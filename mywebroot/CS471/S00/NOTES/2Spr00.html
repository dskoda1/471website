<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Eileen Head">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; U) [Netscape]">
   <title>Introduction To Programming Languages- CS471 -2</title>
</head>
<body>

<center>
<h3>
&nbsp; Introduction Spring, 2000</h3></center>

<center><table BORDER CELLSPACING=0 CELLPADDING=0 BGCOLOR="#FFFFF0" >
<tr>
<td><a href="http://bingweb.binghamton.edu/~head/CS471/NOTES/1Spr00.html">&nbsp;previous</a></td>

<td><a href="http://bingweb.binghamton.edu/~head/CS471/NOTES/3Spr00.html">&nbsp;next&nbsp;</a></td>
</tr>
</table></center>

<h3>
What will be covered ?</h3>

<ul>
<li>
History of programming languages</li>

<li>
<font color="#990000">Different Language Paradigms</font></li>

<li>
Implementation and Run Time Environment</li>
</ul>

<h3>

<hr WIDTH="100%"><font color="#000000">Imperative Paradigm and Declarative
Paradigm</font></h3>

<ul>
<li>
Most languages belong to one of these distinct paradigms</li>

<br>
<hr WIDTH="100%">
<li>
Imperative paradigm focus is on <i>how</i> the machine does what you want.</li>

<ul>
<li>
Execution through state change.</li>

<li>
Key operation: assignment (side-effects)</li>
</ul>

<li>
Three key concepts</li>

<ul>
<li>
variables</li>

<li>
assignments</li>

<li>
sequencing</li>
</ul>

<li>
Examples</li>

<ul>
<li>
Structured control : C, Pascal</li>

<li>
Encapsulation: Modula 2, C++</li>

<li>
Object-Orientation: Smalltalk, Java</li>

<li>
Concurrency:&nbsp; Ada, Java, Concurrent Pascal</li>
</ul>

<p><br>
<hr WIDTH="100%">
<li>
Declarative paradigm focus is on <i>what</i> the computer will do.</li>

<ul>
<hr WIDTH="100%"></ul>

<li>
Functional language</li>

<ul>
<li>
Execution via <i>evaluation</i></li>

<ul>
<li>
Based on formal computational model of lambda calculus</li>
</ul>

<li>
Key operation: function application</li>

<li>
Examples:</li>

<ul>
<li>
eager evaluation: Lisp, ML, Scheme</li>

<li>
lazy evaluation: Miranda, Haskell</li>
</ul>
</ul>

<li>
Logic or constraint-based languages</li>

<ul>
<li>
Execution based on <i>deduction</i></li>

<ul>
<li>
based on predicate calculus using a proof method called resolution</li>

<ul>
<li>
Robinson (1965)</li>
</ul>

<li>
attempts to find values that satisfy certain specific relationships, using
a goal directed search through a list of logical rules.</li>
</ul>

<li>
Key operation: unification</li>

<li>
Example: Prolog</li>
</ul>
</ul>

<hr WIDTH="100%">
<center><a href="mailto: head@binghamton.edu">&copy; 2000 Head,Lander</a></center>

<hr WIDTH="100%">
<center><table BORDER CELLSPACING=0 CELLPADDING=0 BGCOLOR="#FFFFF0" >
<tr>
<td><a href="http://bingweb.binghamton.edu/~head/CS471/NOTES/1Spr00.html">&nbsp;previous&nbsp;</a></td>

<td><a href="http://bingweb.binghamton.edu/~head/CS471/NOTES/3Spr00.html">&nbsp;next&nbsp;</a></td>
</tr>
</table></center>

<br>&nbsp;
<p>1/21/00
</body>
</html>
