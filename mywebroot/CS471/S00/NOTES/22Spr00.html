<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Head/ Lander">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; U) [Netscape]">
   <meta name="Description" content="CS471 spr 00">
   <title>Thread Examples</title>
</head>
<body text="#000000" bgcolor="#F5F5F5" link="#00FF00" vlink="#666666" alink="#FF0000">
&nbsp;
<center><table BORDER CELLSPACING=0 CELLPADDING=0 BGCOLOR="#FFFFF0" >
<tr>
<td><a href="http://bingweb.binghamton.edu/~head/CS471/NOTES/21Spr00.html">&nbsp;previous</a></td>

<td><a href="http://bingweb.binghamton.edu/~head/CS471/NOTES/22Spr00.html">&nbsp;next&nbsp;</a></td>
</tr>
</table></center>

<center>
<h3>
INHERITANCE</h3></center>

<center>
<h3>
&copy; Eileen Head, Leslie C. Lander, 2000</h3></center>
Purpose:&nbsp; To expose student to properties of inheritance in object
oriented languages.
<h3>

<hr WIDTH="100%">IMPLEMENTING INHERITANCE</h3>

<ul>
<li>
First, consider the data fields</li>

<pre>class A{&nbsp;
&nbsp;&nbsp;&nbsp; int a;&nbsp;
&nbsp;&nbsp;&nbsp; ...
}
class B extends A {&nbsp;
&nbsp;&nbsp;&nbsp; int b;&nbsp;
&nbsp;&nbsp;&nbsp; ...
}
class C extends B{
&nbsp;&nbsp;&nbsp; int c;&nbsp;
&nbsp;&nbsp;&nbsp; ...
}</pre>
</ul>

<h3>
how is access to <i>c</i> coded</h3>

<ul>
<li>
Storage of an object: C objC;</li>
</ul>

<center><img SRC="inher1.gif" height=141 width=232></center>

<h3>
offsets again</h3>

<ul>
<li>
Access to storage:</li>

<li>
To access the variable "c" the compiler will need to insert an address
computation such as:</li>

<pre>ref + (offset of C part) + (offset of c in C part)</pre>

<pre>i.e. ref + size(A part) + size(B part) + (offset of c in C part)</pre>
</ul>

<h3>
give the compiler warning that c is accessible</h3>

<ul>
<li>
In either case, the values of the offsets and sizes are determined during
compilation</li>

<li>
You can only access "c" of an instance, whose static type is C</li>

<li>
Note that the compiler is not required to actually store the A, B and C
records in the order shown</li>
</ul>

<h3>
Multiple inheritance is bad news</h3>

<ul>
<li>
The corresponding problems of multiple inheritance (C++):</li>

<pre>class A{&nbsp;
&nbsp;&nbsp;&nbsp; int a;&nbsp;
&nbsp;&nbsp;&nbsp; protected void funA( )
&nbsp;&nbsp;&nbsp; ...
}</pre>

<pre>class B{&nbsp;
&nbsp;&nbsp;&nbsp; int b;&nbsp;
&nbsp;&nbsp;&nbsp; protected void funB( )
&nbsp;&nbsp;&nbsp; ...
}</pre>

<pre>class C: public A, public B {
&nbsp;&nbsp;&nbsp; ...
}</pre>
</ul>

<h3>
Looks the same at first</h3>

<ul>
<li>
Storage of an object: C* objC;</li>
</ul>

<center><img SRC="inher1.gif" height=141 width=232></center>

<h3>
B alone is quite normal</h3>

<ul>
<li>
Access to storage:</li>

<li>
How does the call "objC->funB( )" access "b"?</li>

<li>
First, consider what happens when we have:</li>

<pre>B objB;&nbsp;
objB->funB( );</pre>

<li>
Apparently, the address of objB’s storage is passed to funB</li>
</ul>

<h3>
Meaning of <i>this</i></h3>

<ul>
<li>
There will only be one copy of the code for "funB"</li>

<li>
To tell "funB" which object record to access, the pointer to objB’s storage
is passed as an implicit parameter to funB (called "this")</li>
</ul>

<center><img SRC="inher2.gif" height=89 width=259></center>

<h3>
Accessing B from code for C</h3>

<ul>
<li>
When "funB" accesses "b" the computation is simple:</li>

<pre>address of objB + (offset of b in B record)</pre>

<li>
Now we return to objC->funB( )</li>
</ul>

<h3>
Compilers have to avoid a mistake</h3>

<ul>
<li>
The call objC->funB( );</li>
</ul>

<center><img SRC="inher3.gif" height=143 width=259></center>

<h3>
Do not pass the obvious pointer to funB</h3>

<ul>
<li>
It is a mistake to pass the address of objC to fun B because the computation:</li>

<pre>address of objC + (offset of b in B record)</pre>
does not get to "b": it lands some-where in the A part !
<li>
Remember the code of funB cannot know about the inherited class C</li>

<li>
Somehow the call to funB needs the right pointer</li>

<li>
Whenever the compiler has a call objC->funB( ) it has to know to translate
the address passed to funB as: address of objC + size(A part) + (offset
of b in B record)</li>
</ul>

<h3>
pass <i>this</i> with an extra offset</h3>

<ul>
<li>
The call objC->funB( );</li>
</ul>

<center><img SRC="inher4.gif" height=156 width=291></center>

<h3>
Run-time checks are needed</h3>

<ul>
<li>
BUT … the compiler cannot always tell which address is appropriate:</li>

<pre>B* ptrB;&nbsp;
cin >> ch;&nbsp;
if (ch == 'A') ptrB = new B;&nbsp;
else ptrB = new C; ptrB->funB( );&nbsp;
// there must be code in place to decide the correct "this"</pre>
</ul>

<h3>
Solutions?</h3>

<ul>
<li>
There are probably several solutions but they are not clear to me:</li>

<li>
Ellis &amp; Stroustrup (p.229) suggest storing the offset in the virtual
method table (vtbl). The vtbl is discussed below</li>

<li>
Terribile suggests (p.356) suggests extra "virtual functions" added by
the compiler</li>
</ul>

<h3>
Overridable functions</h3>

<ul>
<li>
So now we have to talk about</li>
</ul>

<center>
<h3>
VIRTUAL FUNCTIONS</h3></center>

<ul>
<li>
All non-final, instance methods in Java are virtual but in C++ they must
be declared virtual</li>

<pre>class A {&nbsp;
&nbsp;&nbsp;&nbsp; virtual void funA( ){
&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp; }&nbsp;
}</pre>
</ul>

<h3>
overriding in action</h3>

<ul>
<li>
If a virtual function is redefined in a subclass then it is the subclass
version that is called when an instance of the subclass makes the call
even if that object was declared to be of the parent class</li>

<li>
The dynamic type determines which method to call</li>
</ul>

<h3>
Simple C++</h3>

<blockquote>
<pre>class A {&nbsp;
&nbsp;&nbsp;&nbsp; public virtual void funA( ) {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; 1;&nbsp;
&nbsp;&nbsp;&nbsp; }&nbsp;
}</pre>

<pre>class B : public A {&nbsp;
&nbsp;&nbsp;&nbsp; void funA( ) {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout &lt;&lt; 2;&nbsp;
&nbsp;&nbsp;&nbsp; }&nbsp;
}</pre>
</blockquote>

<h3>
override</h3>

<ul>
<pre>...
A* ptrA = new B;&nbsp;
ptrA->funA( );&nbsp;
// returns 2 because ptrA is currently pointing to a B object</pre>

<li>
Virtual functions are implemented using virtual method tables called a
vtbl in the books from AT&amp;T people, called vmt in some references</li>
</ul>

<h3>
Simple example</h3>

<blockquote>
<li>
Consider Java code:</li>

<pre>class A {&nbsp;
&nbsp;&nbsp;&nbsp; void f ( ) { ... }
&nbsp;&nbsp;&nbsp; void g ( ) { ... }
}</pre>

<pre>class B extends A {
&nbsp;&nbsp;&nbsp; void f ( ) { ... }
&nbsp;&nbsp;&nbsp; void h ( ) { ... }
}</pre>

<pre>class C extends B {
&nbsp;&nbsp;&nbsp; void f ( ) { ... }
}</pre>

<li>
Only one copy of the code of any method is stored and it is stored with
the class</li>

<li>
The class also has a virtual method table</li>
</blockquote>

<h3>
vmts</h3>

<table>
<tr>
<td>
<blockquote>
<pre>class A {&nbsp;
&nbsp;&nbsp;&nbsp; void f ( ) { ... }
&nbsp;&nbsp;&nbsp; void g ( ) { ... }
}</pre>
</blockquote>
</td>

<td>
<pre>&nbsp;---------------
|&amp; (code of A.f)|
|&amp; (code of A.g)|
&nbsp;---------------</pre>
</td>
</tr>

<tr>
<td>
<blockquote>
<pre>class B extends A {
&nbsp;&nbsp;&nbsp; void f ( ) { ... }&nbsp;
&nbsp;&nbsp;&nbsp; void h ( ) { ... }
}</pre>
</blockquote>
</td>

<td>
<pre>&nbsp;---------------
|&amp; (code of B.f)|
|&amp; (code of A.g)|
|&amp; (code of B.h)|
&nbsp;---------------</pre>
</td>
</tr>

<tr>
<td>
<blockquote>
<pre>class C extends B {
&nbsp;&nbsp;&nbsp; void f ( ) { ... }
}</pre>
</blockquote>
</td>

<td>
<pre>&nbsp;---------------
|&amp; (code of C.f)|
|&amp; (code of A.g)|
|&amp; (code of B.h)|
&nbsp;---------------</pre>
</td>
</tr>
</table>

<h3>
objects point to the vmt</h3>

<ul>
<li>
Suppose we write new B( );</li>

<li>
Then we create a B object</li>

<li>
That B object must contain a pointer to the vmt for B, as shown:</li>
</ul>

<center><img SRC="vmt1.gif" height=74 width=283></center>

<h3>
Accessing the vmt</h3>

<ul>
<li>
Suppose we declare and instantiate as follows:</li>

<pre>A a = new C( );</pre>

<li>
Because of the static type we can only call a.f( ) and a.g( )--unless we
use a "cast" to inform the compiler that a subtype is expected</li>

<li>
But the object C has a pointer to the vmt of class C!</li>

<li>
a.g( ) means "call method whose address is a.vmt[1]," in other words the
version of the code called C.f( )</li>
</ul>

<h3>
vtbl/vmt</h3>

<ul>
<li>
The instance-records have pointers to vtbl’s (one vtbl for each part in
the case of inherited classes)</li>

<li>
It is easier to look at single inheritance as in Java</li>

<li>
The book by Terribile has some terrifying figures of the complexity of
the vmt, when you have "virtual" multiple inheritance</li>
</ul>

<h3>
More on multiple inheritance</h3>

<blockquote>
<pre>class A{&nbsp;
&nbsp;&nbsp;&nbsp; int a;&nbsp;
&nbsp;&nbsp;&nbsp; public void funA( )
&nbsp;&nbsp;&nbsp; ...
}</pre>

<pre>class B{&nbsp;
&nbsp;&nbsp;&nbsp; int b;&nbsp;
&nbsp;&nbsp;&nbsp; public void funB( )&nbsp;
&nbsp;&nbsp;&nbsp; ...
}</pre>

<pre>class C: public A, public B {&nbsp;
&nbsp;&nbsp;&nbsp; int c;&nbsp;
&nbsp;&nbsp;&nbsp; public void funC( )
&nbsp;&nbsp;&nbsp; ...
}</pre>
</blockquote>

<h3>
A real main function</h3>

<ul>
<pre>void main(){
&nbsp;&nbsp;&nbsp; A* a = new C();
&nbsp;&nbsp;&nbsp; ((B*)a)->funB();
}</pre>

<li>
Casting may override the dynamic type of a variable</li>

<li>
Consider:</li>

<pre>A* a = new C( );&nbsp;
((B*)a)->funB( );</pre>
even if funB were redefined in C, the casting requires a call to B’s version
of funB</ul>

<h3>
Dynamic Casting?</h3>

<ul>
<li>
Is this possible?</li>
</ul>

<center><img SRC="multher1.gif" height=108 width=217></center>

<h3>
Recall Real code</h3>

<ul>
<pre>#include "iostream.h"
class A {&nbsp;
&nbsp;&nbsp;&nbsp; public:
&nbsp;&nbsp;&nbsp; void funA() {cout&lt;&lt;1&lt;&lt;"\n";}
};</pre>

<pre>class B {&nbsp;
&nbsp;&nbsp;&nbsp; public:&nbsp;
&nbsp;&nbsp;&nbsp; void funB() {cout&lt;&lt;2&lt;&lt;"\n";}
};</pre>

<pre>class C: public A,public B {
&nbsp;&nbsp;&nbsp; public:&nbsp;
&nbsp;&nbsp;&nbsp; void funC() {cout&lt;&lt;3&lt;&lt;"\n";}
};</pre>

<pre>void main(){
&nbsp;&nbsp;&nbsp; A* a = new C();
&nbsp;&nbsp;&nbsp; ((B*)a)->funB();
}</pre>

<li>
&nbsp;The above works with GCC</li>

<li>
Another version compiles but gives "Segmentation fault." This version uses
the same main( ), but modify B and C as follows</li>

<pre>#include "iostream.h"
class A {&nbsp;
&nbsp;&nbsp;&nbsp; public:
&nbsp;&nbsp;&nbsp; void funA() {cout&lt;&lt;1&lt;&lt;"\n";}
};</pre>

<pre>class B {&nbsp;
&nbsp;&nbsp;&nbsp; public:&nbsp;
&nbsp;&nbsp;&nbsp; virtual void funB() {cout&lt;&lt;2&lt;&lt;"\n";}
};</pre>

<pre>class C: public A,public B {
&nbsp;&nbsp;&nbsp; public:&nbsp;
&nbsp;&nbsp;&nbsp; void funB() {cout&lt;&lt;3&lt;&lt;"\n";}
};</pre>
</ul>

<h3>
Diamond Problem</h3>

<ul>
<li>
Consider:</li>

<pre>class A {&nbsp;
&nbsp;&nbsp;&nbsp; int a;&nbsp;
&nbsp;&nbsp;&nbsp; ...
}&nbsp;
class B : public A {
&nbsp;&nbsp;&nbsp; ...
}
class C : public A {
&nbsp;&nbsp;&nbsp; ...
}
class D : public B, public C {
&nbsp;&nbsp;&nbsp; ...
}</pre>

<li>
D-objects get 2 copies of A’s data: …</li>

<pre>class D {&nbsp;
&nbsp;&nbsp;&nbsp; void funD( ) {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B->a = 1;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C->a = 2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // separate a’s, different values stored
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; ...
}</pre>
</ul>

<h3>
The locations of the two a’s</h3>

<center><img SRC="multher2.gif" height=183 width=217></center>

<h3>
Virtual multiple inheritance</h3>

<ul>
<li>
Virtual multiple inheritance is the answer:</li>

<pre>class A {&nbsp;
&nbsp;&nbsp;&nbsp; int a;&nbsp;
&nbsp;&nbsp;&nbsp; ...
}&nbsp;
class B : virtual public A {
&nbsp;&nbsp;&nbsp; ...
}
class C : virtual public A {
&nbsp;&nbsp;&nbsp; ...
}
class D : public B, public C {
&nbsp;&nbsp;&nbsp; ...
}</pre>
</ul>

<h3>
Only one copy of "a"</h3>

<center><img SRC="multher3.gif" height=180 width=219></center>

<h3>
Graphic from Terribile</h3>

<ul>
<li>
Terribile shows separate vmt ’s for each class in a hierarchy, even for
simple inheritance in C++</li>

<li>
This graphic is for virtual multiple inheritance (we refere the reader
to the book)</li>
</ul>

<h3>
Quote from Terribile</h3>

<blockquote>"The object layout with virtual multiple inheritance is much,
much hairier than without. We will only touch on the issue; the complications
are superabundant, interesting, esoteric, and far into the realm of compiler
writers, language designers, and other practitioners of arcane arts."</blockquote>

<p>
<hr WIDTH="100%">
<center><table BORDER CELLSPACING=0 CELLPADDING=0 BGCOLOR="#FFFFF0" >
<tr>
<td><a href="http://bingweb.binghamton.edu/~head/CS471/NOTES/21Spr00.html">&nbsp;previous</a></td>

<td><a href="http://bingweb.binghamton.edu/~head/CS471/NOTES/22Spr00.html">&nbsp;next&nbsp;</a></td>
</tr>
</table></center>

<br>&nbsp;
<br>&nbsp;
</body>
</html>
