<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Les Lander">
   <meta name="GENERATOR" content="Mozilla/4.72 [en] (WinNT; U) [Netscape]">
   <title>471 Haskell execution</title>
</head>
<body>
&nbsp;
<center><table BORDER CELLSPACING=0 CELLPADDING=0 BGCOLOR="#FFFFF0" >
<tr>
<td><a href="http://bingweb.binghamton.edu/~head/CS471/NOTES/16Spr00.html">&nbsp;previous</a></td>

<td><a href="http://bingweb.binghamton.edu/~head/CS471/NOTES/18Spr00.html">&nbsp;next&nbsp;</a></td>
</tr>
</table></center>

<center>
<h3>
Haskell 5</h3></center>

<center>
<h3>
&copy; Eileen Head, Leslie C. Lander, 2000</h3></center>
Purpose: To examine some execution issues.
<h4>

<hr WIDTH="100%">Execution Issues: A few things to think about</h4>

<ul>
<li>
Lazy adds a new dimension</li>

<li>
All programmers should take a course on Algorithms</li>

<li>
However, the principles applied in a traditional course will not necessarily
apply to parallel computations, nor to programming environments with lazy
evaluation</li>

<li>
Calculating [1..n] uses constant space: you only need to store the expression
for what is not evaluated</li>
</ul>

<h3>
From Haskell book Chap 15 (1st edition) 19.4 (2nd edition)</h3>

<ul>
<pre>[1..n] = <u>1</u>:[2..n] = <u>1:2</u>:[3..n] = ... = <u>1:2:3:…:n</u>:[]</pre>

<li>
The underlined parts are not stored; they are used when they are generated
and then discarded</li>

<li>
Computation time is linear</li>
</ul>

<h3>
Danger in “where”</h3>

<ul>
<li>
<tt>[1..n] ++ [1..n]</tt> uses constant storage, e.g. in the expression</li>

<pre>([1..n]++[1..n])!!(n+ n`div`2)</pre>
although the list is calculated twice, while
<pre>list ++ list where list = [1..n]</pre>
uses space linear in n</ul>

<h3>
Rule of thumb</h3>

<ul>
<li>
“…while it is always sensible not to repeat a calculation of a simple value,
saving a compound value like a list or a tuple can increase the space usage
of a program.”</li>

<li>
Keeping hold of a large data structure when we only need part of it is
called the <i>dragging problem</i></li>

<li>
In large systems it can be hard to locate dragging</li>
</ul>

<h3>
Clever tricks with auxiliary functions</h3>

<blockquote>
<pre>> fib :: Int -> Int
> fib 1 = 1
> fib 2 = 1
> fib n = fib (n-2) + fib (n-1)</pre>

<li>
Faster version:</li>

<pre>> fib1 1 = 1
> fib1 n = fiba n 1 0 1
>&nbsp;&nbsp; where
>&nbsp;&nbsp; fiba n c a b =
>&nbsp;&nbsp;&nbsp;&nbsp; if c == n then b
>&nbsp;&nbsp;&nbsp;&nbsp; else fiba n (c+1) b (a+b)</pre>
</blockquote>

<h3>
Linear</h3>

<ul>
<pre>fiba 7 1 0 1&nbsp;
=> fiba 7 2 1 1&nbsp;
=> fiba 7 3 1 2&nbsp;
=> fiba 7 4 2 3&nbsp;
=> fiba 7 5 3 5&nbsp;
=> fiba 7 6 5 8&nbsp;
=> fiba 7 7 8 13&nbsp;
=> 13</pre>

<li>
The number of recursive calls is linear in n. Compare this to</li>
</ul>

<h3>
Exponential</h3>

<blockquote>
<pre>fib 7
=> fib 5 + fib 6
=> fib 3 + fib 4 + fib 4 + fib 5
=> fib 1 + fib 2 + fib 2 + fib 3
&nbsp;&nbsp; +fib 2 + fib 3 + fib 3 + fib 4
=> 1 + fib 0 + fib 1 + fib 0
&nbsp;&nbsp; +fib 1 + fib 1 + fib 2 + fib 0
&nbsp;&nbsp; +fib 1 + fib 1 + fib 2 + fib 1
&nbsp;&nbsp; +fib 2 + fib 2 + fib 3
=> ...</pre>

<li>
exponential (#calls > fib n)</li>
</blockquote>

<h3>
Fibonacci really is exponential</h3>

<ul>
<pre>fibonacci(<i>n</i>) = [(1 + sqrt(5))<i><sup>n</sup></i> - (1 - sqrt(5))<i><sup>n</sup></i>]/ 2<i><sup>n</sup></i> sqrt(5)</pre>
and we can show (1.6)<sup><i>n </i>- 2</sup> &lt; fibonacci(<i>n</i>) &lt;
(1.7)<sup><i>n </i>- 1</sup> for <i>n</i> > 2
<li>
Compare the performance of fib1 20 and fib 20</li>
</ul>

<h3>
Using Complex Data Structure to save Computation Time</h3>

<ul>... Using <i>where&nbsp;</i> and
<br>Memoization
<p><tt>> fib3 n = fNum</tt>
<br><tt>>&nbsp;&nbsp; where</tt>
<br><tt>>&nbsp;&nbsp; (fNum,_) = fibP n</tt>
<br><tt>>&nbsp;&nbsp; fibP 0 = (0,1)</tt>
<br><tt>>&nbsp;&nbsp; fibP n = (y,x+y)</tt>
<br><tt>>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where</tt>
<br><tt>>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (x,y) = fibP (n-1)</tt>
<br>&nbsp;
<li>
This solution runs in linear time and linear space</li>
</ul>

<h3>
More power in lazy evaluation</h3>

<ul>…and at the same time use the list for the computation
<br>&nbsp;
<pre>> fib2 n = fibs !! n
>&nbsp;&nbsp; where
>&nbsp; fibs = 0:1:zipWith (+) fibs (tail fibs)</pre>

<li>
The initial “0” stands for “fib2 0,” which is not normally defined, used
since lists are indexed from 0</li>

<li>
Remember: only compute as much of the list as is needed</li>

<h3>
Details</h3>

<ul>
<pre>fibs = 0:1:1:2:3:5:8:13:21:34:...
tail fibs=1:1:2:3:5:8:13:21:34:...</pre>

<pre>0:1:zipWith (+) fibs (tail fibs)
=> 0:1:zipWith (+)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0:1:1:2:3:5 :8 :13:21:34:...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1:1:2:3:5:8 :13:21:34:55:...
=> 0:1:1:2:3:5:8:13:21:34:55:89:…</pre>

<li>
Every value that is computed is stored in the list and reused</li>

<li>
<tt>fib2 </tt>runs in linear time</li>

<dl>
<dl>
<li>
AND because of lazy evaluation <tt>fib2 </tt>has only constant space requirements.</li>
</dl>
</dl>
</ul>

<hr SIZE=0 NOSHADE WIDTH="100%"></ul>

<h3>
Factorial Recursive definition</h3>

<ul><tt>> factorial 0 = 1</tt>
<br><tt>> factorial n = n*factorial (n-1)</tt>
<blockquote><tt>or using if/else statement</tt></blockquote>
<tt>> fact n = if ( n==0) then 1 else n*fact (n-1)</tt>
<br>&nbsp;
<li>
Notice the form of the execution tree:</li>

<br><a href="17fact.gif"><img SRC="17fact.gif" ALT="Recursive Factorial Function" BORDER=0 height=275 width=222></a></ul>

<h3>
The fibonacci trick with factorial--not as effective</h3>

<blockquote>
<pre>> fact2 n = facts !! n
>&nbsp; where
>&nbsp;&nbsp; facts = 1:1:zipWith (*) [2..] (tail facts)</pre>

<pre>facts = 1:1:2:6:24:120:720:...
tail facts = 1:2:6:24:120:720:...
[2..]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 2:3:4: 5:&nbsp; 6:&nbsp; 7:...</pre>

<pre>1:1:zipWith (*)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2:3:4: 5:&nbsp; 6:&nbsp; 7:&nbsp;&nbsp; 8:&nbsp;&nbsp;&nbsp; 9:...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1:2:6:24:120:720:5040:40320:...
=> 1:1:2:6:24:120:720:5040:40320…</pre>
</blockquote>

<h3>
Other versions of factorial</h3>

<blockquote>
<pre>> fact 0 = 1
> fact n = n* fact(n-1)</pre>

<pre>> fact1 n = facta n 0 1
>&nbsp; where
>&nbsp;&nbsp; facta n c k = if (c == n) then k&nbsp;
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else facta n (c+1) (c+1)*k</pre>
</blockquote>

<h3>
Tail recursion</h3>

<ul>
<li>
<tt>gcd u v = if (v == 0) then u else gcd v (mod u v)</tt></li>

<br><a href="17gcd.gif"><img SRC="17gcd.gif" ALT="Execution Tree for gcd 12 9" BORDER=0 height=300 width=264></a>
<br>&nbsp;
<li>
One important feature of facta and fiba is that they are tail recursive:</li>

<pre>facta n c k = if (c==n) then k else facta n (c+1) (c+1)*k</pre>

<pre>fiba n c a b = if c == n then b else fiba n (c+1) b (a+b)</pre>

<pre></pre>
</ul>

<h3>
The general form of tail recursion</h3>

<ul>
<pre>f(x) = if p(x) then q(x) else f (h(x))</pre>

<li>
A good compiler can replace tail recursion by a loop automatically</li>

<li>
The argument x can be a sequence of arguments or a tuple</li>

<pre>f(x,y,z) = if p(x,y,z) then q(x,y,z) else f(x',y',z')</pre>

<pre>f x y z = if p x y z then q x y z else f x' y' z'</pre>
</ul>

<h3>
Iterative form</h3>

<ul>
<li>
The corresponding iterative code is:</li>

<pre>type2 f(type1 x) {&nbsp;
&nbsp;&nbsp;&nbsp; type1 t = x;&nbsp;
&nbsp;&nbsp;&nbsp; while (true) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (p(t)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return q(t);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t = h(t);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
}</pre>

<li>
Apply the transformation to:</li>

<pre>facta n c k = if (c == n) then k else facta n (c+1) (c+1)*k</pre>
</ul>

<h3>
Iterative form of facta</h3>

<blockquote>
<pre>facta n c k = if (c==n) then k else facta n (c+1) (c+1)*k</pre>

<pre>int iterfacta(int n,int c,int k){
&nbsp;&nbsp;&nbsp; int tn = n; // not really needed IN THIS CASE
&nbsp;&nbsp;&nbsp; int tc = c;&nbsp;
&nbsp;&nbsp;&nbsp; int tk = k;
&nbsp;&nbsp;&nbsp; while (true) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tc == tn) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tk;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tn = tn;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tc++;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tk *= tc;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
}</pre>
</blockquote>

<h3>
Comments</h3>

<ul>
<li>
These linear iterations use very little space since no recursive calls
are made</li>

<li>
We see later the effect of calling subprograms on space</li>

<li>
Other functions such as fiba and gcd are also tail recursive and can be
converted to high-speed loops by a compiler</li>
</ul>

<h3>
Iterative version of fiba</h3>

<blockquote>
<pre>fiba n c a b = if c == n then b else fiba n (c+1) b (a+b)</pre>

<pre>int iterFiba(int n,int c,int a,int b){&nbsp;
&nbsp;&nbsp;&nbsp; int tn = n;&nbsp;
&nbsp;&nbsp;&nbsp; int tc = c;&nbsp;
&nbsp;&nbsp;&nbsp; int ta = a;&nbsp;
&nbsp;&nbsp;&nbsp; int tb = b;&nbsp;
&nbsp;&nbsp;&nbsp; while (true) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tc == tn) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tb;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tn=tn;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tc++;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int t = ta;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ta = tb;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tb += t;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
}</pre>
</blockquote>

<h3>
Iterative form of gcd (assumes one input is not 0)</h3>

<blockquote>
<pre>gcd m n = if n == 0 then m else gcd (n, m `mod` n)</pre>

<pre>int itergcd(int m, int n) {&nbsp;
&nbsp;&nbsp;&nbsp; int tm = m;&nbsp;
&nbsp;&nbsp;&nbsp; int tn = n;&nbsp;
&nbsp;&nbsp;&nbsp; while (true) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tn == 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tm;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int t = tm;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tm = tn;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tn = t `mod` tn;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
}</pre>
</blockquote>

<h3>
Kieburtz and Shultis</h3>

<ul>
<li>
Not all recursive functions are tail recursive. If a function is not tail
recursive, an accumulating parameter will need to be introduced.</li>

<li>
There is substantial research into this area.</li>

<li>
One very nice result is due to Kieburtz and Shultis.</li>

<li>
Suppose f has the form:</li>
</ul>

<h3>
Format for Kieburtz and Shultis</h3>

<blockquote>
<pre>f x = if p x then q x else r (g x) (f (h x))</pre>
where r is ASSOCIATIVE, i.e.<tt> r x (r y z) = r (r x y) z</tt>
<br>or infix: <tt>x `r` (y `r` z) = (x `r` y) `r` z</tt>
<br>then f can be transformed into the iteration:</blockquote>

<h3>
Iterative form</h3>

<blockquote>
<pre>type2 f(type1 x) {
&nbsp;&nbsp;&nbsp; type1 t = x;&nbsp;
&nbsp;&nbsp;&nbsp; type2 acc;&nbsp;
&nbsp;&nbsp;&nbsp; if (p(t)) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return q(t);
&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; acc := g(t);
&nbsp;&nbsp;&nbsp; } //see note&nbsp;
&nbsp;&nbsp;&nbsp; while(true) {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t = h(t);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (p(t)) (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return r(acc,q(t));&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; acc = r(acc,g(t));&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
}</pre>
</blockquote>

<h3>
Some K&amp;S functions</h3>

<ul>
<li>
Note: In general you cannot assign to “acc” before checking that “p(t)”
is false.</li>

<li>
It can be the case that “g(t)” is undefined when “p(t)” is true, e.g. when
p(t) is (t == 0) and g(t) is 1/t</li>

<li>
The functions factorial and length are of the K&amp;S form</li>
</ul>

<h3>
factorial</h3>

<ul>
<pre>fact n = if n == 0 then 1 else n * fact(n-1)</pre>

<pre>r is multiply (*);&nbsp;&nbsp;
g(n) = n&nbsp;
q(n) = 1;&nbsp;
h(n) = n-1;&nbsp;
p is (0==)</pre>

<li>
The iterative form is on the next slide</li>

<li>
Notice that the iterative code simply modifies two memory locations until
a predicate is satisfied</li>
</ul>

<h3>
Iterative version</h3>

<blockquote>
<pre>long f(int x) {
&nbsp;&nbsp;&nbsp; int t = x;&nbsp;
&nbsp;&nbsp;&nbsp; long acc;&nbsp;
&nbsp;&nbsp;&nbsp; if (t==0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;
&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; acc := t;&nbsp;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; while(true) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t = t-1;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (t==0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return acc*1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; acc = acc*t;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; }
}</pre>
</blockquote>

<h3>
Garbage</h3>

<ul>
<li>
Functional languages generate many temporary data structures during execution</li>

<li>
The data structures may be shared among several temporary variables, e.g.
there may be several variables pointing at different parts of a list</li>

<li>
Temporary storage stops being useful as soon as a function evaluation is
complete...</li>
</ul>

<h3>
Garbage collection</h3>

<ul>…it becomes garbage
<li>
A program would soon run out of memory if the memory storing the garbage
were not cleared for reuse</li>

<li>
This needs to be an automatic process since the programmer has no control
of memory allocation</li>

<li>
The automatic process is called garbage collection</li>
</ul>

<h3>
Garbage collection</h3>

<ul>
<li>
In fact, garbage collection is also important for object-oriented systems
and Java provides automatic garbage collection</li>

<li>
Functional programming environments must provide garbage collection to
be able to make larger computations or run for a longer time</li>

<li>
We may look at techniques for garbage collection later</li>
</ul>

<hr WIDTH="100%">
<center><table BORDER CELLSPACING=0 CELLPADDING=0 BGCOLOR="#FFFFF0" >
<tr>
<td><a href="http://bingweb.binghamton.edu/~head/CS471/NOTES/16Spr00.html">&nbsp;previous</a></td>

<td><a href="http://bingweb.binghamton.edu/~head/CS471/NOTES/18Spr00.html">&nbsp;next&nbsp;</a></td>
</tr>
</table></center>

</body>
</html>
