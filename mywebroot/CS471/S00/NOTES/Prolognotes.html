<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.61 [en] (WinNT; U) [Netscape]">
   <title>Logic Programming and Prolog</title>
</head>
<body>

<center>
<h1>
<b>Logic Programming and Prolog</b></h1></center>
Non-procedural languages have been developed to make programming
<i>easier</i>
rather than harder. Their unusual syntax and approach make them confusing
for programmers experienced with Ada, Basic, C, Cobol, Fortran, Pascal,
PL/I, etc. We shall see later that one strength of functional programming
is that functional programs correspond very closely to functional specifications,
which are very natural descriptions of what software should do in many
cases. Thus programs correspond much more to the designs of the algorithms
the program uses. One of the features introduced by <b>logic programming</b>
is to attempt automatic programming: given that a programmer can give a
precise description of <i>what</i> is to be computed, the programming language
should provide the <i>how</i>. Prolog is a partial implementation of the
ideas behind logic programming.
<p><b>A Simple Program</b>
<p>The following is a mathematical definition of the factorial function:
<center>
<p><img SRC="img00025.gif" ></center>

<p>Now the Prolog is similar:
<p><b>factorial(0, 1).</b>
<p><b>factorial(N, M):- N1 is N - 1, factorial (N1, M1), M is N<font face="Symbol">*</font>M1.</b>
<p>This code abounds with special things to remember. The commas outside
of parentheses mean <i>and</i>. The ':-' means <i>if</i>. The keyword 'is'
is assignment, but "N is N-1" has no meaning in Prolog-there is <b>no</b>
destructive assignment. There are no functions in Prolog, only <i>relations</i>.
When we write 'factorial(N, M)' we are saying "N is related to M by the
relation 'factorial'." The order is not important provided it is used consistently.
The assertions about the relation 'factorial' end with a period. Variable
names <i>begin with upper-case letters</i>, constants are numbers or names
beginning with a lower-case letter.
<p>We can now read the Prolog code:
<p><b>factorial(0, 1).</b> /<font face="Symbol">* </font>It is a fact that
the factorial of 0 is 1<font face="Symbol">*</font>/
<p><b>factorial(N, M) :- N1 is N - 1,</b> /<font face="Symbol">*
</font><u>If</u>
temporary variable N1 is assigned to N-1<font face="Symbol">*</font>/
<p><b>factorial(N1, M1),</b> /<font face="Symbol">* </font><u>and if</u>
the factorial of N1 is M1<font face="Symbol">*</font>/
<p><b>M is NM1.</b> /<font face="Symbol">* </font><u>and if</u> M is assigned
to N<font face="Symbol">*</font>M1<font face="Symbol">*</font>/
<p>/<font face="Symbol">* </font><u>then</u> the factorial of N is M<font face="Symbol">*</font>/
<p>This is a recursive <i>specification</i> of the relation between a number
N and its factorial M. Prolog reviews the rules about a particular relation
in order, from top to bottom. The input
<p><b><font face="Symbol">?</font> - factorial(2, X).</b>
<p>is resolved as follows (see the figures):
<ul>
<li>
The fact "factorial(0, 1)." does not say anything about factorial(2, X).</li>

<li>
Using the second rule, assign N1 to 2-1 = 1. Next, we have to find "factorial(1,M1)."
This starts a whole new consideration of the rules about factorial.</li>

<li>
To avoid confusion of variable names, we write this new query, which Prolog
makes internally,</li>
</ul>
<b><font face="Symbol">?</font> - factorial(1, X1).</b>
<ul>
<li>
The first rule does not help this time either: "factorial(0, 1)." says
nothing about factorial(1, X1).</li>
</ul>
With the second rule, a new local version of N1 is set to 1-1 = 0 and we
seek "factorial(0, M1)." In the figure we write this internal query as
<p><b><font face="Symbol">?</font> - factorial(0, X2).</b>
<ul>
<li>
The first rule about factorial tells us that X2 is 1. This information
is used to deduce that X1 = 1 <font face="Symbol">*</font> X2 =</li>

<br>1<font face="Symbol">*</font>1 = 1. It follows that M = N<font face="Symbol">*</font>M1
= 2<font face="Symbol">*</font>1 = 2.</ul>
<b>Prolog Implementations available</b>
<p>The best implementation we have to offer at present is on <b>bingsuns</b>.
When using your bingsuns account, type "<b>swipl</b>" to enter the version
of Prolog on that machine. You can edit your Prolog programs using vi or
emacs and then enter swipl.
<p>Once in swipl, suppose your file is called "assig1.log," then you load
it at the Prolog prompt by typing:
<p><b>? - ['assig1.log'].</b>
<p>Note that the period '.' is essential. Swipl compiles Prolog into Warren
Abstract Machine (WAM) instructions and interprets that code. It is relatively
efficient. A user manual is available in the Library Reading Room; the
Computer Center finds it is too long to be left on-line. You can enter
the vi editor from within swipl but since you can switch swipl between
background and foreground, it is simple to edit the files outside swipl
and <b>reload</b> them after each change. The vi editor can be accessed
from within swipl (if your default editor is emacs, this may not work):
<p><b>? - edit('assig1.log').</b>
<p>An alternative implementation is <b>Prolog2</b> which is available in
H1 and can be copied from the Prolog2 directory is a public domain interpreter
for 80x86 machines. Prolog2 has a built-in editor which has commands like
the Turbo Pascal editor. The editor can be accessed from inside Prolog2
as follows:
<p><b>? - edit(assig1).</b>
<p>The editor will create a file called "assig1.pro" in the directory containing
Prolog2. You can also load files as indicated above for swipl. If you wish
to edit a file in another directory, use quotes, for example:
<p><b>? - edit('a:\pro\assig1.pro').</b>
<p>This editor is exited using CTRL-K, D, which returns you to Prolog.
Function keys F3 and F4 moves through previous commands, which saves retyping.
<p>A simple trace facility is very useful for debugging. Suppose you have
defined a relation 'r1' which does not seem to be working. You can follow
the execution of a query ? - r1(...) by typing
<p><b>? - spy(r1).</b>
<p><b>? - r1(...).</b>
<p>To turn off the 'spy' facility, you can try
<p><b>? - nospy(r1).</b>
<p>However, it may be safer to exit Prolog and restart it, since 'nospy'
may not properly reset the environment and so may give strange effects
(at least, this seems to happen in Prolog2).
<p>You can see a listing of relation 'r1' as Prolog has stored it by typing:
<p><b>? - listing(r1).</b>
<p>To exit Prolog type:
<p><b>? - halt.</b>
<p><b>Lists</b>
<p>Prolog has a list construct denoted <b>[...]</b>. Elements are separated
by commas. <b>[0, 2, 4, 9]</b> is a list. The notation <b>[<i>a</i> | L]</b>
adds the element
<i>a</i> at the beginning of the list L, e.g. [3 | [1,
2, 5]] = [3, 1, 2, 5]. There does exist a rarely used alternative notation:
.(<i>a</i>, L). If we write [X | Y], it is understood that the X is the
first element of the list [X | Y] and Y consists of all the other elements,
e.g. if [X | Y] is [3,&nbsp; 1,&nbsp; 2,&nbsp; 5], then X = 3 and Y = [1,
2, 5]. The notation generalizes, e.g., [X, Y, Z | R] is a list with X,
Y and Z as the first 3 elements and R as the rest of the list: [3, 4, 5
| [1, 2, 5]] = [3, 4, 5, 1, 2, 5]. Thus, if [X, Y, Z | R] is [3, 1, 2,
5], then X = 3, Y = 1, Z = 2, and R = [5].
<p><i>Examples</i>: the length of a list (<i>NOTE</i> that [ ] is an empty
list)
<p><b>mylength([ ], 0).</b> /<font face="Symbol">*</font> the prefix "my"
is to avoid redefining built-in relations in some Prolog versions<font face="Symbol">*</font>/
<p><b>mylength([X | Y], N):- mylength(Y, N1), N is N1+1.</b>
<p><b>? - mylength([1, 7, 9], X).</b>
<p>X = 3
<p><b>? - mylength(jim, X).</b>
<p>no
<p><b>mymember(X, [X | _ ]).</b>
<p><b>mymember(X, [ _ | Z]) :- mymember(X, Z).</b>
<p><i>NOTE</i> that the underscore '_' is a "don't-care" variable name.
The above is equivalent to:
<p><b>mymember(X, [X | Y]).</b>
<p><b>mymember(X, [W | Z]) :- mymember(X, Z).</b>
<p>If the underscore occurs twice in the same rule, Prolog interprets it
differently each time, e.g.,
<p><b>? - [1, 3, 4, 6] = [ _, _, _, _ ].</b>
<p>_1 = 1,
<p>_2 = 3,
<p>_3 = 4,
<p>_4 = 6.
<p>The query above could have been written:
<p><b>? - [1, 3, 4, 6] = [X, Y, Z, W].</b>
<p>The following query fails to succeed.
<p><b>? - mymember(a, [b, c, 6]).</b>
<p>no
<p>whereas,
<p><b>? - mymember(a, [b, a, 6]).</b>
<p>yes
<p>We even have the possibility of putting variables where we would normally
have constants. The semicolon (';') in this example has been typed by the
user, followed by a &lt;return>. The 'no' at the end means "no more answers."
<p><b>? - mymember(X, [b, c, 6]).</b>
<p>X = b;
<p>X = c;
<p>X = 6;
<p>no
<p><i>NOTE </i>If you use <b>Prolog2</b>, the system will ask if you want
more solutions and you respond 'y' or 'n.' Typing 'y' corresponds to typing
in the ';&lt;return>' above. Typing 'n' corresponds to typing simply &lt;return>.
<p>The first example illustrates Prolog's interpretation of <i>negation</i>
as a failure in a search. The Prolog version simply gives up without finding
a way to solve the relation 'member (a, [b, c, 6])' and that is interpreted
as negation (i.e., something being false). The following function 'add_to_set'
only inserts an element in a list if it is not already there.
<p><b>add_to_set(X, [ ], [X]).</b>
<p><b>add_to_set(X, Y, Y) :- mymember(X, Y).</b>
<p><b>add_to_set(X, Y, [X | Y]).</b>
<p>The most significant internal operation which is a part of the Prolog
implementation is <i>unification</i> which is a general purpose pattern
matching. Examples of unification (see book and then consider the following):
<p><b>? - f(a) = f(X,a).</b> /<font face="Symbol">*</font> fails because
f/1 cannot unify with f/2 <font face="Symbol">*</font>/
<p><i>NOTE</i> that 'f/i' means "the version of the relation f that takes
i parameters." The number of parameters (i) is usually called the <i>arity</i>
of the relation (f)
<p><b>? - f(x) = f(g(X)). </b>/<font face="Symbol">*</font> fails because
the constant x cannot unify with g/1<font face="Symbol">*</font>/
<p><b>? - X = f(X).</b> may succeed but will fail if the Prolog implementation
has included the "occurs check"; if unification does succeed it is unusable
because there is a match of X with f(f(f( ... )))
<p><b>? - [A, B | X] = [2, 1].</b> /<font face="Symbol">*</font> succeeds
with A = 2, B = 1, X = [ ] <font face="Symbol">*</font>/
<p><b>? - p(X, X) = p(Y, f(Y)). </b>/<font face="Symbol">*</font> fails
if "occurs check" implemented, else succeeds
<p>with the unusable binding X = Y, Y = f(f(f( ... )))
<font face="Symbol">*</font>/
<p><b>? - f(X, g(X)) = f(a, Y).</b> /<font face="Symbol">*</font> succeeds
with X = a and Y = g(a) <font face="Symbol">*</font>/
<p><b>? - f(X, b, g(X)) = f(A, A, g(a)).</b> /<font face="Symbol">*</font>
fails, first X = A = b and then X = would have to be a <font face="Symbol">*</font>/
<p>The rules for unification are the following:
<ul>
<li>
Constants only unify if they are the same (floating point number may allow
some rounding when testing for equality)</li>

<li>
Structures (e.g. f(g(X), h(y)) ) unify only if their functors and arities
agree and their corresponding arguments unify recursively</li>

<li>
A variable X can unify with any Prolog term. In subsequent unifications,
X will be replaced by that term automatically</li>

<li>
Note that any Prolog rule for a relation has the general form:</li>
</ul>
<b>rel(&lt;parameters>) :- subgoal_1(...), subgoal_2(...), ..., subgoal_n(...).</b>
<p>The query <b>? - rel(&lt;actual parameters>).</b> is a "goal" which
Prolog tries to solve. Whenever it comes to use the above rule to try to
satisfy the "goal" it has to try to solve, in turn, each of the "subgoals"
<b>subgoal_1(...)</b>
through <b>subgoal_n(...)</b>. Any unifications which result from calling
the rule for <b>rel(...)</b> and from solving <b>subgoal_1(...)</b> through
<b>subgoal_j(...)</b> will be used when solving <b>subgoal_j+1(...)</b>
through <b>subgoal_n(...)</b>. At any point a failure may occur and then
Prolog attempts a new solution at the most <i>recent</i> point where an
alternative exists. The easiest way to understand the process us to see
and then program lots of examples.
<p><b><i>More Examples</i></b>
<p>(1) Define "parent(X, Y)" where X is a parent of Y, if X is either the
mother or the father of Y. Similar definitions can be made for grandparent,
sibling, and both-parent sibling:
<p><b>parent(X, Y) :- mother(X, Y).</b>
<p><b>parent(X, Y) :- father(X, Y).</b>
<p><b>grandparent(X, Z):- parent(X, Y), parent(Y, Z).</b>
<p><b>sibling(X, Y) :- parent(P, X), parent(P, Y), X \= Y.</b>
<p><b>both-parent-sibling(X, Y) :- mother(M, X), mother(M, Y), father(F,
X), father(F, Y), X \= Y.</b>
<p>These statements give rules of implication among the variables X, Y,
Z, M, F. The following facts can then be added, and questions can be asked
regarding those facts and the above rules.
<p><b>mother(mary, ann).</b>
<p><b>mother(mary, joe).</b>
<p><b>mother(sue, mary).</b>
<p><b>father(mike, ann).</b>
<p><b>father(mike, joe).</b>
<p><b>grandparent(sue, ann).</b> /<font face="Symbol">*</font> redundant
<font face="Symbol">*</font>/
<p>Questions such as the following can then be asked:
<p><b>?- parent(X, ann), parent(X, joe).</b>
<p>X = mary;
<p>X = mike
<p><b>?- grandparent(sue, Y).</b>
<p>Y = ann;
<p>Y = joe
<p><b>?- both-parent-sibling(X, ann).</b>
<p>X = joe
<p>(2) Write a Prolog relation that accepts a list of integers, and counts
the number of zeros in the list, e.g.,
<p><b>?&shy; zeros([1, 0, 0, 5], X).</b>
<p>X = 2
<p><b>?&shy; zeros([ ], X).</b>
<p>X = 0
<p>Relation definition:
<p><b>zeros([ ], 0).</b>
<p><b>zeros([0 | T], Z):- zeros(T, Z1), !, Z is Z1 + 1.</b>
<p><b>zeros([ _ | T], Z):- zeros(T, Z).</b>
<p><i>Note</i> that the <i>cut</i>, written '!,' is very significant. If
you type ';' after the answers above you do not get any more solutions.
Without the 'cut' you get the following:
<p><b>fragile-zeros([ ], 0).</b>
<p><b>fragile-zeros([0 | T], Z):- fragile-zeros(T, Z1), Z is Z1 + 1.</b>
<p><b>fragile-zeros([ _ |T], Z):- fragile-zeros(T, Z).</b>
<p><b>?&shy; fragile-zeros([1, 0, 0, 5], X).</b>
<p>X = 2;
<p>X = 1;
<p>X = 1;
<p>X = 0;
<p>no
<p>The <i>cut</i> ensures that if you get a match on a list with 0 at the
head, you count the 0 once and <i>only</i> consider the tail T of that
list. You do not try to pass the whole [0 | T] list to the third rule.
<p>(3) Write a Prolog relation which accepts two lists of integers L and
M, and `succeeds' if M is a list of the squared numbers in L, e.g.,
<p><b>?&shy; squares([0, 2, 3, 1], X).</b>
<p>X = [0, 4, 9, 1]
<p><b>?&shy; squares([ ], X).</b>
<p>X = [ ]
<p><b>?- squares([2, 4, 6], [4, 16, 36]).</b>
<p>Relation definition:
<p><b>squares([ ], [ ]).</b>
<p><b>squares([N|T], [S|ST]):- S is N<font face="Symbol">*</font>N, squares(T,
ST).</b>
<p>(4) Write a Prolog relation "intersect(L1, L2, R)" that succeeds if
R is the intersection of L1 and L2. (<i>Assume no duplicates</i>), e.g.,
<p><b>?&shy; intersect([0, 1, 6, 3], [5, 1, 8, 2, 3, 9], X).</b>
<p>X = [1, 3]
<p><b>?&shy; intersect([1], [4], X).</b>
<p>X = [ ]
<p>Relation definition:
<p><b>intersect([ ], X, [ ]).</b>
<p><b>intersect([X|R], Y, [X|Z]) :- mymember(X, Y), !, intersect(R, Y,
Z).</b>
<p><b>intersect([X|R], Y, Z) :- intersect(R, Y, Z).</b>
<p>Again, the cut is necessary to avoid spurious answers. You should test
this code without the cut.
<p>(5) Write a Prolog relation union(L1, L2, R) that succeeds if R is the
union of L1 and L2, e.g.,
<p><b>?&shy; union([3, 7, 1, 6], [5, 7, 2, 4, 1], X).</b>
<p>X = [3, 6, 5, 7, 2, 4, 1] /<font face="Symbol">*</font> or some other
order of elements <font face="Symbol">*</font>/
<p><b>?&shy; union([4], [1, 6, 8], X).</b>
<p>X = [4, 1, 6, 8] /<font face="Symbol">*</font> or some other order of
elements <font face="Symbol">*</font>/
<p>Relation definition:
<p><b>union([ ], X, X).</b>
<p><b>union([X|R], Y, Z):- member(X, Y), !, union(R, Y, Z).</b>
<p><b>union([X|R], Y, [X|Z]):- union(R, Y, Z).</b>
<p>(6) Write a Prolog relation which accepts a list of integers and counts
the number of positive entries in an arbitrary list of integers, e.g.,
<p><b>?&shy; positive([0, &shy;1, &shy;5, 5], X).</b>
<p>X = 1
<p><b>?&shy; positive([1, &shy;2, 4, 2, 3], X).</b>
<p>X = 4
<p><b>?&shy; positive([ ], X).</b>
<p>X = 0
<p>Relation definition:
<p><b>positive([ ], 0).</b>
<p><b>positive([H|T], Z):- H > 0, !, positive(T, Z1), Z is 1 + Z1.</b>
<p><b>positive([ _ |T], Z) :- positive(T, Z).</b>
<p>(7) Write a Prolog relation which separates all (strictly) positive
and negative entries from an arbitrary list of integers, e.g.,
<p><b>?&shy; selectpn([0, &shy;1, &shy;5, 5], X, Y).</b>
<p>X = [5]
<p>Y = [&shy;1, &shy;5]
<p><b>?&shy; selectpn([1, &shy;2, 4, 2, 3], X, Y).</b>
<p>X = [1, 4, 2, 3]
<p>Y = [&shy;2]
<p>Relation definition:
<p><b>selectpn([ ], [ ], [ ]).</b>
<p><b>selectpn([0 | T], X, Y) :- selectpn(T, X, Y), !.</b>
<p><b>selectpn([H | T], [H|Z], X):- H > 0, !, selectpn(T, Z, X).</b>
<p><b>selectpn([H | T], X, [H|Z]):- selectpn(T, X, Z).</b>
<p>(8) Write a relation to computer Fibonacci numbers:
<p>Double recursion to compute Fibonacci numbers (exponential growth of
recursive calls):
<p><b>fibonacci_1(X, 1):- X &lt; 2.</b>
<p><b>fibonacci_1(X, Y):- X > 1, X1 is X </b>-<b> 1, X2 is X </b>-<b> 2,</b>
<p><b>fibonacci_1(X1, Y1), fibonacci_1(X2, Y2), Y is Y1 + Y2.</b>
<p>Storing Fibonacci numbers, once computed:
<p><b>fibonacci_2(0, 1).</b>
<p><b>fibonacci_2(1, 1).</b>
<p><b>fibonacci_2(X, Y):- X > 1, X1 is X </b>-<b> 1, X2 is X </b>-<b> 2,
fibonacci_2(X1, Y1), fibonacci_2(X2, Y2),</b>
<p><b>Y is Y1 + Y2, asserta(fibonacci_2(X,Y)).</b>
<p>Run a few queries of fibonacci_2 and use listing(fibonacci_2) to see
how the database grows.
<p>A more efficient recursive program using accumulating parameter:
<p><b>fibonacci3(X, N) :- fib_aux(X, 2, 1, 1, N).</b>
<p><b>fib_aux(M, Count, Last_fib, Second_last_fib, Last_fib) :- Count >=
M.</b>
<p><b>fib_aux(M, Count, Last_fib, Second_last_fib, N) :- Count &lt; M,
Next_count is Count + 1,</b>
<p><b>New_fib is Last_fib + Second_last_fib,</b>
<p><b>fib_aux(M, Next_count, New_fib, Last_fib, N).</b>
<p>(9) Write a Prolog relation which produces the permutations of a list,
one at a time (after the first one, the program must be prompted by the
user typing `;'), e.g.,
<p><b>?- perm([1, 4, 7], X).</b>
<p>X = [1, 4, 7];
<p>X = [1, 7, 4];
<p>X = [4, 1, 7];
<p>X = [4, 7, 1];
<p>X = [7, 1, 4];
<p>X = [7, 4, 1];
<p>no
<p>Relation definition:
<p><b>perm([ ], [ ]).</b>
<p><b>perm(L, [X | Y]):- sel(L, X, T), perm(T, Y).</b>
<p><b>sel([X | Y], X, Y).</b>
<p><b>sel([X | Y], Z, [X | T]):- sel(Y, Z, T).</b>
<p>Consider
<p><b>callperm(X):- perm(X,Y), write(Y), nl, fail.</b>
<p>The query
<p><b>?- callperm([1, 4, 7]).</b>
<p>gives all permutations.
<p>We shall now review some of the material from Chapter 8 of a book by
Sethi which is on reserve: A <i>simple term</i> is a number, a variable
or a constant atom. A <i>compound term</i> is an atom (also called a functor)
followed by a parenthesized sequence of terms separated by commas. The
grammar of Prolog is exceedingly simple:
<p>&lt;<i>term</i> > &lt;<i>number</i> > | &lt;<i>atom</i> > | &lt;<i>variable</i>
> | &lt;<i>atom</i> > <b>(</b> &lt;<i>terms</i> > <b>)</b>
<p>&lt;<i>terms</i> > &lt;<i>term</i> > | &lt;<i>term</i> > <b>,</b> &lt;<i>terms</i>
>
<p>&lt;<i>fact</i> > &lt;<i>term</i> > <b>.</b>
<p>&lt;<i>rule</i> > &lt;<i>term</i> > <b>:-</b> &lt;<i>terms</i> > <b>.</b>
<p>&lt;<i>query</i> > &lt;<i>terms</i> > <b>.</b>
<p>There are a number of special notations added for convenience:
<b>=</b>
is a predefined functor which represents the relation "can be unified with."
It can be written using infix or prefix notation: <b>=(X, Y)</b> or <b>X
= Y</b> and similarly for several other operators. The list notation <b>[X
| Y]</b> is used instead of <b>.(X, Y)</b> There is an operation "or" which
is written ';' and is sometimes useful:
<p><b>parent(X, Y) :- mother(X, Y); father(X, Y).</b>
<p>It can be used with parentheses to form an "or" of sequences of subgoals.
<p>Data strctures can be represented using functors, e.g., a binary tree
can be written
<p><b>node(Self, Leftsubtree, Rightsubtree)</b>:
<p>This representation of a tree needs the existence of a constant
<b>empty</b>.
The following Prolog relation would check whether something is a binary
tree (not a search tree):
<p><b>binarytree(empty).</b>
<p><b>binarytree(node(X, Y, Z)):- binarytree(Y), binarytree(Z).</b>
<p>Suppose we are able to construct a binary <i>search</i> tree <b>T</b>
using the above representation, which has a number stored at each node.
To test whether the number <b>E</b> occurs in <b>T</b>, we can use the
following recursive tree search:
<p><b>tree-member(E, node(E, _ , _ )):- !.</b> /<font face="Symbol">*</font>
cut off search after first time the element is found <font face="Symbol">*</font>/
<p><b>tree-member(E, node( N , L, _ )):- E &lt; N, !, tree-member (E, L).</b>
<p>/<font face="Symbol">*</font> cut if E &lt; N to avoid searching the
right subtree <font face="Symbol">*</font>/
<p><b>tree-member(E, node( _ , _ , R )):- tree-member(E, R).</b>
<p>The <i>guess</i> and <i>verify</i> technique, which is available in
Prolog, is illustrated by:
<p><b>have-elements-in-common-ver1(X,Y):- mymember(E,X), mymember(E,Y).</b>
<p><b>have-elements-in-common-ver2(X,Y):- mymember(E,X), mymember(E,Y),
!.</b>
<p>The first call to member will give values to E which run through the
list X in sequence, each such E will be checked to see if it belongs to
Y. The cut in the second version will stop the search after the first success
(if any) and disallow additional solutions. Notice the following behavior:
<p><b>? - have-elements-in-common-ver1(X, [1, 2, 3]).</b>
<p>X = [1| _14];
<p>X = [2| _14];
<p>X = [3| _14];
<p>X = [ _16, 1| _18];
<p>X = [ _16, 2| _18];
<p>X = [ _16, 3| _18];
<p>...
<p><b>? - have-elements-in-common-ver1([1, 2, 3], Y).</b>
<p>Y = [1| _33];
<p>Y = [_35, 1 | _36];
<p>Y = [_35, _39, 1 | _40];
<p>...
<p>Order of evaluation problems:
<p><b>? - X = [1, 2, 3], write(X), nl, mymember(a, X).</b>
<p>X = [1, 2, 3]
<p>no
<p><b>?- mymember(a, X), write(X), nl, X = [1, 2, 3].</b>
<p>X = [a| _3];
<p>X = [_5, a| _7];
<p>X = [_5, _8, a| _9];
<p>X = [_5, _8, _11, a| _12];
<p>X = [_5, _8, _11, _14, a| _15];
<p>...
<p>Accessing the end of a list using variables as place-holders:
<p><b>? - L = [a, b | X], X = [c, Y].</b>
<p>L = [a, b, c | _2]
<p>X = [c | _2]
<p>Y = _2
<p>(note that _1 was the first value of X.) The unification inserts a <b>c</b>
at the end of <b>L</b>.
<p>A queue implementation; q(X, Y) is a queue with X representing the whole
queue and Y representing a place-holder at the end of the queue:
<p><b>create-queue(q(X, X)).</b>
<p>Hence <b>create-queue(Q)</b> unifies <b>Q</b> with <b>q( _<i>n</i>,
_<i>n</i> )</b>.
<p>Consider:
<p><b>add-queue(E, q(X, Last), q(X, NewLast)):-</b>
<p><b>Last = [E | NewLast].</b>
<p>(alternatively: <b>add-queue(E, q(X, [E | Y]), q(X, Y)).)</b>
<p>Here, <b>add-queue(a, Q, R)</b> first unifies <b>Last</b> with
<b>_<i>n</i></b>
and then with <b>[a | _<i>n</i>+1]</b>. That makes <b>Q</b> unify with
<b>q([a
| _<i>n</i>+1], [a | _<i>n</i>+1])</b>, <b>NewLast</b> with <b>_<i>n</i>+1</b>
and <b>R</b> with <b>q([a | _<i>n</i>+1], _<i>n</i>+1)</b>:
<p>Similarly <b>add-queue(b, R, S)</b> make the unifications:
<p><b>Q</b> = <b>q([a, b | _<i>n</i>+2], [a, b | _<i>n</i>+2])</b>
<p><b>R</b> = <b>q([a, b | _<i>n</i>+2], [b | _<i>n</i>+2])</b>
<p><b>S</b> = <b>q([a, b | _<i>n</i>+2], _<i>n</i>+2)</b>
<p>Next we have:
<p><b>del-queue(E, q(X, Last), q(NewX, Last)):- X = [E | NewX].</b>
<p><b>del-queue(A, S, T)</b> unifies <b>q(X, Last)</b> with <b>S</b>, i.e.
<b>X</b>
unifies with <b>[a, b | _<i>n</i>+2]</b> and <b>Last</b> with
<b>_<i>n</i>+2</b>.
<p>Therefore <b>A</b> unifies with <b>a</b> and <b>NewX</b> with
<b>[b
| _<i>n</i>+2]</b>. Finally, <b>T</b> unifies with <b>q([b | _<i>n</i>+2],
_<i>n</i>+2)</b>.
<p>The relation <b>force-empty-queue (q( [ ], [ ]))</b> would appear to
be a reasonable characterization of an empty queue but it is too restrictive:
it checks that the terms inside <b>q</b> are really empty, not just identical.
For example, while <b>Q</b> is bound to <b>q( _1, _1)</b>, <b>emptyQ(Q)</b>
will succeed by unifying <b>_1</b> and <b>[ ]</b>. However, as soon as
<b>Q</b>
unifies with <b>q([a | _2], [a | _2])</b> or <b>q([a, b | _2], [a, b |
_2])</b>, the match with
<b>[ ]</b> is no longer possible and <b>force-empty-queue(Q)</b>
will fail. In fact, we need to check the pointers are <i>identical:</i>
<p><b>empty-queue(q(X,Y)):- X = = Y.</b>
<p>Thus:
<p><b>? - create-queue(Q), add-queue(a, Q, R), empty-queue(Q).</b>
<p>Q = q([a| _<i>n</i> ], [a| _<i>n</i> ])
<p>R = q([a| _<i>n</i> ], _<i>n</i> )
<p>yes
<p><b>? - create-queue(Q), add-queue(a, Q, R), empty-queue(R).</b>
<p>no
<p>but:
<p><b>? - create-queue(Q), add-queue(a, Q, R), force-empty-queue(Q).</b>
<p>no
<p>also:
<p><b>? - create-queue(Q), add-queue(a, Q, R), add-queue(b, R, S), del-queue(A,
S, T), write(A), nl,</b>
<p><b>del-queue(B, T, U), write(B), nl, force-empty-queue(U).</b>
<p>a
<p>b
<p>Q = q([a, b], [a, b])
<p>R = q([a, b], [b])
<p>S = q([a, b], [ ])
<p>A = a
<p>T = q([b], [ ])
<p>B = b
<p>U = q([ ], [ ])
<p>Note the rather unexpected behavior:
<p><b>? - create-queue(Q), del-queue(X, Q, R), write(X), nl, add-queue(a,
R, S), write(X), nl.</b>
<p>_<i>m</i>
<p>a
<p>Q = q([a| _<i>n</i> ], [a| _<i>n</i> ])
<p>X = a
<p>R = q( _<i>n</i> , [a| _<i>n</i> ])
<p>S = q( _<i>n</i> , _<i>n</i> )
<p>If <b>force-empty-queue(S)</b> is added as the last subgoal, then _<i>n</i>
unifies with <b>[ ]</b>:
<p><b>? - create-queue(Q), del-queue(X, Q, R), write(X), nl, add-queue(a,
R, S), write(X), nl,</b>
<p><b>force-empty-queue(S).</b>
<p>_<i>m</i>
<p>a
<p>Q = q([a], [a])
<p>X = a
<p>R = q([ ], [a])
<p>S = q([ ], [ ])
<p><i>Difference lists</i> are an important Prolog technique. Some relation
<b>diff_list
(L, E)</b> is used, with no special meaning in Prolog, but the user thinks
of the relation as representing the list that remains when E is removed
from L, where E is some tail part of L. Prolog allows some of the predefined
symbols:
<b>+</b>, -, etc., to be used in the representation of difference
lists. Since we are working with <i>difference</i> lists, the symbol -
is the most frequently used: <b>L </b>-<b> E</b>.
<p>The following queue is from F.Kluzniak &amp; S.Szpakowicz, <i>Prolog
for Programmers</i>, Academic Press: (just replace q(X, Y), above, by X
- Y). First we need to introduce "not":
<p><b>not(P) :- call(P), !, fail.</b>
<p>%see pages 337, 338 of Kluzniak &amp; Szpakowicz
<p><b>not(P).</b>
<p>alternatively <b>not(P):- P, !, fail; true.</b>
<p>If the call to P fails, then the second rule makes <b>not(P)</b> succeed
for any P. If the call to P succeeds, then the first rule fails but the
cut prevents any other solutions, so the whole of <b>not(P)</b> fails.
<p>Next the difference-list queue:
<p><b>create-queue(L </b>-<b> L).</b>
<p><b>add-queue(E, L </b>-<b> [E | R], L </b>-<b> R)).</b>
<p>Now, the naive definition like the one used before:
<p>del-queue(E, [E | Rest] - Last, Rest - Last)).
<p>is unsatisfactory because, when a queue is empty (i.e., Rest is the
same as Last), this del-queue produces "negative difference lists"
<br>del-queue( _<i>n</i> - [E | _<i>n</i> ])
<p>Correct version:
<p><b>del-queue(E, L </b>-<b> Last, NewL </b>-<b> Last):- not (L = = Last),</b>
<p><b>L = [E | NewQ].</b>
<p><b>empty-queue(L </b>-<b> M):- L = = M.</b>
<p>The graphic for this queue is essentially same as before with q(X, Y)
replaced by X-Y.
<p>Difference lists can eliminate recursion and thus improve efficiency:
<p><img SRC="img00026.gif" >
<p><b>append (L </b>-<b> X, X </b>-<b> Y, L </b>-<b> Y).</b>
<p>compared to:
<p><b>append([ ], X, X).</b>
<p><b>append([X | Y], Z, [X | T]):- append(Y, Z, T).</b>
<p><b>? - append([1, 2, 3 | X] - X, [4, 5] - [ ], Y </b>-<b> Z).</b>
<p>X = [4, 5]
<p>Y = [1, 2, 3, 4, 5]
<p>Z = [ ]
<p><b>? - append([1, 2, 3 | X] - X, [4, 5 | Y] - Y, W </b>-<b> Z).</b>
<p>X = [4, 5 | _<i>n</i>]
<p>Y = _<i>n</i>
<p>W = [1, 2, 3, 4, 5 | _<i>n</i>]
<p>Z = _<i>n</i>
<p>The following simple code extracts the list corresponding to the difference
list:
<p><b>simplify(X - Y, [ ]) :- X == Y.</b>
<p><b>simplify([X | Y] </b>-<b> Z, [X | W]):- simplify (Y </b>-<b> Z, W).</b>
<p>The "occurs-check" problem: for efficiency reasons, the check may not
be made in Prolog, hence:
<p><b>? - append ([ ], E, [a, b | E]).</b>
<p>E = [a, b, a, b, a, b, a, b, a, b, a, b, a, b, a, b, a, b, a, b, a,
b, a, b, a, b, a, b, a, b, a, b, ...
<p>Some Prologs may construct a cyclic data structure for terms derived
in the above way.
<p>The following is meant to illustrate the elegance and clarity of Prolog:
<p><b>qsort([X | L], Outlist) :- partition (X, L, Small, Large), qsort(Small,
Localsmall),</b>
<p><b>qsort(Large, Locallarge),</b>
<p><b>append (Localsmall, [X | Locallarge], Outlist).</b>
<p><b>qsort([ ], [ ]).</b>
<p>where <b>partition</b> separates the elements of L into those X and
those > X:
<p><b>partition (X, [ ], [ ], [ ]).</b>
<p><b>partition (X, [Y | Tail], [Y | Small], Large) :- X > Y, !, partition
(X, Tail, Small, Large).</b>
<p><b>partition (X, [Y | Tail], Small, [Y | Large]) :- partition (X, Tail,
Small, Large).</b>
<p><b>? - qsort(&lt;</b><i>some input list</i><b>>, X).</b>
<p>Alternative using an auxiliary parameter to avoid <b>append</b>:
<p><b>quicksort([X | L], Aux, Outlist):- partition (X, L, Small, Large),
quicksort(Large, Aux, Local),</b>
<p><b>quicksort(Small, [X | Local], Outlist).</b>
<p><b>quicksort([ ], Any, Any).</b>
<p><b>? - quicksort(&lt;</b><i>some input list</i><b>>, [ ], X).</b>
<p>Alternative using difference lists, also avoiding the expensive form
of append:
<p><b>qsort1(Inlist, Outlist):- qsort2(Inlist, Outlist </b>-<b> [ ]).</b>
<p><b>qsort2([X | Tail], A1 </b>-<b> Z2):- partition (X, Tail, Small, Large),
qsort2(Small, A1 </b>-<b> [X | A2]),</b>
<p><b>qsort2(Large, A2 </b>-<b> Z2).</b>
<p><b>qsort2([ ], Z </b>-<b> Z).</b>
<p>Solving the Towers of Hanoi puzzle:
<p><b>hanoi(N) :- move(N, left, center, right).</b>
<p><b>move(0, _ , _ , _ ) :- !.</b>
<p><b>move(N, A, B, C) :- M is N</b>-<b>1, move(M, A, C, B), inform(A,
B), move(M, C, B, A).</b>
<p><b>inform(X, Y) :- write([move, a, disc, X, to, Y]), nl.</b>
<p><i>User-defined operations</i>
<p>Prolog allows the user to introduce new operations. The precedence of
the operator can be specified in relation to the other operators and it
can be specified as left- or right-associative. The <i>third edition</i>
of Clocksin and Mellish has a list of the built in operators, their precedence
and their associativity in Chapter 5. Many newer texts on Prolog have examples.
<p><i>Definite clause grammars </i>(<i>DCG</i>)
<p>A standard library that can be found with many Prolog systems provides
the translation from grammar-rule notation into normal Prolog syntax automatically.
The grammar below can then be typed into Prolog directly (example from
Bratko, Chapter 17). It becomes easier to work with grammars and typing
errors are avoided:
<p><b>move step.</b>
<p><b>step [up].</b>
<p><b>move step, move.</b>
<p><b>step [down].</b>
<p>Some references if you need more information on Prolog:
<p>Ivan Bratko, <i>Prolog, Programming for Artificial Intelligence</i>,
2nd edition (or later if there is one), Addison-Wesley
<p>W.F. Clocksin and C.S. Mellish, <i>Programming in Prolog</i>, 3rd edition,
Springer-Verlag
<p>Leon Sterling and Ehud Shapiro, <i>The Art of Prolog</i>, MIT Press.
<p>Richard A. O'Keefe, <i>The Craft of Prolog</i>, MIT Press 1990
</body>
</html>
