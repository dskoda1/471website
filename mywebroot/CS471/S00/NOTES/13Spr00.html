<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Les Lander">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; U) [Netscape]">
   <title>Theoretical Foundations of Functional Languages</title>
</head>
<body>
underConstruction
<center><table BORDER CELLSPACING=0 CELLPADDING=0 BGCOLOR="#FFFFF0" >
<tr>
<td><a href="http://bingweb.binghamton.edu/~head/CS471/NOTES/12Spr00.html">&nbsp;previous</a></td>

<td><a href="http://bingweb.binghamton.edu/~head/CS471/NOTES/14Spr00.html">&nbsp;next&nbsp;</a></td>
</tr>
</table></center>

<center>
<h4>
FUNCTIONAL PROGRAMMING PRINCIPLES</h4></center>

<center>
<h3>
&copy; Eileen Head, Leslie C. Lander, 2000</h3></center>

<h4>
Propose:&nbsp; To examine the theoretical foundations of functional languages.</h4>

<center>
<h4>

<hr WIDTH="100%"></h4></center>

<center>
<h3>
&copy; Eileen Head, Leslie C. Lander, 2000</h3></center>
<i>The material here includes classroom slides of courses taught at Binghamton.</i>
<h2>
Functional Programming Principles</h2>

<h3>
Programming methods</h3>

<ul>
<li>
Techniques derived from functional programming that are in use in standard
imperative languages include:</li>

<ul>
<li>
recursive subprogram calls</li>

<li>
using function values rather than using procedures to operate on global
variables</li>
</ul>

<li>
A function f is a rule that takes an input value x and returns a value
f (x)</li>
</ul>

<h3>
Domain/range of a function</h3>

<ul>
<li>
The inputs x belong to a set X (called the domain of f )</li>

<li>
The values y = f (x) belong to a set Y (called the range of f )</li>

<li>
We write f : X -> Y</li>

<li>
Functional programming refers to writing a program as a set of functions</li>
</ul>

<h3>
Programs are function calls</h3>

<ul>
<li>
The program is executed by making a call to one of these functions, passing
in some set of input values</li>

<li>
The first function called will normally make calls to other functions or
use other functions as parameters</li>

<li>
Variable symbols like x and y inside function definitions should be thought
of as formal parameters…</li>
</ul>

<h3>
The function “cube”</h3>

<ul>
<li>
they indicate how many input values are required and how the function will
use them to compute its return value, e.g.</li>

<pre>cube(x) = x * x * x</pre>

<li>
The function "cube" takes one input value and returns the cube of that
value, e.g.</li>

<pre>cube(4) = 64</pre>
</ul>

<h3>
No memory locations</h3>

<ul>
<li>
The input should be numeric in this case, otherwise an error will occur</li>

<li>
Variable symbols outside of function definitions should NOT be thought
of as references to memory locations</li>

<li>
They will always be a constant (numeric or literal) or the value of some
other function:</li>

<pre>pi = 3.14159&nbsp;
six = factorial (3)</pre>
</ul>

<h3>
Pure functional programming</h3>

<ul>
<li>
Writing programs that depend entirely on function calls without assigning
the values of any variables, except for initialization, is called pure
functional programming.</li>

<li>
All programming in Haskell in this course will be "pure" in this sense.</li>

<li>
Compare the following Java functions (note, all functions in Java MUST
be INSIDE A JAVA CLASS):</li>
</ul>

<h3>
Imperative code, full of assignments</h3>

<ul>
<pre>int gcd(int u, int v) {
&nbsp;&nbsp;&nbsp; int x = u;&nbsp;
&nbsp;&nbsp;&nbsp; int y = v;&nbsp;
&nbsp;&nbsp;&nbsp; int t;&nbsp;
&nbsp;&nbsp;&nbsp; while (true) {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (y == 0) {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t = y;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y = x % y;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = t;&nbsp;
&nbsp;&nbsp;&nbsp; }&nbsp;
}</pre>
</ul>

<h3>
Recursive (functional) version</h3>

<ul>
<li>
The first code is an example of imperative programming: a sequence of instructions
that operate on fixed memory locations during execution</li>

<pre>int gcd(int u, int v) {&nbsp;
&nbsp;&nbsp;&nbsp; if (v == 0) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return u;
&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return gcd(v,u % v);&nbsp;
&nbsp;&nbsp;&nbsp; }
}</pre>
</ul>

<h3>
Definition of gcd</h3>

<ul>
<li>
The second code is based on function calls. No variables are assigned values.</li>

<li>
The second code is essentially a mathematical definition of the function
gcd :</li>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { u&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if v = 0
gcd (u, v) = {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { gcd (v, u mod v)&nbsp; if v > 0</pre>
</ul>

<h3>
Referential transparency</h3>

<ul>
<li>
The idea that the value of a function depends entirely on the values of
the parameters is called referential transparency.</li>

<li>
No reference is made to global variables that might change each time the
function is called.</li>

<li>
Haskell syntax for the recursive version of the gcd function:</li>
</ul>

<h3>
Haskell version of gcd</h3>

<ul>
<pre>> gcd u v = if (v == 0) then u else gcd v (mod u v)</pre>
or
<pre>> gcd u 0 = u
> gcd u v = gcd v (u `mod` v)</pre>

<li>
Note that “gcd” is in the Prelude so, you would need to write “mygcd”</li>

<li>
The function as given in the Prelude appears on the next slide:</li>
</ul>

<h3>
Prelude version of gcd</h3>

<blockquote>
<pre>> gcd :: Integral a => a -> a -> a
> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
> gcd x y = gcd' (abs x) (abs y)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where gcd' x 0 = x
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gcd' x y = gcd' y (x `rem` y)</pre>
</blockquote>

<h3>
Functions of several variables</h3>

<ul>
<li>
Notice that Haskell allows functions “of more than variable” if we use
tuples (not the preferred way):</li>

<pre>> extract::(Int,Int,[Int])->[Int]
> extract (a,b,[]) = []
> extract (a,b,(c:x))
>&nbsp;&nbsp;&nbsp; |a&lt;=c &amp;&amp; c&lt;=b = extract(a,b,x)
>&nbsp;&nbsp;&nbsp; |otherwise&nbsp;&nbsp;&nbsp; = c:extract(a,b,x)</pre>

<li>
But now, “extractOver8,” i.e. “extract 8” is not defined</li>
</ul>

<h3>
lambda-calculus</h3>

<ul>
<li>
Alonzo Church introduced lambda-calculus (lambda-calculus) as a notation
for studying functions</li>

<li>
The model of computation provided by Church’s work with lambda-calculus
has been shown to be equivalent the model provided by Turing machines</li>

<li>
We can use lambda-notation in Haskell directly</li>
</ul>

<h3>
Traditional lambda-notation and Haskell</h3>

<ul>
<li>
The textbook (Section 10.7) has the first example (prefix notation):</li>

<pre>(lambda x. + 1 x)</pre>

<li>
Haskell</li>

<pre>\x -> (+) 1 x or \x -> 1 + x</pre>

<li>
(In Common Lisp and Scheme, this can be written (lambda (x) (+ 1 x))</li>

<li>
Notice that lambda-calculus functions can be anonymous (no name is needed)</li>
</ul>

<h3>
Function application</h3>

<ul>
<li>
Having defined a function in lambda-calculus, you apply it by supplying
arguments at the end</li>

<li>
The arguments are constants or values of functions:</li>

<pre>(lambda x. + 1 x) 2 <i>returns</i> 3,</pre>

<li>
Haskell:</li>

<pre>...> (\x -> 1 + x) 2&nbsp;
3</pre>

<li>
We say x is a bound variable (bound by lambda)</li>
</ul>

<h3>
Bound and free variables (symbols)</h3>

<ul>
<li>
It would be better to say x is a bound symbol, since the word variable
suggests the wrong sort of meaning to most programmers (a name for a memory
location)</li>

<li>
There can be symbols that are not bound. Such symbols are called free:</li>

<pre>(lambda x. + y x)</pre>

<li>
Haskell does not like this unless y is already defined, e.g. <tt>\x ->
pi + x</tt></li>
</ul>

<h3>
Substitution</h3>

<ul>
<li>
In lambda-expressions there is always a problem with using the same symbol
more that once; just use different symbols next to every lambda</li>

<li>
lambda-notation accepts the following:</li>

<pre>(lambda x. + ((lambda y.((lambda x. * x y) 2)) x) y)</pre>
but it is clearer to instead write:
<pre>(lambda x. + ((lambda y.((lambda z. * z y) 2)) x) k)</pre>
</ul>

<h3>
Evaluation</h3>

<ul>
<li>
Evaluation</li>

<pre>(lambda x. + ((lambda y.((lambda z. * z y) 2)) x) k)
=> (lambda x. + ((lambda y. * 2 y) x) k)
=> (lambda x. + (* 2 x) k)</pre>

<li>
Since lambda-notation only binds one variable it may seem that lambda-calculus
cannot handle functions of several variables but in fact, it describes
functions in curried form</li>
</ul>

<h3>
Haskell shorthand</h3>

<ul>
<li>
Haskell has an abbreviated way to express nested lambda-functions:</li>

<pre><tt>(\ x y z&nbsp; ->&nbsp; x&nbsp; +&nbsp; y&nbsp; +&nbsp; z)</tt></pre>

<li>
is an abbreviation of</li>

<pre>(\x -> (\y -> (\z -> x + y + z)))</pre>

<li>
Thus even <tt>(\ x y z -> x + y + z)</tt> is treated as if it were in Curried
form:</li>

<pre>...>:t (\ x y z -> x+y+z)&nbsp;
\ x y z-> x + y + z :: Num a => a -> a -> a -> a</pre>
</ul>

<h3>
Applicative order evaluation (Section 5.7)</h3>

<ul>
<li>
Applicative order evaluation means that all arguments to functions are
evaluated before the function is evaluated:</li>

<li>
In</li>

<pre>(lambda x.(lambda y. * x y)) (+3 4) (-5 6)</pre>
we first evaluate the arguments to get
<pre>(lambda x. (lambda y. * x y)) 7 (-1)&nbsp;
=> (lambda y. * 7 y)) (-1)&nbsp;
=> * 7 (-1)&nbsp;
=> -7</pre>
</ul>

<h3>
Normal order evaluation</h3>

<ul>
<li>
Normal order evaluation means that an expression is not evaluated until
the value is needed:</li>

<pre>(lambda x.(lambda y. * x y)) (+ 3 4) (- 5 6)&nbsp;
=> lambda y. * (+ 3 4) y) (- 5 6)&nbsp;
=> * (+ 3 4) (- 5 6))&nbsp;
=> * 7 (- 5 6)&nbsp;
=> * 7 (-1)&nbsp;
=> -7</pre>

<li>
Evaluation in Haskell is Normal evaluation by default</li>
</ul>

<h3>
Haskell evaluation</h3>

<ul>
<li>
In Haskell, for</li>

<pre>f :: a -> b -> c</pre>

<pre>f exp1 (f exp2 exp3)</pre>
is evaluated starting with “f exp1” since f will be curried,
<li>
f exp1 will be a function b -> c</li>

<li>
This is outside-in evaluation.</li>

<li>
Evaluation is also left-to-right</li>

<pre>f exp1 + f exp2</pre>
is evaluated starting with "f exp1," then we get the function "f exp1 +"</ul>

<h3>
Church-Rosser Theorem</h3>

<ul>
<li>
“f exp1 +” is then applied to f exp2</li>

<li>
Note here that (10 +) is a function, which is the same as</li>

<pre>(\x -> x+10)</pre>

<li>
There is a theorem called the <i>Church-Rosser Theorem</i> that states
that if both forms of evaluation (applicative and normal) return results
then the results are equal Problems with applicative order</li>
</ul>

<h3>
The problem is that applicative order may not produce a result</h3>

<ul>
<li>
Consider the constant function</li>

<pre>(lambda x. 2):&nbsp;
...> (\x -> 2) 7&nbsp;
2</pre>

<li>
Now the expression (3 `div` 0) is an error:</li>

<pre>...> (3 `div` 0)&nbsp;
Program error: {primQrmInt 3 0}</pre>
</ul>

<h3>
Haskell delays evaluation of the argument</h3>

<ul>
<li>
In Haskell we get the following:</li>

<pre>...> (\x -> 2) (3 `div` 0)&nbsp;
2</pre>

<li>
Haskell never evaluates the argument!</li>

<li>
Compare Java, where we have</li>

<pre>int f (int x) {&nbsp;
&nbsp;&nbsp;&nbsp; return 2;&nbsp;
}&nbsp;
...&nbsp;
f (3 / 0);</pre>
raises an exception</ul>

<h3>
A complete Java program</h3>

<ul>
<pre>import java.io.*;
class HaskellTest {&nbsp;
&nbsp;&nbsp;&nbsp; int f (int x) {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 2;&nbsp;
&nbsp;&nbsp;&nbsp; }&nbsp;
&nbsp;&nbsp;&nbsp; public static void main (String[] args) throws IOException {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HaskellTest ht = new HaskellTest();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; byte [] x = new byte [1];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.in.read(x);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("" + f(3/((int)x[0] - 48)));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // I needed to hide from the compiler the division by 0
&nbsp;&nbsp;&nbsp; }
}</pre>
</ul>

<h3>
Result of evaluating the argument first</h3>

<ul>
<pre>C:>java HaskellTest
0
java.lang.ArithmeticException: / by zero at HaskellTest.main (HaskellTest.java:8)</pre>

<li>
The classic example is the function <tt>(lambda x. x x)</tt>, which apples
the argument to itself</li>

<li>
Sadly, Haskell rejects this function:</li>
</ul>

<h3>
Type checking rejects (lambda x. x x)</h3>

<ul>
<pre>...> :t (\x -> x x)
ERROR: Type error in application
*** expression&nbsp;&nbsp;&nbsp;&nbsp; : x x
*** term&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : x
*** type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : a -> b
*** does not match : a
*** because&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : unification would give infinite type</pre>
</ul>

<h3>
Further consideration of evaluation order</h3>

<ul>
<li>
If we were allowed to define (lambda x. x x), consider ((lambda x. x x)
(lambda x. x x))</li>

<li>
It evaluates to ((lambdax. x x) (lambdax. x x)),</li>

<li>
i.e. the evaluation process is infinite (normal or applicative)</li>

<li>
Applicative evaluation fails on</li>

<pre>((lambda y. 2) ((lambda x. x x) (lambda x. x x)))</pre>
because the argument is never evaluated
<pre>((lambday. 2) ((lambdax. x x) (lambdax. x x)))</pre>
would evaluate to 2 in normal order</ul>

<h3>
<a NAME="recursion"></a>Meaning of recursion</h3>

<ul>
<li>
WHAT DOES RECURSION MEAN?</li>

<li>
You know what a recursive function looks like:</li>

<pre>length x = if x == [] then 0 else 1 + length (tail x)</pre>

<li>
How do we write this in lambda-notation?</li>

<pre>(\x -> if x == [] then 0 else 1 + ???(tail x))</pre>
</ul>

<h3>
What do we do with the ??? ?</h3>

<ul>
<li>
Recursion is vital to functional programming and lambda-calculus is a model
for such calculation</li>

<li>
Defining recursion is a challenge…</li>

<li>
Consider a new function</li>

<pre>H<sub>len</sub> :: ([t] -> u) -> [t] -> u&nbsp;
H<sub>len</sub> = (\f x -> if x == [] then 0 else 1 + (f (tail x)))</pre>
</ul>

<h3>
H<sub>len</sub> length = length</h3>

<ul>
<li>
How does H work?</li>

<li>
Try it on the function “sum”</li>

<pre>H<sub>len</sub> sum [4,5,6] => 1 + sum [5,6] => 1 + 11 => 12</pre>

<li>
This is not much to do with “sum”</li>

<li>
However, if we knew what “length” was, we would have</li>

<pre>H<sub>len</sub> length [4,5,6] => 1 + length [5,6] => 3</pre>
</ul>

<h3>
Fixed-points</h3>

<ul>
<li>
In fact H<sub>len</sub> length = length and “length” is the only function
like that</li>

<li>
length is defined to be the function f that satisfies Hlen f = f</li>

<li>
We do not get into the conditions when such a fixed-point of Hlen exists
here</li>

<li>
Another example is factorial. The textbook writes it out in lambda-notation</li>
</ul>

<h3>
Factorial</h3>

<ul>
<pre>factorial n = if n ==0 then 1 else n * (factorial (n - 1))</pre>

<li>
In lambda-calculus:</li>

<pre>(\n -> if n == 0 then 1 else n * ???(n-1))</pre>

<li>
Define Hfact by</li>

<pre>Hfact :: (Int->Int)->Int->Int
Hfact f n = if n==0 then 1 else n * f(n-1)</pre>
</ul>

<h3>
Applying H<sub>fact</sub></h3>

<ul>
<li>
Apply H<sub>fact</sub> to the Fibonacci function:</li>

<pre>H<sub>fact</sub> fib = (\n -> if n==0 then 1 else n * fib(n-1)</pre>

<pre>e.g. H<sub>fact</sub> fib 5 = 5*fib 4 = 5*3=15</pre>
not much to do with fib, but if we had a factorial function fact we would
have Hfact fact = (\n -> if n == 0 then 1 else n * fact(n-1)</ul>

<h3>
General definition</h3>

<ul>
<li>
Here</li>

<pre>H<sub>fact</sub> fact = fact,</pre>
i.e. the factorial function is the “smallest” fixed point of H<sub>fact</sub>
<li>
In general, to give meaning to the recursive function</li>

<pre>f = (lambda x. if (cond(x)) then val(x) else expr(f, x))</pre>
(which cannot be expressed in lambda-notation), we define
<pre>H<sub>f</sub> =(lambda F. lambda x. if (cond(x)) then val(x) else expr(F, x))</pre>
</ul>

<h3>
The fixed-point combinator</h3>

<ul>
<li>
The function f is the unique “least” fixed-point of H<sub>f</sub></li>

<li>
There is a lambda-function that returns the fixed-point called the fixed-point
combinator (at least Y exists in untyped lambda-calculus):</li>

<pre>Y = (lambda h. (lambda x. h (x x)) (lambda y. h (y y)))</pre>
</ul>

<h3>
factorial = Y H<sub>fact</sub></h3>

<ul>
<li>
Consider:</li>

<pre>Y = (lambda h. (lambda x. h (x x)) (lambda y. h (y y)))</pre>

<li>
Substitution on both sides shows that Y H = H (Y H) so that Y H is a fixed
point of H.</li>

<li>
You can also check that:</li>

<pre>Y H<sub>fact</sub> n = if n == 0 then 1 else n * Y H<sub>fact</sub> (n - 1)</pre>

<li>
So</li>

<pre>factorial = Y H<sub>fact</sub></pre>
</ul>

<h3>
The fixed point does not always exist</h3>

<ul>
<li>
Existence of a “least” fixed point is subtle and we have not proved its
existence here</li>

<li>
Clearly some recursive functions are not really defined and would not be
fixed points of an operator, e.g.</li>

<pre>f n = if n == 0 then 1 else f(abs n + 1)</pre>

<li>
Only defined for n=0, not defined for any positive or negative n</li>
</ul>

<h3>
Booleans</h3>

<ul>
<li>
Define two functions:</li>

<pre>true = lambda x. lambda y. x</pre>

<pre>(in Haskell: (\x y -> x))</pre>

<pre>false = lambda x. lambda y. y</pre>

<pre>(in Haskell: (\x y -> y))</pre>

<li>
Then define</li>

<pre>if a b c = lambda z. (a z) (b z) (c z)</pre>

<li>
Suppose <tt>(a z) = true</tt>:</li>

<pre>(if a b c) z&nbsp;
=> (a z) (b z) (c z)
=> (lambda x. lambda y. x) (b z) (c z)&nbsp;
=> (lambda y. (b z)) (c z)&nbsp;
=> (b z)</pre>

<pre></pre>
</ul>

</body>
</html>
