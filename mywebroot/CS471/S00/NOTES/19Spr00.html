<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Head/ Lander">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; U) [Netscape]">
   <meta name="Description" content="CS471 spr 00">
   <title>Reasoning about programs</title>
</head>
<body text="#000000" bgcolor="#F5F5F5" link="#00FF00" vlink="#666666" alink="#FF0000">
&nbsp;
<center><table BORDER CELLSPACING=0 CELLPADDING=0 BGCOLOR="#FFFFF0" >
<tr>
<td><a href="http://bingweb.binghamton.edu/~head/CS471/NOTES/18Spr00.html">&nbsp;previous</a></td>

<td><a href="http://bingweb.binghamton.edu/~head/CS471/NOTES/20Spr00.html">&nbsp;next&nbsp;</a></td>
</tr>
</table></center>

<center>
<h3>
Haskell 7</h3></center>

<center>
<h3>
&copy; Eileen Head, Leslie C. Lander, 2000</h3></center>
Purpose: To examine the how to prove different code computes the same results
.
<br>&nbsp;<a href="http://bingweb.binghamton.edu/~head/CS471/CODE/Scripts/Hof.lhs">Hof.lhs</a>
illustrates some addition examples.
<h3>

<hr WIDTH="100%"></h3>

<h3>
Review for test</h3>

<ul>
<li>
Arguments can be types i.e.</li>

<br><tt>> fn (x::Int)&nbsp; = (+) x</tt>
<br><tt>&nbsp; ...> :t fn</tt>
<br><tt>&nbsp; fn :: Int -> Int -> Int</tt>
<p><tt>> f x = (+) x</tt>
<br><tt>&nbsp; ...> :t f</tt>
<br><tt>&nbsp; f :: Num a => a -> a -> a</tt>
<p><tt>> elem 3 [1,2,3]</tt>
<br><tt>> elem 'a' "xyz"</tt>
<p>(play with dropWhile, takeWhile, take, drop)</ul>

<ul>
<li>
Problem remove all occurences of a character in a string of lower case
characters AND change to upper case.</li>

<br><tt>Main> removeCapP 'c' "abccc cdef gcfc"</tt>
<br><tt>"AB DEF GF"</tt>
<br>&nbsp;
<li>
"Primitive" recursion</li>

<br><tt>> removeCapP r str =</tt>
<br><tt>>&nbsp;&nbsp;&nbsp;&nbsp; if str==[] then []</tt>
<br><tt>>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
else if head str == r</tt>
<br><tt>>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
then removeCapP r (tail str)</tt>
<br><tt>>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
else toUpper (head str):removeCapP r (tail str)</tt>
<br>&nbsp;
<li>
Recursion with pattern matching and guards</li>

<br><tt>> removeCap r (c:cs)</tt>
<br><tt>>&nbsp; | r == c = removeCap r cs</tt>
<br><tt>>&nbsp; | otherwise = (toUpper c):removeCap r cs</tt>
<br><tt>> removeCap r [] = []</tt>
<br>&nbsp;
<li>
List comprehension</li>

<br><tt>> removeCapLC r cs = [toUpper c | c &lt;- cs, c /=r ]</tt>
<br>&nbsp;
<li>
Higher order functions</li>

<br><tt>> removeCapHOF r cst = (filter ((toUpper r) /=) . map toUpper)
cst</tt>
<br>&nbsp;
<br>&nbsp;
<li>
Higher order functions ??</li>

<br><tt>> removeCapHOFX r cst = (map toUpper . filter (r /= )) cst</tt></ul>

<hr NOSHADE WIDTH="100%">
<h3>
<i><u>Why Study Functional Languages?</u></i></h3>
Research began in the 1960s to prove things about programs. Areas that
were studied were:
<ul>
<li>
How to prove a program is correct.</li>

<li>
<u>Given the same input prove different code computes the same results.</u></li>

<li>
Prove one program is faster than another.</li>

<li>
A given program will always terminate.</li>
</ul>
Continued....
<h3>

<hr WIDTH="100%">Proofs -- Induction proof over finite lists</h3>

<blockquote>&nbsp;
<table>
<caption>Recursive Definitions</caption>

<tr>
<td>(len.1)</td>

<td><tt>len [] = 0</tt></td>
</tr>

<tr>
<td>(len.2)</td>

<td><tt>len (x:xs) = 1 + len xs</tt></td>
</tr>

<tr>
<td>(++.1)</td>

<td><tt>[] ++ ys = ys</tt></td>
</tr>

<tr>
<td>(++.2)</td>

<td><tt>(x:xs) ++ ys = x :(xs ++ ys)</tt></td>
</tr>
</table>
</blockquote>

<h3>
&nbsp;length (xs ++ ys) =?= length xs + length ys</h3>

<blockquote>&nbsp;
<table BORDER=0 WIDTH="65%" BGCOLOR="#E8E8E8" >
<caption>BASE CASE:
<br>Prove: <u>len ([] ++ ys) = len [] + len ys</u></caption>

<tr>
<td><tt>len ([] ++ ys)&nbsp;</tt></td>

<td><tt>len [] + len ys</tt></td>
</tr>

<tr>
<td>=
<table BORDER >
<tr>
<td><tt>len ys</tt></td>

<td>++.1</td>
</tr>
</table>
</td>

<td>=
<table BORDER >
<tr>
<td><tt>0 + len ys</tt></td>

<td>len.1</td>
</tr>
</table>

<p>=
<table BORDER >
<tr>
<td><tt>len ys</tt></td>

<td>&nbsp;+ identity</td>
</tr>
</table>
</td>
</tr>

<tr>
<td><tt>len ys</tt></td>

<td><tt>len ys</tt></td>
</tr>
</table>
Both sides are true, therefore base case is True
<br>
<hr ALIGN=LEFT SIZE=1 NOSHADE WIDTH="75%">
<br>&nbsp;
<br>&nbsp;
<table BORDER=0 WIDTH="85%" BGCOLOR="#E8E8E8" >
<caption>INDUCTION STEP:&nbsp;
<br>Assume: len (xs ++ ys) = len xs + len ys
<br>Prove: <u>len ((x:xs) ++ ys) =?= len (x:xs) + len ys</u></caption>

<tr>
<td><b><tt>len((x:xs) ++ ys)</tt></b></td>

<td><b><tt>len (x:xs) + len ys</tt></b></td>
</tr>

<tr>
<td>=
<table BORDER WIDTH="100%" >
<tr>
<td><tt>len( x:(xs ++ ys))</tt></td>

<td>++.2</td>
</tr>
</table>
=
<table BORDER WIDTH="100%" >
<tr>
<td><tt>1 + len (xs ++ ys)</tt></td>

<td>len.2</td>
</tr>
</table>
=
<table BORDER WIDTH="100%" >
<tr>
<td><tt>1 + len xs + len ys</tt></td>

<td>Induction&nbsp;
<br>Hypotheses</td>
</tr>
</table>
</td>

<td></td>
</tr>

<tr>
<td>=
<table BORDER WIDTH="100%" >
<tr>
<td><tt>(1 + len xs) + len ys</tt></td>

<td>+ Asso</td>
</tr>
</table>
</td>

<td>=
<table BORDER WIDTH="100%" >
<tr>
<td><tt>(1 + len xs)+len ys</tt></td>

<td>len.2</td>
</tr>
</table>
</td>
</tr>
</table>
Both sides are equal completing the induction proof!</blockquote>

<h3>

<hr NOSHADE WIDTH="100%">Higher-level proof</h3>

<blockquote>&nbsp;
<table>
<caption><u>Definitions</u></caption>

<tr>
<td>(map.1)</td>

<td><tt>map f [] = []</tt></td>
</tr>

<tr>
<td>(map.2)</td>

<td><tt>map f (x:xs) = f x:map f xs</tt></td>
</tr>

<tr>
<td>(comp.1)</td>

<td><tt>(f . g) x = f (g x)</tt></td>
</tr>
</table>

<h4>
map (f . g) xs =?= (map f . map g) xs</h4>
&nbsp;
<table BORDER=0 WIDTH="65%" BGCOLOR="#E8E8E8" >
<caption>Base Case
<br>Prove: <u>map (f . g) [] =?= (map f . map g) []</u></caption>

<tr>
<td><b><tt>map (f . g) []</tt></b></td>

<td><b><tt>(map f . map g) []</tt></b></td>
</tr>

<tr>
<td>
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<br>&nbsp;
<p><tt>=</tt>
<table BORDER >
<tr>
<td><tt>&nbsp;[]&nbsp;</tt></td>

<td>map.1</td>
</tr>
</table>
</td>

<td><tt>=</tt>
<table BORDER >
<tr>
<td><tt>map f (map g [])</tt></td>

<td>comp.1</td>
</tr>
</table>

<p><tt>=</tt>
<table BORDER >
<tr>
<td><tt>map f []</tt></td>

<td>map.1</td>
</tr>
</table>

<p><tt>=</tt>
<table BORDER >
<tr>
<td>&nbsp; []&nbsp;</td>

<td>map.1</td>
</tr>
</table>
</td>
</tr>
</table>
Both sides are equal therefore the base case is true.
<br>
<hr ALIGN=LEFT SIZE=1 NOSHADE WIDTH="75%">
<br>&nbsp;
<br>&nbsp;
<table BORDER=0 WIDTH="90%" BGCOLOR="#E8E8E8" >
<caption>Induction Step:
<br>Assume: map (f . g) xs = (map f . map g) xs
<br>Prove: <u>map (f . g) (x:xs) = (map f . map g) (x:xs)</u></caption>

<tr>
<td><b><tt>map (f . g) (x:xs)</tt></b></td>

<td><b><tt>(map f . map g) (x:xs)&nbsp;</tt></b></td>
</tr>

<tr>
<td>=&nbsp;
<table BORDER WIDTH="100%" >
<tr>
<td><tt>(f . g) x:map (f . g)xs</tt></td>

<td>map.2</td>
</tr>
</table>
</td>

<td>=
<table BORDER WIDTH="100%" >
<tr>
<td><tt>(map f (map g(x:xs))&nbsp;</tt></td>

<td>comp.1</td>
</tr>
</table>
</td>
</tr>

<tr>
<td>=
<br>&nbsp;
<table BORDER WIDTH="100%" >
<tr>
<td><tt>f(g x):map (f . g)xs</tt></td>

<td>comp.1</td>
</tr>
</table>
</td>

<td>=
<table BORDER WIDTH="100%" >
<tr>
<td><tt>map f( g x:map g xs)</tt></td>

<td>map.2</td>
</tr>
</table>

<p>=
<table BORDER WIDTH="100%" >
<tr>
<td><tt>f( g x):map f (map g xs)</tt></td>

<td>&nbsp;map.2</td>
</tr>
</table>
</td>
</tr>

<tr>
<td>=
<table BORDER WIDTH="100%" >
<tr>
<td><tt>f(g x):(map f . map g)xs</tt></td>

<td>induction</td>
</tr>
</table>
</td>

<td>=
<table BORDER WIDTH="100%" >
<tr>
<td><tt>f(g x):(map f . map g)xs</tt></td>

<td>comp.1</td>
</tr>
</table>
</td>
</tr>
</table>
Both sides are equal completing the induction proof!</blockquote>

<hr NOSHADE WIDTH="100%">
<h4>
Properties of general functions that can be proved:</h4>

<ul>
<li>
<tt>map ( f. g ) xs = (map f . map g) xs</tt></li>

<li>
<tt>(filter p . map f) xs = (map f . filter (p . f)) xs</tt></li>

<ul>
<li>
Applying the filter first is more efficient</li>
</ul>

<li>
<tt>&nbsp;map f ( reverse xs) = reverse (map f xs )</tt></li>

<li>
<tt>&nbsp;map f ( ys ++ zs )&nbsp; = map f ys ++ map f zs</tt></li>
</ul>

<hr ALIGN=LEFT NOSHADE WIDTH="100%">
<blockquote>
<h6>
Thompson, Simon, <i>The Craft of Functional Programming, 2nd edition,</i>1999
sections 8.5, 10.9</h6>
</blockquote>

<hr WIDTH="100%">
<br>&nbsp;
<br>&nbsp;
<center><table BORDER CELLSPACING=0 CELLPADDING=0 BGCOLOR="#FFFFF0" >
<tr>
<td><a href="http://bingweb.binghamton.edu/~head/CS471/NOTES/18Spr00.html">&nbsp;previous</a></td>

<td><a href="http://bingweb.binghamton.edu/~head/CS471/NOTES/20Spr00.html">&nbsp;next&nbsp;</a></td>
</tr>
</table></center>

</body>
</html>
