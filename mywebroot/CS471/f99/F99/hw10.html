<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Eileen Head">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; U) [Netscape]">
   <title>Assignment 10 Programming Languages  --Haskell</title>
</head>
<body text="#000000" bgcolor="#FDFDFD" link="#660000" vlink="#660000" alink="#990000">
<a href="http://bingweb.binghamton.edu/~head/CS471/471hwIndex.html">Back</a>
<h4>
Assignment 10: Hard copy due Tue. DEC 7.</h4>
Read Chapters:
<blockquote>
<blockquote>Ghezzi: Chapter 7
<br>Thompson, <i>Haskell,<a href="http://www.cs.ukc.ac.uk/people/staff/sjt/craft2e/">The
Craft of Functional Programming</a></i> Chapters 10.3,12, Appendix A.
<blockquote>&nbsp;</blockquote>
</blockquote>
</blockquote>

<h4>
Instructions for posting solutions:</h4>

<ul>
<li>
Post Your solutions to the following problems on the web.</li>

<li>
You may work in groups. BUT the you will not receive for copied solutions.</li>

<li>
You should post who you work with and credit all sources. YOU will receive
a zero if you do not do this.</li>

<li>
Each student is to have their own solutions for each question.</li>
</ul>
NOTE: you can update these files as the semester progresses if you find
errors or better answers.
<h3>
<a href="http://bingweb.binghamton.edu/~head/CS471/requirements.html">Instructions
for presentation of&nbsp; hard copy</a></h3>
&nbsp;
<h3>
Written assignment:</h3>

<ol>
<li>
Understand the terms function definition, function application, normal
order, application order,&nbsp; referential transparency , and tail recursion.
You do not need to turn this in.</li>

<li>
(Ghezzi: page 369 exercise 2:) Reduce the (<font face="Symbol">l</font>x.(x
x))(<font face="Symbol">l</font>x.(x x)).&nbsp; What is peculiar about
this expression?</li>

<li>
(From Abelson and Sussman [1985]) It is also possible to express the integer
as lambda abstractions:</li>

<br>zero =<font face="Symbol"> l </font>f&nbsp; .<font face="Symbol"> l</font>
x . x
<br>one =&nbsp;<font face="Symbol"> l</font>f.<font face="Symbol">&nbsp;
l</font> x ( f x)
<br>two =&nbsp;<font face="Symbol"> l</font> f.<font face="Symbol"> l</font>
x ( f (f x))
<br>. . . .
<p>These are called Church numbers after Alonzo Church.
<p>Given the following definition of the successor function:
<center>successor =<font face="Symbol"> l </font>n.<font face="Symbol">
l </font>f.<font face="Symbol"> l</font> x ( f (( n f ) x ) ).</center>
&nbsp;&nbsp;&nbsp; show that (successor zero) = one (you do not need to
turn this in)
<br>&nbsp;&nbsp;&nbsp; and (successor one) = two&nbsp; (turn this in).</ol>

<h3>
<b>Programming Assignment:</b></h3>
<b>Do not post your assignment.&nbsp; Email your code to&nbsp;</b> <a href="mailto:cs471h@binghamton.edu">cs471h</a>
also following <a href="http://bingweb.binghamton.edu/~head/CS471/requirements.html">instructions</a>
for how to document your program and name your <b>attached program file.</b>
<br>You will find some sample code here (will be supplied later).
<ol>
<ol>
<li>
Write a definition using list comprehension,&nbsp; countOccurrences e l,&nbsp;
that returns the number of times that element e occurs in list l, thus</li>

<br>&nbsp;&nbsp;&nbsp; ..> countOccurrences 'd'&nbsp; ['e',' t', 'r', 'd',
'g', 'd', 'd', 'e' ]
<br>&nbsp;&nbsp;&nbsp;&nbsp; returns 3
<br>&nbsp;&nbsp;&nbsp; ..> countOccurrences 'a' ['e',' t', 'r', 'd', 'g',
'd', 'd', 'e']
<br>&nbsp;&nbsp;&nbsp; returns 0
<li>
Redo 1 ONLY using&nbsp; HOF (higher order functions i.e. map, foldr,foldl,
iter, etc.).</li>

<li>
Given a function f of type<tt> a -> b -> c </tt>write down a lambda expression
<tt>(\
... -> ...)</tt>that describe the function of type<tt> b -> a -> c&nbsp;</tt>
which behaves like f but which takes its argument in the other order.&nbsp;
(Thompson 10.6)</li>

<li>
Redo the Palindrome using only function application.</li>

<li>
(Thompson pg. 175 exercise 10.9) Define a function <tt>total</tt></li>

<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <tt>total :: (Int -> Int)
-> (Int -> Int)</tt>
<br>so that total<tt> f i</tt>s a function which at value<tt> n </tt>gives
the total
<br><tt>&nbsp;&nbsp;&nbsp; f 0 + f 1 + f 2 + ... + f n</tt>
<li>
Find the average of a list of Ints using HOF.</li>

<li>
Find the average of a list of Float using HOF.</li>

<li>
The BookCompany program creates an inventory by adding "Book"s to the inventory.&nbsp;
The program can add "Book"s to the inventory, sort the inventory and print
out the inventory.&nbsp; It is implemented in three paradigms using Haskell,
Java and C. All three implementations use the generic sort method supplied
in their respective library.&nbsp; The sorting order of the "Book"s is
based on the ascending order of year, followed by the ascending lexical
order of the book title.</li>

<ol TYPE=A>
<ol TYPE=a>
<li>
The Haskell version, <a href="http://bingweb.binghamton.edu/~head/CS471/CODE/Scripts/BookCompany.lhs">BookCompany.lhs
</a>&nbsp;
is implemented literal style. It uses the sort definition found in <a href="http://haskell.org/onlinelibrary/list.html">List.hs</a>
. In order to use the sort the type Book must be in the class Ord.&nbsp;
Therefore the user must declare Book to be in class Ord as well as implement
the expected methods.</li>

<li>
The Java implementation, <a href="http://bingweb.binghamton.edu/~head/CS471/CODE/Scripts/BookCompany.java">BookCompany.java,</a>
uses the static method&nbsp; <a href="http://java.sun.com/products/jdk/1.2/docs/api/java/util/Collections.html#sort(java.util.List, java.util.Comparator)">sort</a>
found in the <a href="http://java.sun.com/products/jdk/1.2/docs/api/java/util/Collections.html">java.util.Collections</a>
class .&nbsp; Sort uses a modified mergesort to sort a list of mutually
comparable elements.&nbsp; The user must supply an ordering of "Book" to
the sorting method.&nbsp; This is done by implementing the interface <a href="http://java.sun.com/products/jdk/1.2/docs/api/java/util/Comparator.html">Comparator</a>&nbsp;
for the elements type in the list and passing the an object of the class
that implements it.&nbsp; This version uses a nested class and an inner
class.</li>

<li>
The "C" implementation,&nbsp; <a href="http://bingweb.binghamton.edu/~head/CS471/CODE/Scripts/bookCompany.c">bookCompany.c</a>&nbsp;
use the stdlib's qsort to sort the inventory.&nbsp; The user must supply
an ordering function to the qsort for the data being sorted.&nbsp; This
is done by implement a function for ordering following the same rules as
compare in <a href="http://java.sun.com/products/jdk/1.2/docs/api/java/util/Comparator.html">Comparator</a>
in Java and then passing the function as one of the parameter.</li>
</ol>

<li>
Using the implements in 8a, 8b and 8c as models write a Haskell program
and either a Java or C program to keep a book inventory.&nbsp; Expand the
book type (in above) to include fields for an authors first and last name.&nbsp;
The sorting order should now be based descending order of year, followed
by ascending lexical order of author's last name and finally the the ascending
lexical order of book title.&nbsp; You will need to update the testing
data&nbsp; to reflect the addition information included.&nbsp; You should
make sure that there is a way to printout all the information about the
book. (Bingsuns has gcc for compiling C.&nbsp; Many machines on campus
have Java 1.2.)</li>

<br>&nbsp;</ol>

<li>
&nbsp;<a href="http://bingweb.binghamton.edu/~head/CS471/CODE/Scripts/Tree.lhs">Tree.lhs</a>
is a modification of Thompson's the search tree given section 16.7. Add
the following definitions:</li>

<ol TYPE=a>
<li>
Define a function inorder :: Ord a => Tree a -> [a]</li>

<br>Create a list of the items as you traverse the tree inorder.
<li>
Define a function preorder :: Ord a => Tree a -> [a]</li>

<br>Create a list of the items as you traverse the tree preorder.
<li>
Define a function postorder :: Ord a => Tree a -> [a]</li>

<br>Create a list of the items as you traverse the tree postorder.
<li>
Define a function depth :: Tree a -> Int</li>

<br>That returns the depth of the tree.&nbsp; (Root has depth 0)
<li>
Define an higher-order function foldTree :: (a -> a -> a) -> Tree a ->
a</li>

<br>For example:
<br>Tree> foldTree (+) t1
<br>26
<br>Tree> foldTree (+) t2
<br>23
<br>Tree>foldTree max t1
<br>9
<br>Tree>foldTree max t2
<br>11
<br>Tree>foldTree max (join t1 t2)
<br>11</ol>
</ol>
Nov 28,1999</ol>

</body>
</html>
