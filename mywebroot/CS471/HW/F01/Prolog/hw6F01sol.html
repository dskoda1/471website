<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
    
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
    
  <meta name="GENERATOR" content="Mozilla/4.77 [en] (Windows NT 5.0; U) [Netscape]">
  <title>Fall 2001 CS471 Homework #6 Solutions</title>
</head>
  <body>
  
<center><b><font size="+2">Fall 2001</font></b> <br>
<b><font size="+2">CS 471 Programming Language</font></b> <br>
<b><font size="+2">Homework #6 Solution</font></b></center>
  
<p>Purpose: Review computer architecture and how it relates to the design 
of HOL (higher order languages) and semantics of HOL. </p>
<ol>
 <li> &nbsp;What is IEEE 754?</li>
  <br>
  <b>Answer 1: IEEE 754 is a representation of floating point numbers and
operations.</b> <br>
&nbsp; <li> &nbsp;Java has 8 primitive data types.&nbsp; What are they? How
are the different primitive types for numbers encoded?&nbsp; What is the
maximum and minimum value for int, float, and double? (See my online Java
references for help.)&nbsp; The easiest way to present you answer is in a
table.</li>
 
</ol>
  
<ol>
&nbsp; 
  <table border="1" cols="5" width="100%">
 <tbody>
      <tr>
 <td><b>Primitive Type</b></td>
  <td><b>Size</b></td>
  <td><b>Minimum</b></td>
  <td><b>Maximum</b></td>
  <td><b>Encoding</b></td>
 </tr>
  <tr>
 <td>boolean</td>
  <td>-</td>
  <td>-</td>
  <td>-</td>
  <td>two values: true and false</td>
 </tr>
  <tr>
 <td>char</td>
  <td>16-bit</td>
  <td>Unicode 0</td>
  <td>Unicode 2<sup>16</sup>-1</td>
  <td>16-bit unsigned integers</td>
 </tr>
  <tr>
 <td>byte</td>
  <td>8-bit</td>
  <td>-128</td>
  <td>+127</td>
  <td>8-bit signed two's complement</td>
 </tr>
  <tr>
 <td>short</td>
  <td>16-bit</td>
  <td>-2<sup>15</sup></td>
  <td>2<sup>15</sup>-1</td>
  <td>16-bit signed two's complement</td>
 </tr>
  <tr>
 <td>int</td>
  <td>32-bit</td>
  <td>-2<sup>31</sup></td>
  <td>+ 2<sup>31</sup>-1</td>
  <td>32-bit signed two's complement</td>
 </tr>
  <tr>
 <td>long</td>
  <td>64-bit</td>
  <td>-2<sup>63</sup></td>
  <td>+ 2<sup>63</sup>-1</td>
  <td>64-bit signed two's complement</td>
 </tr>
  <tr>
 <td>float</td>
  <td>32-bit</td>
  <td>(+/-)1.40129846432481707e-45&nbsp;</td>
  <td>(+/-)3.40282346638528860e+38&nbsp;</td>
  <td>32-bit IEEE 754 floating point numbers</td>
 </tr>
  <tr>
 <td>double</td>
  <td>64-bit</td>
  <td>(+/-)4.94065645841246544e-324d</td>
  <td>(+/-)1.79769313486231570e+308d</td>
  <td>64-bit IEEE 754 floating-point numbers</td>
 </tr>
  <tr>
 <td>void</td>
  <td>-</td>
  <td>-</td>
  <td>-</td>
  <td>Void</td>
 </tr>
 
    </tbody>
  </table>
 
</ol>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>Note: void is not included 
in Java Language Specification</b> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <i><font color="#3333ff">
source: Bruce Eckel's "Thinking in Java"</font></i> <br>
<i><font color="#3333ff">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
Java API:&nbsp; java.lang.Float, java.lang.Double</font></i> 
<ol>
 <li> There are 5 basic (scalar) data types in C. (Including pointers).&nbsp; 
What are they and how are they encoded? Where do you find the maximum and 
minimum values for int, float and double? In addition there are the following 
qualifiers: short, long, signed and unsigned. Briefly explain effect of the
qualifiers on the basic types.&nbsp; You should mention which standard you
are using(i.e ANSI/ISO amendment I or K&amp;R&nbsp; etc.). The easiest way
to present you answer is in a table.</li>
 
</ol>
 From K&amp;R: NOTE that int is implementation dependent.&nbsp;&nbsp; 
<table border="1" cols="4" width="100%">
 <tbody>
    <tr>
 <td><b>Data Types</b></td>
  <td><b>Encoding</b></td>
  <td><b>Minimum</b></td>
  <td><b>Maximum</b></td>
 </tr>
  <tr>
 <td><b>Integer Types</b></td>
  <td><br>
      </td>
  <td><br>
      </td>
  <td><br>
      </td>
 </tr>
  <tr>
 <td>int</td>
  <td>16-bit two's complement</td>
  <td>-32,767</td>
  <td>32,767</td>
 </tr>
  <tr>
 <td>char</td>
  <td>8-bit two's complement</td>
  <td>--</td>
  <td>--</td>
 </tr>
  <tr>
 <td><b>Floating-point Types</b></td>
  <td><br>
      </td>
  <td><br>
      </td>
  <td><br>
      </td>
 </tr>
  <tr>
 <td>float</td>
  <td>32-bit IEEE 754</td>
  <td>1.175494351E-38F</td>
  <td>3.402823466E+38F</td>
 </tr>
  <tr>
 <td>double</td>
  <td>64-bit IEEE 754</td>
  <td>2.2250738585072014E-308</td>
  <td>1.7976931348623157E+308</td>
 </tr>
  <tr>
 <td><b>Pointer Types</b></td>
  <td>byte-address occupying</td>
  <td>--</td>
  <td>--</td>
 </tr>
 
  </tbody>
</table>
  
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>One can find the maximum 
and minimum values for int, float, and double in header file, limit.h and 
float.h</b> <br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; qualifiers short, long, unsigned,
and signed define the range of values representable by a integer type. In</b>
 <br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; another word, the amount of
storage space allocated for the variable.</b> <br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; e.g.</b> <br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; short &lt;= int &lt;= long</b>
 <br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; unsigned means not taking the
most significant bit as sign bit. Therefore, no negative numbers. And, as
a result, greater range of numbers between 0 and the max.</b> <br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; signed is to take the most
significant bit as sign bit, hence there can be negative numbers.</b> </p>
<ol>
 <li> How does the philosophy of C differ from Java with respect to the implementation 
primitive (basic/scalar) types? (Discuss the positive and negatives of both
philosophies.</li>
  <br>
  <b>Ans 4:</b> <br>
  <b>Point 1: C gives designer freedom of coping the architecture of the
machine. However, this makes programmer needs to know the underlying architecture
to make the performance of the program works better. Java, on the other hand,
aims for platform independent. This frees programmer from boggled down with
great details of the architecture. However, the cost of platform indepedent
is that program might not make best use of the underlying architecture.</b>
 <br>
  <b>Point 2: Memory usage is another important factor. In C, programmer can
use qualifiers to allocate amount of memory usage. Java, on the other hand,
is limited to fix size of memory. If more memory is allocated to the type
than is needed, than memory is wasted.</b> <br>
  <b>Point 3: Java has automatic garbage collector which frees the programmer 
from knowing how much memory is been used. However, this comes the expense 
of complicated system.</b> <br>
  <b>Point 4: In Java, all variables are automatically initialized, but in
C they are not. This adds flexibility to C, but convenience to Java.</b> <br>
  <b>Point 5: Java has boolean primitive type, while C uses 0 and 1 for true
and false. Boolean type makes code more readable.</b>
</ol>
  <br>
&nbsp; <br>
&nbsp; 
<ol>
 <li> In Java 1.3 the modifier strictfp was added.&nbsp; What is the effect
of using this modifier?&nbsp; Why was it added to the language?</li>
  <br>
&nbsp; 
  <p>&nbsp; </p>
  <p><b>Ans 5: The keyword "strictfp" is used to control certain aspects of
floating-point arithmetic, to make all float or double expressions within 
the class declaration be explicitly FP-strict. "Within an FP-strict expression, 
all intermediate values must be elements of the float value set or the double
value set, implying that the results of all FP-strict expressions must be
those predicted by IEEE 754 arithmetic on operands represented using single
and double formats. Within an expression that is not FP-strict, some leeway
is granted for an implementation to use an extended exponent range to represent
intermediate results; the net effect, roughly speaking, is that a calculation
might produce "the correct answer" in situations where exclusive use of the
float value set or double value set might result in overflow or underflow."</b>
 <br>
  <b>"strictfp is important because its use guarantees common behavior across
different Java implementations. In other words, you can know that the floating-point
arithmetic in your application behaves the same when you move your application
to a different Java implementation or hardware platform. "</b> <br>
  <i><font color="#3333ff">(source: Java Language Specification</font></i>
 <br>
  <i><font color="#3333ff">and&nbsp;&nbsp;&nbsp; http://developer.java.sun.com/developer/TechTips/txtarchive/Apr01_GlenM.txt</font></i>
 <br>
  <i><font color="#3333ff">and&nbsp;&nbsp;&nbsp; http://developer.java.sun.com/developer/JDCTechTips/2001/tt0410.html)</font></i></p>
</ol>
  
<ol>
 <li> I have written a simple C program (hw6F01.c).</li>
  <br>
A. One would expect Part 1a and Part 1b to compute and print the same value
for sum.&nbsp; One would also expect that adding&nbsp; ten times the value
0.1 would result in 1.0.&nbsp; (Remember C does not have a boolean it uses
0 to mean false and all other&nbsp; values to mean true.) Compile in gcc
(either using cygwin or Sun work stations) and run.
</ol>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B. Does the execute 
as expected? <br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ans 6B: No, Part
1a and Part 1b have different result, differ by some decimal points.</b> 
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; C. Explain why (how)
the computer gets the results for Part 1 and Part 2? </p>
<blockquote><b>Answer 6C</b> <br>
  <b>First, most decimal fractions cannot be represented exactly as binary 
fractions. As the result, floating-point&nbsp; numbers are only approximated 
by the binary floating-point numbers stored in the machine.</b></blockquote>
  
  <blockquote><b>For example, 0.1 is represented as 0.1000000000000000055511151231257827021181583404541015625</b>
 <br>
    <b>However, if the machine only stored 17 significant digits, then 0.1
is represented as 0.10000000000000001, in which the original number has been
rouded up. In part B, since 0.1 is not exactly 1/10 in binary format, then
adding 0.1 10 times may not yield 1.0.</b> 
    <p><b>Second, only fixed significant digits be stored. As a consequence, 
part 1b, each result will be truncated or round off depends on the architecture. 
As a consequence, floating points addition are not associative.</b> <br>
&nbsp; </p>
    <p><i><font color="#3333ff">source: http://python.sourceforge.net/devel-docs/tut/node14.htm</font></i>
 <br>
    <i><font color="#3333ff">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
and&nbsp;&nbsp;&nbsp;&nbsp; http://www.lahey.com/float.htm</font></i></p>
    </blockquote>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D. If this code
was converted to Java what would you expect to happen? 
    <blockquote><b>Ans 6D: Java possibly will produce similar results as
part1 and part2, because they are using binary representation as well. Hence, 
similar reasoning applies.</b></blockquote>
  
      <ol>
 <li> What is a homoiconic language? Explain why Prolog is homoiconic.&nbsp; 
Can you name any other homoiconic language?</li>
  <br>
        <b>Ans 7: In Homoiconic language, programs and data have the same
representation. Prolog's facts and predicates are represented in same format.
And its facts and rules may be added and subtracted at any time. Lisp, Tcl,
and Snobol are other homiconic languages.</b>
      </ol>
  
      </body>
      </html>
