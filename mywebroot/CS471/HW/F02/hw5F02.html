<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
                  
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
                  
  <meta name="Author" content="Eileen Head">
                  
  <meta name="GENERATOR"
 content="Mozilla/4.78 [en] (Windows NT 5.0; U) [Netscape]">
  <title>Homework 5 Last Prolog Assignment Fall 2002</title>
</head>
<body text="#000000" bgcolor="#fdfdfd" link="#000099" vlink="#009900"
 alink="#000099">
   <font size="-2">&nbsp; </font><a
 href="http://bingweb.binghamton.edu/%7Ehead/CS471/471hwIndex.html">Back<font
 color="#cc0000"> &nbsp;10/03/02 7pm</font>     </a>
<h3><br>
</h3>
<a href="http://bingweb.binghamton.edu/%7Ehead/CS471/471hwIndex.html"><font
 color="#cc0000"> </font></a>
<h3 align="center">Assignment 5</h3>
     
<h4><a
 href="http://bingweb.binghamton.edu/%7Ehead/CS471/requirements.html">General
 Submission Instructions</a></h4>
   You hardcopy should begin with the following identification:   
<ul>
              
  <blockquote><font color="#000000">CS471 - Programming Languages</font><br>
       <font color="#000000">Section: </font><font color="#cc0000">&lt;YOUR
 Section number&gt;</font><br>
       <font color="#000000">Assignment #</font><font color="#cc0000">&lt;number&gt;
     </font><font color="#000000">due:</font><font color="#cc0000">&lt;DATE&gt;</font>
     <br>
       <font color="#000000">Author:</font><font color="#cc0000"> &lt;LastName&gt;,
 &lt;FirstName&gt; </font><font color="#000000">(</font><font
 color="#cc0000">&lt;EMail&gt;</font><font color="#000000">)</font><br>
       <font color="#000000">Date:</font><font color="#cc0000"> &lt;DATE&gt;</font></blockquote>
</ul>
<h3><b>Written Assignment:</b></h3>
   <b>Purpose: To understand how order imposed by the implementation of Prolog
causes problems.To understand the beauty of pattern matching.&nbsp;</b>  
<ol>
     <li>Below are 4 versions of subList(SubList, List) discussed in class.<br>
    <br>
subList1(S,L):-append(P,T,L),append(H,S,P).<br>
subList2(S,L):-append(H,S,P),append(P,T,L). <br>
subList3(S,L):-append(S,ST,T),append(H,T,L).<br>
subList4(S,L):-append(H,T,L),append(S,ST,T).</li>
  
  <ol>
    <li>Run each version above with the following input, S = [2,3], L = [1,2,3,4]</li>
    <li>Run each version above with the following input, S = [a,b], L = [1,2,3,4]</li>
    <li>One version runs out of stack-- &nbsp;Explain why this error occurs.<br>
      <br>
    </li>
  
  </ol>
    <li>Consider the following program:</li>
     
</ol>
     
<ol type="A">
              
  <ol type="A">
       <tt>fill(X,N,L) :- length(L,N), append([X],Lx,L), append(Lx,[X],L).</tt>
     <br>
   &nbsp;<li><tt>(Do not turn in).</tt>If the input <i>X</i> is a term and
 input       <i>N</i>is a positive integer, then what will the output <i>L</i>?
 Try the following.. also find other possible solutions with ";"</li>
                      
    <ol type="a">
         <li><tt>?-</tt>&nbsp; <tt>fill(xyz, 5, L).</tt></li>
         <li><tt>?- fill(xyz, 5, [H|T].</tt></li>
                      
    </ol>
       <li><tt>Try to briefly explain how it works.</tt></li>
       <li>Does the below code give the same results as <i>fill</i>?</li>
                      
    <ol type="A">
         <tt>fillr(X,0,[]):-!.</tt><br>
         <tt>fillr(X,N,[X|T]) :- Nx is N-1,fillr(X,Nx,T).</tt>          
        
    </ol>
       <li>Compare the execution time of the two version for various values
 of <i>N .&nbsp; </i>(Use "trace" or write your own append (use myAppend)
and length(use myLen) so you can see trace to see the execution steps. )</li>
              
  </ol>
     
</ol>
     
<h3><b>Programming Assignment:</b></h3>
   <b>Purpose:</b><li><b>The purpose is this assignment is</b></li>
   <br>
   <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1) reenforce recursive programming</b>
 <br>
   <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2) reenforce the use of the list
 data structure in Prolog</b><br>
   <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3) use of pattern recognition in
 programming</b><br>
   <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4) use of backtracking to solve
 problems.</b> <br>
   <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5) learn how to dynamically change
 prolog code</b>   
<ol>
   You may find this <a
 href="http://cbl.leeds.ac.uk/%7Etamsin/prologtutorial/index.html#menu">tutorial</a>
 or&nbsp; <a href="http://www.amzi.com/AdventureInProlog/advfrtop.htm">another
 tutorial</a> helpful.&nbsp; You will find the following builtin predicates
 helpful trace, help(predicate), and listing.&nbsp;&nbsp; <a
 href="http://www.swi.psy.uva.nl/projects/SWI-Prolog/Manual/DocIndex.html">Online
 documentation</a> .            
  <p><b>Files with hints and format : For most of the problems</b> <a
 href="XXXAs5.pl">XXXAs5.pl.</a><a href="file:///A%7C/hw/XXXAs5p1.pl"></a></p>
              
  <ol>
   &nbsp;            
  </ol>
     <li>(easy) Write a prolog program to reconize whether a "list of &nbsp;atoms"
 are in the language generated by the grammar given in HW2 problem 5.<br>
&nbsp; &nbsp; &nbsp; &lt;S&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font
 color="#3333ff">  :=&nbsp;</font><font color="#000000">     &nbsp;&nbsp;&nbsp;&nbsp;
1 &nbsp;  &lt;S&gt;&nbsp;&nbsp; 0<br>
     </font>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;<b><font color="#3333ff">|</font></b>&nbsp; &nbsp;
 &nbsp;+ 1 = 1                                                          
              <br>
    <font color="#000000">&lt;S&gt; is a non-terminal symbol and<b><font
 color="#009900"> 0,1,+</font></b> and<font color="#006600"> <b>=</b> </font>are
terminal  symbols.</font><br>
     </li>
     i.e.<br>
&nbsp; ?- s([1,+,1,=,1,0],A).<br>
&nbsp; &nbsp;A = []<br>
&nbsp; &nbsp;Yes<br>
  <br>
&nbsp; ?- s([1,1,+,1,=,1,0,0],A).<br>
&nbsp; A = [] <br>
&nbsp; Yes<br>
  <br>
&nbsp; &nbsp;?- s([1,1,1,+,1,=,1,1,1,0],A).<br>
&nbsp; &nbsp;No<br>
&nbsp;   
  <ol type="A">
              
  </ol>
   &nbsp;<li><font color="#000000">(easy- ONE relation)Define a predicate
append3DL&nbsp;  that concatenates three difference lists:</font></li>
     <br>
     <font color="#000000">&nbsp;&nbsp;&nbsp; <tt>?- append3DL( [z,y|A] -
A,  [x,w | B] -B, [u,v | C] - C, What).</tt></font><br>
     <tt><font color="#000000">&nbsp; What = [z, y, x, w, u, v | _n] - _n</font></tt>
   <br>
     <tt><font color="#000000">&nbsp; yes</font></tt><br>
   &nbsp;<br>
   &nbsp;<li>[Hard &nbsp;(only 3 lines)Do NOT use any built in functions.
except "is"] Write a procedure called <b>numOfAtoms</b> that takes a list
whose elements may be either atoms or lists (with any degree of embedding)
of atoms and returns the total number of atoms:</li>
              
  <ol start="2">
   ?-<b><tt>numOfAtoms([1,[a,s,d],[s,s,[1,4,5],[d,f,g]],[x,c,v]],NA)<br>
  NA = 15 </tt></b><br>
      <b><tt>?- numOfAtoms([[],[1,[a,s,d],[s,s,[1,4,5],[d,f,g]],[]],[x,c,v]],NA).<br>
  NA = 15 </tt></b><br>
       <b><tt><br>
       </tt></b>            
  </ol>
     <li>The following Finite State machine accepts all even parity "strings".
 Write a prolog program that accept all valid strings in the language. We
will represent the strings as a list of atoms. &nbsp;<br>
   Sigma = { 0,1 }, Start state = {q0}, &nbsp;Final state = { q0,q1 }, and<br>
  &nbsp; &nbsp; delta(q0,0) = q1<br>
  &nbsp; &nbsp; delta(q0,1) = q3<br>
  &nbsp; &nbsp; delta(q1,0) = q0<br>
  &nbsp; &nbsp; delta(q1,1) = q2<br>
  &nbsp; &nbsp; delta(q2,0) = q3<br>
  &nbsp; &nbsp; delta(q2,1) = q1<br>
  &nbsp; &nbsp; delta(q3,0) = q2<br>
  &nbsp; &nbsp; delta(q3,1) = q0.<br>
    <br>
  &nbsp; &nbsp; Remember you will need to build deltaHat(Q1,Str). &nbsp;The
 definition of deltaHat is:<br>
  &nbsp; &nbsp; deltaHat(Q,[]) = Q (Our program will represent the empty string
 as the empty list).<br>
  &nbsp; &nbsp; deltaHat(Q, [C|Cs]) = deltaHat(delta(Q,C),Cs).<br>
    <br>
  A string is accepted if deltaHat(q0, String) is in a final state (q0 or
q1).<br>
      <br>
  &nbsp; &nbsp; ?- accept([0,0,0,0,1,1,1,1,0,1,1]).<br>
  &nbsp; &nbsp; Yes<br>
  &nbsp; &nbsp; ?- accept([0,0,0,0,1,1,1,1,1]).<br>
  &nbsp; &nbsp; No<br>
  &nbsp; &nbsp; ?- accept([0,0,0,0,1,1,1,1,1,1]).<br>
  &nbsp; &nbsp; Yes<br>
  &nbsp; &nbsp; ?- accept([0,0,1,1,0,0,1,1,1,1,1,1]).<br>
  &nbsp; &nbsp; Yes<br>
  &nbsp; &nbsp; ?- accept([0,0,0,0,1]).<br>
  &nbsp; &nbsp; No<br>
  &nbsp; &nbsp; ?- accept([1,1,1,0,1,0,1,0,1,0]).<br>
  &nbsp; &nbsp;Yes<br>
      <br>
      <br>
    </li>
    <li>Write a predicate <b>show(ExpTree)</b> that makes a pretty print of
an expression tree. (See show(Tree) in previous homework).<br>
(See file for definition.)<br>
i.e.<br>
?- tree1(T), show(T).<br>
Tree =<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2<br>
&nbsp; times<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3<br>
plus<br>
&nbsp;&nbsp;&nbsp; 5<br>
    <br>
T = exp(plus, exp(const, 5), exp(times, exp(const, 3), exp(const, 2))) <br>
    <br>
Write a predicate <b>eval(ExpTree, Value)</b> that evaluates an expression
tree. i.e.<br>
    <br>
?- tree1(T), eval(T,V).<br>
T = exp(plus, exp(const, 5), exp(times, exp(const, 3), exp(const, 2)))<br>
V = 11 <br>
Yes<br>
    <br>
?- tree2(T), eval(T,V).<br>
T = exp(times, exp(times, exp(const, -3), exp(const, 2)), exp(plus, exp(const,
3), exp(const, 2)))<br>
V = -30 <br>
Yes</li>
     <br>
   &nbsp;   
</ol>
   <font color="#3333ff">Remember Programming is an individual task... :</font>
  
<p><font color="#3333ff">Resources use:</font></p>
     
<p><a href="mailto:head@binghamton.edu">Questions?(For E. Head)</a><br>
   &nbsp;</p>
   <br>
   <br>
  <br>
 <br>
<br>
</body>
</html>
