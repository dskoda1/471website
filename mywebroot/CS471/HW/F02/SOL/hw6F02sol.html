<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
           
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
           
  <meta name="GENERATOR"
 content="Mozilla/4.77 [en] (Windows NT 5.0; U) [Netscape]">
  <title>Fall 2001 CS471 Homework #6 Solutions</title>
</head>
<body>
    
<center><b><font size="+2">Fall 2002</font></b> <br>
 <b><font size="+2">CS 471 Programming Language</font></b> <br>
 <b><font size="+2">Homework #6 Solution</font></b></center>
    
<ol>
  <li> &nbsp;What is IEEE 754?</li>
   <br>
   <b>Answer 1: IEEE 754 is a representation of floating point numbers and
operations. It has&nbsp; three basic components: the sign, the exponent, and
the mantissa.</b> <br>
   <b>1. The sign bit, 0 denotes a positive number, 1 denotes a negative number.</b>
   <br>
   <b>2. The exponent field needs to represent both positive and negative
exponents. To do this, a bias is added to the actual exponent in order to
get the stored exponent. For IEEE single-precision floats, this value is 127.
Thus, an exponent of zero means that 127 is stored in the exponent field.
A stored value of 200 indicates an exponent of (200-127), or 73.&nbsp; For
IEEE double-precision floating point, the bias value is 1023.</b> <br>
   <b>3. The mantissa, also known as the significand, represents the precision
 bits of the number. It is composed of an implicit leading bit and the fraction
 bits. In IEEE single-precision floats, 23 bits are allocated to the mantissa,
 whereas in IEEE double-precision floats, 52 bits are allocated to the mantissa.</b><br>
  <font color="#3333ff"><i>Source: http://research.microsoft.com/~hollasch/cgindex/coding/ieeefloat.html<br>
http://www.psc.edu/general/software/packages/ieee/ieee.html<br>
Scott - page 212-214<br>
Haribson etal; (4 th ed) page 119<br>
 </i></font>  
  <p> &nbsp;&nbsp; </p>
   <li> "There are only a few basic data types in C: char ... int ... float
... double" (Kernighan &amp; Ritchie p36)</li>
            
  <p>A. For each type: What phase (language design, implementation, compile
time, run time)&nbsp; is the decision made on how the type is encoded , i.e.
how much space is allocated and the format in memory ?<b><br>
Answer 2A:</b> <b>The constants described in limit.h are specified during
implementation time. However, the possible range of values are specified
by the committee that designs the standard of the language (design time).
&nbsp;In another word, there is no general rule of what is the smallest type
a programmer can use to represent a value. This all depends on the C compiler
and the target machine. <br>
  </b><font color="#3333ff"><i>(Source: "Advanced Programming in the Unix
Environment" by W. Richard Stevens<br>
  </i><i>http://www.gnu.org/manual/glibc-2.2.5/html_node/Range-of-Type.html)<br>
Harbison etal: chap 5.<br>
  </i></font></p>
  
</ol>
<blockquote>B. At compile time your code finds the maximum and minimum values
for char,  int, float and double in the /usr/include/limits.h and /usr/include/float.h
 files supplied by the implementor of the compiler (on bingsuns, gnu). Look
 in these files to find these definitions (you may have to look in files included
by limits.h). Compare the values found on bingsuns to the values provided
here. (or K&amp;R page 257 or Harrison&amp;Steele page 112 and 118)&nbsp;&nbsp;
Give a reason why the values may be different. In addition there are the
following qualifiers: short, long, signed and unsigned. Briefly explain effect
of the qualifiers on the basic types. You should mention which standard you
are using(i.e ANSI/ISO amendment I or K&amp;R&nbsp; etc.).<br>
  <b>Answer 2B:</b><br>
  <b>Values among K&amp;R, bingsuns, gnu may differ because types are implementation
dependent. Advantage of implementation dependent is that programmer can make
use of the underlying architecture more efficiently. However, disadvantage
is that programmer has to be careful that the program may run on one machine
but not the other. <br>
Qualifiers <i>short, long, unsigned,</i> and <i>signed</i> define the range
of values representable by a integer type. <br>
In another word, the amount of storage space allocated for the variable.
  <br>
e.g. &nbsp;short &lt;= int &lt;= long. The storage space is implementation
dependant. <br>
  <i>unsigned</i> means not taking the most significant bit as sign bit.
Therefore, no negative numbers. Thus, greater range of numbers between 0
and the max.    <br>
  <i>signed</i> is to take the most significant bit as sign bit, therefore
smaller range numbers between 0 and the max, but negative number is possible.
  <br>
  </b></blockquote>
<ol>
  
  <p>&nbsp;<br>
C. The 99 standard has&nbsp; new types like long long, and long double.&nbsp;&nbsp;
 What are they (size and maximum values)?&nbsp; Why is there a necessarily
 to include new types?&nbsp; Please include any pertinent links. &nbsp; <br>
  </p>
      
  <p><b>Answer 2C:&nbsp; New type long long (signed and unsigned) and long
double are implementation dependent. According to &nbsp;</b><i><font
 color="#3333ff">http://usgibm.nersc.gov/vac/ref/ruimpint.htm</font></i>,
long long supports 64-bits, and long double supports 128-bits.&nbsp;<b><br>
It is necessary to include new types to increase the precision of representing
floating numbers. &nbsp;</b><br>
  <br>
  </p>
</ol>
<blockquote>3.&nbsp; The C code provided below illustrates some problems with
the implementation of floating point numbers. You are given&nbsp; a simple
C program ( hw6F02.c) to run. There is a&nbsp; makefile and README if you
want to use them. (Hw6f02.zip) </blockquote>
      
<ol>
   
</ol>
 
<ol>
   A. Compile and run this code usnig GCC. (either using cygwin or Sun work
stations).<br>
  <b>Using gcc<br>
Part 1A --increasing i's-- sum = 1.639638e+00<br>
Part 1A --decreasing i's-- sum = 1.639638e+00<br>
  <br>
Part 1B--increasing i's -- sum = 7.919039e+00<br>
Part 1B -- decreasing i's -- sum = 8.508162e+00<br>
  <br>
Part 2 -- f is 1.000000e-01,&nbsp; sum is 1.000000e+00<br>
Part 2B?&nbsp; sum == 1.0F IS false (0)</b> 
</ol>
 
<blockquote>  B. The 4 sums are computed in part1() and printed out in. Part
1A's printout appears to be the same independent of the calculation. However,
the sum printed out in Part 1B's printout is different. One would expect&nbsp;
program would compute and print the same value for sum.&nbsp;&nbsp; Explain
what is going on.<b><br>
Answer 3B: In part 1A since numbers are smaller, 1 divides by smaller number,
the precision of floating points is able to keep within the fixed space allocated
to floating point on the system. &nbsp;In part 1B where 1 is divided by large
numbers, the result is extremely small numbers in floating points. Thus, there
may be loss of precision due to limited space allocated to the floating point.
&nbsp;And, depends on the iteration, the rounding off/truncation is done
differing. Thus, result in different results in part 1B.&nbsp;</b></blockquote>
<blockquote>  
  <p>C. One would also expect that adding ten times the value 0.1 would result
in 1.0.&nbsp; Explain why (how) the computer gets the results for part 2 (part2())
?<b><br>
Answer 3C</b> <b><br>
First, most decimal fractions cannot be represented exactly as binary  fractions.
As the result, floating-point&nbsp; numbers are only approximated  by the
binary floating-point numbers stored in the machine.</b> <b>For example, 0.1
is represented as 0.1000000000000000055511151231257827021181583404541015625.</b><b><br>
However, if the machine only stored 17 significant digits, then 0.1 is represented
as 0.10000000000000001, in which the original number has been rouded up. In
part B, since 0.1 is not exactly 1/10 in binary format, then adding 0.1 10
times may not yield 1.0.</b>       <b><br>
  </b></p>
  
  <p><b>Second, only fixed significant digits be stored. As a consequence,
 part 1b, each result will be truncated or round off depends on the architecture.
 As a consequence, floating points addition are not mathematically associative.</b><br>
  <i><font color="#3333ff">Source: http://python.sourceforge.net/devel-docs/tut/node14.htm<br>
and&nbsp; http://www.lahey.com/float.htm<br>
Scott page 264<br>
  </font></i></p>
</blockquote>
 
<ol>
 
</ol>
<blockquote>  D. (Page 117 Harbison &amp; Steele(4th ed))&nbsp; "Prior to
ISO C, all implementations were required to convert all values of type float
to type double before operations were performed.&nbsp; ... In ISO C, operations
can now be performed using type float ."&nbsp; What is the consequences of
this change? ( Consider speed,&nbsp;  accuracy, and the effect of decisions
made in selection of types used by programmer)<br>
  <b>Answer 3D: Without conversion from float to double, the speed of the
processor is able to increase slightly. However, &nbsp;increase in speed,
we actually tradeoff precision of the floating point numbers by representing
numbers in float rather than double. In addition, programmer now has one additional
responsiblity when the program encounters floating point calculation. Programmers
need to consider if the program can tradeoff accuray for speed.   </b><br>
</blockquote>
 <br>
 
<ol>
   <li value="4">Convert this code(in question 3) to Java.&nbsp; (This code
can just be static methods.)  &nbsp;</li>
 
</ol>
 
<ol>
  
  <p>Execute this code and compare results you obtained in problem 3?&nbsp;
 If the results are the same--Do you always expect the results <br>
always to be the same -- explain. If the results are different explain why.
  <br>
  </p>
  
  <p><b>Java output<br>
Part 1A --increasing i's-- sum = 1.6396378763020039<br>
Part 1A --decreasing i's-- sum = 1.6396378763020039<br>
  <br>
Part 1B--increasing i's -- sum = 8.51744326352513<br>
Part 1B -- decreasing i's -- sum = 8.51744326352513<br>
  <br>
Part 2 -- f is 0.1 sum is 1.0000001<br>
false<br>
  </b></p>
  
  <p><b>The results differ because how Java and C represent the floating point
numbers. In C, numbers are expressed in fixed amount of decimal points plus
exponent, whereas in Java floating point numbers are represented in fixed
decimal points. This results are likely to differ due to truncation/rounding
errors.</b> <br>
  </p>
  
  <p>B. What does the keyword strictfp in mean? <br>
   <b>Answer 4B: The keyword "strictfp" is used to control certain aspects
of floating-point arithmetic, to make all float or double expressions within
 the class declaration be explicitly FP-strict. "Within an FP-strict expression,
 all intermediate values must be elements of the float value set or the double
value set, implying that the results of all FP-strict expressions must be
those predicted by IEEE 754 arithmetic on operands represented using single
and double formats. Within an expression that is not FP-strict, some leeway
is granted for an implementation to use an extended exponent range to represent
intermediate results; the net effect, roughly speaking, is that a calculation
might produce "the correct answer" in situations where exclusive use of the
float value set or double value set might result in overflow or underflow."</b>
   <br>
   <b>"strictfp is important because its use guarantees common behavior across
different Java implementations. In other words, you can know that the floating-point
arithmetic in your application behaves the same when you move your application
to a different Java implementation or hardware platform. "</b> <br>
   <i><font color="#3333ff">(source: Java Language Specification</font></i>
   <br>
   <i><font color="#3333ff">and&nbsp;&nbsp;&nbsp; http://developer.java.sun.com/developer/TechTips/txtarchive/Apr01_GlenM.txt</font></i>
   <br>
   <i><font color="#3333ff">and&nbsp;&nbsp;&nbsp; http://developer.java.sun.com/developer/JDCTechTips/2001/tt0410.html)</font></i>
   </p>
      
  <p>C. Compile and run the code with the keyword strictfp . Compare these
results  with the results in part 4a (Java only).&nbsp; Explain your results.<br>
  <b>Answer 4C: The results are the same, there are two possible explanations.<br>
a) The default mode for floating point calculations in Java on Solaris is
in strict mode <br>
  </b><i><font color="#3333ff">(Source: Julia Dudascik, and http://www7b.boulder.ibm.com/vajdoc/vahwebx.exe/en_US/vj32/Extract/0/ide/ref/rikstric.htm)</font></i><b><br>
b) Possibly no overflow/underflow occured in the computation. <br>
  </b></p>
    
</ol>
 &nbsp;&nbsp;&nbsp; &nbsp;5. What is the purpose of the make utility used
during software development in gcc (see man &nbsp;&nbsp;&nbsp; pages)?&nbsp;
What is the Makefile?<br>
 
<blockquote><b>Answer 5: The make utility is a software engineering tool for
managing and maintaining computer &nbsp;&nbsp;&nbsp; programs. As the number
of files in the program increases so does the compile time and complexity
of the compilation comand, therefore likelihood of human errors increase.
Theefore, by creating a descriptor file containing dependency rules, macros,
and suffix rules, you can instruct make to automatically build your program
whenever one of the program's component files is modified. make utility is
smart enough to recompile files that were affected by the changes thus reduce
compilation time and reduce human errors. </b><br>
</blockquote>
<blockquote><b> Make goes through a descriptor file starting with the target
it is going to create. Make looks at each of the target's dependencies to
see if they are also listed as targets. It follows the chain of dependencies
until it reaches the end of the chain and then begins backing out executing
the commands found in each target's rule. Actually every file in the chain
may not need to be compiled. Make looks at the time stamp for each file in
the chain and compiles from the point that is required to bring every file
in the chain up to date. If any file is missing it is updated if possible.
Make builds object files from the source files and then links the object files
to create the executable. If a source file is changed only its object file</b>
  <b>needs to be compiled and then linked into the executable instead of
recompiling all the source files. </b><br>
</blockquote>
<blockquote><font color="#3333ff"><i>Source: http://www.mtsu.edu/~csdept/UNIX_HELP/make.html</i></font><br>
  <b> </b></blockquote>
<br>
 &nbsp;&nbsp;&nbsp; 6. What is a homoiconic language? Explain why Prolog is
homoiconic.&nbsp; Can you name any other &nbsp;&nbsp;&nbsp; homoiconic language?
   
<ol>
   <b>Answer 6: &nbsp;Homoiconic are self representing languages. Homoiconic
language, programs and data have the same representation.  Prolog's facts
and predicates are represented in same format. Further, its  facts and rules
may be added and subtracted on the fly. <br>
 Other homoiconic language: Lisp, Tcl, and Snobol.<br>
Scott page 600, pag3 637<br>
  </b>
</ol>
<br>
</body>
</html>
