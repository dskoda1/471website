<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
               
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
               
  <meta name="Author" content="E Head">
               
  <meta name="GENERATOR"
 content="Mozilla/4.7 [en] (WinNT; U) [Netscape]">
               
  <meta name="KeyWords" content="Prolog assignments">
  <title>Homework assignment 4 Prolog Fall 2002</title>
</head>
  <body text="#000000" bgcolor="#fffff4" link="#ff0000" vlink="#800080"
 alink="#0000ff">
   <a href="http://bingweb.binghamton.edu/%7Ehead/CS471/471hwIndex.html">Back</a> 
 <br>
   Due Sat. Sept 28 ,2002 10:30 AM<br>
   <a
 href="http://bingweb.binghamton.edu/%7Ehead/CS471/requirements.html">General 
 Submission Instructions,</a><br>
   For this assignment put all the code in one file called   
<blockquote><font color="#000099">&lt;lastName&gt;&lt;firstName&gt;4.pl</font><font
 color="#000000">.</font> </blockquote>
     
<h3> </h3>
 
<h3>&nbsp;(Code outline file)<a href="XXXAs4.pl"> &nbsp;XXXAs4.pl</a><br>
  </h3>
   <b>Reading</b>                                
<ul>
     <li> Read: 625-641</li>
     <li>Read: 401-403, 384 -386</li>
     
</ul>
     
<h3><b>Practice : Do not turn in.</b></h3>
           <li> <b>What is the difference between the use of <font
 color="#cc0000">      "</font> and<i> </i><font color="#990000">'</font><i> 
 .</i></b></li>
                                               
<blockquote><b>?- X = "ABD".</b> <br>
             <b>?- X = 'ABD'.</b></blockquote>
           <li> <b>What is happening?&nbsp;</b></li>
             
<blockquote><b>?- X = "c"</b>.<br>
    <b>?- X =&nbsp; c.<br>
  ?- X = "c", [Y</b>]<b> =X, Z=X.</b></blockquote>
  <b></b>        <li>     <b> What does name do? Try</b></li>
                                                             
<blockquote><b>?-name(What, "abc").</b> <br>
               <b>?- name(What, "abc 123").</b> <br>
               <b>?- name(abc, What).</b></blockquote>
           <li> <b>What does write do?&nbsp; Try</b></li>
                                                                        
  
<blockquote><b>?-write("abc123") , write('abc') ,write(abc).</b></blockquote>
   <br>
     
<h2><b>Written</b></h2>
     
<ol>
     <li><b>What is the definition of a binary tree?</b></li>
     <li><b>What is the definition of a binary search tree?</b></li>
     <li><b>What is the difference between a heap data structure and a binary 
 search tree?</b></li>
     
</ol>
     
<h2><b>Programming</b></h2>
   The purpose of this assignment is to re-enforce your understanding of
recursive  data structures, &nbsp;the power of pattern matching and recursion.
  
<ol>
     <li>(easy) Ackermann's function is a simple but very interesting  non-trivially 
   recursive function.&nbsp; It is surprising that for such a simple definition 
   ack(4,4) can NOT be computed within a resonable time .<br>
&nbsp;
    <ol>
      <table>
             <caption>                     
        <h3>Definition of Ackermann's function</h3>
             </caption>    <tbody>
       <tr>
             <td>ack( <i>m,n</i> ) =</td>
        <td>2<i>n</i></td>
        <td>&nbsp;&nbsp;&nbsp; if <i>m</i> = 0</td>
       </tr>
        <tr>
       <td>ack( <i>m,n</i> ) =&nbsp;</td>
        <td>0</td>
        <td>&nbsp;&nbsp;&nbsp; if <i>m</i> &gt;=1 and <i>n</i> = 0&nbsp;</td>
       </tr>
        <tr>
       <td>ack( <i>m,n</i> ) =</td>
        <td>2</td>
        <td>&nbsp;&nbsp;&nbsp; if <i>m</i> &gt;=1 and <i>n</i> = 1&nbsp;</td>
       </tr>
        <tr>
       <td>ack( <i>m,n</i> ) =</td>
        <td>ack( <i>m</i>-1, ack( <i>m, n</i>-1 ) )</td>
        <td>&nbsp;&nbsp;&nbsp; if <i>m</i> &gt;=1 and <i>n</i> &gt;=2&nbsp;</td>
       </tr>
                                                                        
        </tbody>                                                  
      </table>
    </ol>
    <p><br>
In the early days of imperative languages, recursion was  not   very  fashionable
and implementions put restrictions on what depth of  recursion    was achievable.&nbsp;
The Ackermann function was used to measure  the recursion    capability of
a compiler by defining the Ackermann Number  N of the compiler    as the
largest N for which<br>
       </p>
                 
    <blockquote>                     
      <ol>
           <tt>ack(3,N)</tt>                     
      </ol>
       </blockquote>
          gives an answer without a stack overflow.&nbsp;       Turn in the 
 code and the answers written as comments in the program.</li>
           
  <ol>
       <li type="A">What value does your program calculate for&nbsp; <tt>ack(2,4)?</tt> 
       &nbsp; Does it match the result expected proved in HW1?&nbsp;</li>
       <li type="A">Program Ackermann's function in Prolog and find the Ackermann 
  Number   N of your Swipl environment.<br>
         <br>
       </li>
           
  </ol>
     <li>Write a procedure, countChar( String, Char, Count) which counts
the  number of time Char occurs in the String and unifies the value with
Count.&nbsp;  (Easy)&nbsp; (Extra credit for avoiding addition wrong answers
generated  after typing ";").</li>
           
  <ol>
       <tt>?- countChar("The early bird ate the worm", "e", Count).</tt><br>
       <tt>Count = 4;</tt><br>
       <tt>No</tt>         
  </ol>
     <li>Write a procedure, countOcc(String, CharList,CountList), which counts 
 the number of times each Char occurs in the String and put the value in the
 corresponding position in CountList. &nbsp;You may use the results from problem
2.</li>
           
  <ol>
       <tt>?- countOcc("The early bird ate the worm", "aekt", Count).</tt><br>
       <tt>Count = [2,4,0,2];</tt><br>
       <tt>No<br>
       <br>
       </tt>         
  </ol>
     <li>A list is a<b> <i>palindrome</i></b> if it reads the same in  the
  forward direction and the backward direction. &nbsp; [m,a,d,a,m] and  [2,0,0,2]
  and [g,o,h,a,n,g,a,s,a,l,a,m,i,i,m,a,l,a,s,a,g,n,a,h,o,g] are palindrome. 
 One way to implement the predicate is to use reverse: <br>
        &nbsp; <b>palindrome (List) :- reverse(List, List).<br>
                      </b>You are to supply an alternate solution using the
 built   in predicate <b>append.<br>
       <br>
       </b></li>
     <li>accumProd(+Lst, RLst): &nbsp;Given a list, Lst <i>accumProd</i>
creates/checks  that RLst is a list of the running product of all the numbers
of &nbsp;Lst  from right to left. &nbsp;<br>
  i.e.</li>
       
  <dl>
    <dd><b>?- accumProd([3,2,5,2],R).<br>
  R = [60, 20, 10, 2]</b></dd>
    <dd><b>?- accumProd([3,4,5,6,0.5],R).<br>
  R = [180, 60, 15, 3, 0.5]</b> </dd>
    <dd><br>
      </dd>
    <dd><br>
      </dd>
  </dl>
    <dd><br>
    </dd>
     <li>(very easy)<b>lastElement(Lst,LElement)</b>, is a predicate that 
unifies the LElement with the last Element of Lst. &nbsp;It should fail if 
the list is empty.<br>
     <br>
   </li>
   <li><a
 href="http://bingweb.binghamton.edu/%7Ehead/CS471/CODE/PL/tree.pl">Attached 
 is partial binary search trees code.</a>.</li>
           
  <ol type="a">
       <li>Write a procedure <b><tt>isBinaryTree(Tree),</tt></b>that succeeds 
 if Tree is a binary tree (it is not necessary for Tree to be a binary search 
 tree).</li>
                 
    <ol type="a">
         <b><tt>?- isBinaryTree(empty).</tt></b><br>
         <b><tt>yes</tt></b><br>
         <b><tt>?-isBinaryTree(node(5,empty,empty)).</tt></b><br>
         <b><tt>yes</tt></b><br>
         <b><tt>?-notBST(T),isBinaryTree(T).</tt></b><br>
         <b><tt>yes</tt></b><br>
         <b><tt>?- isBinaryTree(node(5)).</tt></b><br>
         <b><tt>no</tt></b>               
    </ol>
       <li>Write a procedure sumTree(+intBinaryT, ?Sum) that given a binary 
 tree of intergers, <i>&nbsp;intBinaryT</i> , &nbsp;Sum unifies with the computed
 sum of all the nodes. <br>
       </li>
       <li>Write a procedure <b><tt>isBST(Tree),</tt></b>that succeeds if 
Tree  is a binary search tree.</li>
                 
    <ol type="a">
         <b><tt>?- isBST(empty).</tt></b><br>
         <b><tt>yes.</tt></b><br>
         <b><tt>?-isBST(node(5,empty,empty)).</tt></b><br>
         <b><tt>yes.</tt></b><br>
         <b><tt>?-notBST(T),isBST(T).</tt></b><br>
         <b><tt>no.<br>
       <br>
       </tt></b>              
    </ol>
             
  </ol>
   
</ol>
     
<ol start="2">
           
  <p><br>
   &nbsp;</p>
     
</ol>
     
<h5><a href="mailto:head@binghamton.edu">Questions?(For E. Head</a></h5>
9/23/02 9am<br>
   <br>
  <br>
 <br>
</body>
</html>
