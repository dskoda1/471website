<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="Author" content="Eileen Head">
  <meta name="GENERATOR"
 content="Mozilla/4.78 [en] (Windows NT 5.0; U) [Netscape]">
  <title>Homework 5 Last Prolog Assignment Spring 2003</title>
</head>
<body alink="#000099" vlink="#009900" link="#000099"
 style="color: rgb(0, 0, 0); background-color: rgb(253, 253, 253);">
<font size="-2">&nbsp; </font><a
 href="http://bingweb.binghamton.edu/%7Ehead/CS471/471hwIndex.html">Back<font
 color="#cc0000">&nbsp; 10/1/03&nbsp; Due: Oct 10,2003</font></a>
<h3 align="center">Assignment 5</h3>
<h4><a
 href="http://bingweb.binghamton.edu/%7Ehead/CS471/requirements.html">General
Submission Instructions</a></h4>
You hardcopy should begin with the following identification:
<ul>
  <blockquote><font color="#000000">CS471 - Programming Languages</font><br>
    <font color="#000000">Section: </font><font color="#cc0000">&lt;YOUR
Section number&gt;</font><br>
    <font color="#000000">Assignment #</font><font color="#cc0000">&lt;number&gt;</font><font
 color="#000000">due:</font><font color="#cc0000">&lt;DATE&gt;</font> <br>
    <font color="#000000">Author:</font><font color="#cc0000">
&lt;LastName&gt;, &lt;FirstName&gt; </font><font color="#000000">(</font><font
 color="#cc0000">&lt;EMail&gt;</font><font color="#000000">)</font><br>
    <font color="#000000">Date:</font><font color="#cc0000">
&lt;DATE&gt;</font></blockquote>
</ul>
<h3><b>Written Assignment:</b></h3>
<b>Purpose: To understand how order imposed by the implementation of
Prolog causes problems.To understand the beauty of pattern
matching.&nbsp;</b>
<ol>
  <li>Below are 4 versions of subList(SubList, List) discussed in class.<br>
    <br>
subList1(S,L):-append(P,T,L),append(H,S,P).<br>
subList2(S,L):-append(H,S,P),append(P,T,L). <br>
subList3(S,L):-append(S,ST,T),append(H,T,L).<br>
subList4(S,L):-append(H,T,L),append(S,ST,T).</li>
  <ol>
    <li>Run each version above with the following input, S = [2,3], L =
[1,2,3,4]</li>
    <li>Run each version above with the following input, S = [a,b], L =
[1,2,3,4]</li>
    <li>One version runs out of stack-- &nbsp;Explain why this error
occurs.<br>
      <br>
    </li>
  </ol>
  <li>Consider the following program:</li>
</ol>
<ol type="A">
  <ol type="A">
    <tt>fill(X,N,L) :- length(L,N), append([X],Lx,L), append(Lx,[X],L).</tt>
    <br>
&nbsp;<li><tt>(Do not turn in).</tt>If the input <i>X</i> is a term
and input <i>N</i> is a positive integer, then what will the output <i>L</i>?
Try the following.. also find other possible solutions with ";"</li>
    <ol type="a">
      <li><tt>?-</tt>&nbsp; <tt>fill(xyz, 5, L).</tt></li>
      <li><tt>?- fill(xyz, 5, [H|T].</tt></li>
    </ol>
    <li><tt>Try to briefly explain how it works.</tt></li>
    <li>Does the below code give the same results as <i>fill</i>?</li>
    <ol type="A">
      <tt>fillr(X,0,[]):-!.</tt><br>
      <tt>fillr(X,N,[X|T]) :- Nx is N-1,fillr(X,Nx,T).</tt>
    </ol>
    <li>Compare the execution time of the two version for various
values of <i>N .&nbsp; </i>(Use "trace" or write your own append (use
myAppend) and length(use myLen) so you can see trace to see the
execution steps. )</li>
  </ol>
</ol>
<h3><b>Programming Assignment:</b></h3>
<b>Purpose:</b><li><b>The purpose is this assignment is</b></li>
<br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1) reenforce recursive
programming</b> <br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2) reenforce the use of the
list data structure in Prolog</b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3) use of pattern recognition
in programming</b><br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4) use of backtracking to solve
problems.</b> <br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5) learn how to dynamically
change prolog code</b>
<ol>
You may find this <a
 href="http://www.cs.otago.ac.nz/cosc347/References/LP/LeedsTutorial/">tutorial</a>
or&nbsp; <a href="http://www.amzi.com/AdventureInProlog/advfrtop.htm">another
tutorial</a> helpful.&nbsp; You will find the following builtin
predicates helpful trace, help(predicate), and listing.&nbsp;&nbsp; <a
 href="http://www.swi.psy.uva.nl/projects/SWI-Prolog/Manual/DocIndex.html">Online
documentation</a> .
  <p><b>Files with hints and format : For most of the problems</b> <a
 href="XXXAs5.pl">XXXAs5.pl.</a>&nbsp; </p>
  <ol type="A">
  </ol>
&nbsp;<li><font color="#000000">(easy- ONE relation)Define a predicate
append3DL&nbsp; that concatenates three difference lists:</font></li>
  <br>
  <font color="#000000">&nbsp;&nbsp;&nbsp; <tt>?- append3DL( [z,y|A] -
A, [x,w | B] -B, [u,v | C] - C, What).</tt></font><br>
  <tt><font color="#000000">&nbsp; What = [z, y, x, w, u, v | _n] - _n</font></tt>
  <br>
  <tt><font color="#000000">&nbsp; yes</font></tt><br>
&nbsp;<br>
  <li>Using the main idea used in proving the cardinality of the
powerset of a set of cardinality of <span style="font-style: italic;">n</span>
is 2^<span style="font-style: italic;">n, </span>write a prolog
program
to build the powerset of set. (Remember if a list has more than 8
elements prolog only prints out 8). &nbsp;You may use a "helper"
predicate and <span style="font-style: italic;">append</span>.<br>
  </li>
  <dd><br>
  </dd>
  <dl>
?- powerset([a,b],P).<br>
&nbsp;P = [[a, b], [b], [a], []] ;<br>
&nbsp;No<br>
?- powerset([a,b,c],P).<br>
&nbsp;P = [[a, b, c], [b, c], [a, c], [c], [a, b], [b], [a], []]<br>
&nbsp;Yes<br>
?- powerset([a,b,c,d],P).<br>
&nbsp;P = [[a, b, c, d], [b, c, d], [a, c, d], [c, d], [a, b, d], [b,
d], [a, d], [d], [...|...]|...]<br>
Yes<br>
(if you type "w" when the list prints&nbsp;then Prolog will print out
the entire list.)<br>
?- powerset([1,2,3,4],P).<br>
&nbsp;<br>
P = [[1, 2, 3, 4], [2, 3, 4], [1, 3, 4], [3, 4], [1, 2, 4], [2, 4], [1,
4], [4], [...|...]|...] [write]<br>
P = [[1, 2, 3, 4], [2, 3, 4], [1, 3, 4], [3, 4], [1, 2, 4], [2, 4], [1,
4], [4], [1, 2, 3], [2, 3], [1, 3], [3], [1, 2], [2], [1], []]<br>
    <br>
    <br>
    <br>
  </dl>
  <li><span style="font-family: monospace; font-weight: bold;">countList(+NestedLst,
-NumOfLists), </span>given a list of nested lists,
NestedLst, count all the lists. &nbsp;This is a hard problem
to see how to do but you need only 2 base cases and 1 recursive rule.</li>
? countLists([[[a],[]],[b,c,[d],e,f,[abc],e],[1,2,3]], S).<br>
S = 8<br>
?- countLists([[[a]]], S).<br>
S = 3<br>
?- countLists([[[a],[a,[[d],e]]]], S).<br>
S = 6<br>
  <br>
  <li>Knapsack problem See <a href="knapsackItems.pl">knapsackItems.pl</a>
for
description of problem.&nbsp; (I will have a zerox of the problem by my
office.)<br>
  </li>
  <dl>
    <dd>Possible output--&nbsp; Given the 4 items listed in the file
can a sack of&nbsp; weight&nbsp; W or less have a profit of $90.<br>
meaning for functors:&nbsp; sack(Weight, Profit), item(Number, Profit,
Weight, Profit/Weight). S is the list of items in the sack. (Don't
worry if you get duplicate answers.)<br>
      <br>
&nbsp;?- knapSack01(sack(18,90),S).<br>
&nbsp;S = [item(1, 40, 2, 20), item(3, 50, 10, 5)]<br>
&nbsp;Yes<br>
?- knapSack01(sack(12,90),S).<br>
&nbsp;S = [item(1, 40, 2, 20), item(3, 50, 10, 5)]<br>
yes<br>
?- knapSack01(sack(10,90),S).<br>
No<br>
?- knapSack01(sack(20,80),S).<br>
S = [item(1, 40, 2, 20), item(2, 30, 5, 6), item(4, 10, 5, 2)] ;<br>
S = [item(2, 30, 5, 6), item(3, 50, 10, 5)]<br>
Yes<br>
      <br>
      <br>
    </dd>
  </dl>
  <dl>
    <dd><br>
    </dd>
  </dl>
  <li>Write a prolog program that adds final states and delta rules
dynamically to you program. For example addStart(State), in XXXAs5.pl
lets the user define the state state of a FSM.(See problem 7 for
example
to test your program.) &nbsp;At the top of the file I put in 3 "dummy"
facts. start(empty), final(empty), and delta(empty,empty,empty), for
this to work .For example to add delta rules you would type.<br>
?- addDelta(q1,1,q2).<br>
?- addStart(q0).<br>
?- addFinal(q0).</li>
  <dl>
    <dd><br>
    </dd>
  </dl>
  <li>Define deltaHat(..) and accept(Lst). &nbsp;so that for any FSM
defined by the user at runtime (See problem 7), accept(Lst) &nbsp;where
Lst represented a sentence in the language if it is accepted by the FSM.<br>
  </li>
  <ol>
    <dl>
Use the following definition to build deltaHat(Q1,Str). &nbsp;<br>
The definition of deltaHat is::<br>
&nbsp;&nbsp;<b>deltaHat(Q,[]) = Q</b>&nbsp;(Our program will represent
the empty string as the empty list).&nbsp;&nbsp;<br>
&nbsp;&nbsp;<b>deltaHat(Q, [C|Cs]) = deltaHat(delta(Q,C),Cs) </b><br>
The following Finite State machine accepts all odd parity "strings".
Write a prolog program that accept all valid strings in the language.
We
will represent the strings as a list of atoms.<br>
Sigma = { 0,1 }, Start state = {q0}, &nbsp;Final state = { q2,q3 },<br>
&nbsp;&nbsp;delta(q0,0) = q1<br>
&nbsp;&nbsp;delta(q0,1) = q3<br>
&nbsp;&nbsp;delta(q1,0) = q0<br>
&nbsp;&nbsp;delta(q1,1) = q2<br>
&nbsp;&nbsp;delta(q2,0) = q3<br>
&nbsp;&nbsp;delta(q2,1) = q1<br>
&nbsp;&nbsp;delta(q3,0) = q2<br>
&nbsp;&nbsp;delta(q3,1) = q0.<br>
      <br>
A string is accepted if deltaHat(q0, String) is in a final state (q2 or
q3).&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;?- accept([0,0,0,0,1,1,1,1,0,1]).&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Yes&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;?- accept([0,0,0,0,1,1,1,1]).&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;No <br>
&nbsp;&nbsp;?- accept([1,1,0,0,1,0,1,1,1,1,0,1,1]).<br>
&nbsp;&nbsp;Yes&nbsp;
    </dl>
  </ol>
</ol>
<ol start="7">
  <li>Write a declarative program in prolog to (these will be only one
line of code each):</li>
  <ol style="list-style-type: upper-alpha;">
    <li>"say what a square<span style="color: rgb(255, 0, 0);">Roo</span>t
is"</li>
    <li>Use ordered from homework 4 and permutation from the notes to
define what it means for a list to be sorted.<br>
      <br>
    </li>
  </ol>
  <li>Below is problem 8 from homework 1:</li>
  <dl>
    <dd><br>
    </dd>
A common way to compute the square root is to use Newton's
method of successive approximations. &nbsp;Newton's
method says that whenever
we have a guess y for the value of the square root of a
number x, we can perform a simple manipulation to get a
better guess (one closer to the actual square root) by averaging y
with x/y.&nbsp;For
example, we can compute the square root of 2 as follows. Suppose our
initial guess is 1:
  </dl>
</ol>
<table border="0" cellpadding="2" style="margin-left: 80px;">
  <tbody>
    <tr>
      <td><big>Guess</big></td>
      <td><big> Quotient</big></td>
      <td><big>&nbsp; &nbsp; &nbsp; Average</big></td>
    </tr>
  </tbody>
</table>
<div style="margin-left: 40px;"> <br>
<div style="margin-left: 40px;"><a
 href="http://www-mitpress.mit.edu/sicp/chapter1/node9.html"><img
 src="http://www-mitpress.mit.edu/sicp/chapter1/line2.gif" title=""
 alt="Process" width="276" height="111" border="0"></a><br>
</div>
</div>
<div style="margin-left: 40px;">Continuing this process, we obtain
better and better
approximations to
the square root. (From <a
 href="http://www-mitpress.mit.edu/sicp/chapter1/node9.html"><span
 style="font-style: italic;">Structure and
Interpretation of Computer Programs</span> by Abelson and Sussman</a>).<br>
<br>
Program this algorithm in prolog.&nbsp; We will determine a guess is
"closeEnough" if the absolute value of x - guess*guess is less than
0.0001.<br>
</div>
<ol start="9">
  <dl>
    <dd><br>
    </dd>
  </dl>
  <li>Write a predicate <b>show(ExpTree)</b> that makes a pretty print
of an expression tree. (See show(Tree) in&nbsp;<a href="tree.pl">tree.pl</a>
).<br>
(See <a href="http://bingweb.binghamton.edu/%7Ehead/CS471/HW/XXXAs5.pl">XXXAs5.pl</a>
for definition of tree1, tree4)<br>
i.e.<br>
?- tree1(T),show(T).<br>
Tree =<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; 2<br>
&nbsp;&nbsp; *<br>
&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; 3<br>
+<br>
&nbsp;&nbsp; &nbsp; 5<br>
&nbsp;<br>
T = exp(+, exp(const, 5), exp(*, exp(const, 3), exp(const, 2)))<br>
?- tree4(T),show(T).<br>
Tree =<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;
2<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; /<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;
pi<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sin<br>
float<br>
&nbsp;<br>
T = exp(float, exp(sin, exp(/, exp(const, pi), exp(const, 2))))<br>
    <br>
    <br>
  </li>
  <li> Write a predicate <b>eval(ExpTree, Value)</b> that evaluates an
expression tree. i.e. <br>
  </li>
?- tree4(T),eval(T,V).<br>
&nbsp;<br>
T = exp(float, exp(sin, exp(/, exp(const, pi), exp(const, 2))))<br>
V = 1.0<br>
yes<br>
  <br>
?- tree1(T),eval(T,V).<br>
T = exp(+, exp(const, 5), exp(*, exp(const, 3), exp(const, 2)))<br>
V = 11<br>
&nbsp;
</ol>
<font color="#3333ff">Remember Programming is an individual task... :</font>
<p><font color="#3333ff">Resources use:</font></p>
<p><a href="mailto:head@binghamton.edu">Questions?(For E. Head)</a><br>
&nbsp;</p>
<br>
<br>
<br>
<br>
<br>
</body>
</html>
