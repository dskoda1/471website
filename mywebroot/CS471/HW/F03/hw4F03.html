<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="Author" content="E Head">
  <meta name="GENERATOR"
 content="Mozilla/4.73 [en] (Win98; U) [Netscape]">
  <meta name="Description" content="Introduction">
  <title>4 - Prolog Programming</title>
</head>
<body text="#000000" bgcolor="#fffdff" link="#ff0000" vlink="#990000"
 alink="#cc0000">
<font size="-2">&nbsp; </font><a
 href="http://bingweb.binghamton.edu/%7Ehead/CS471/471hwIndex.html">
Back</a>
<h4> </h4>
<h4>Given: Sat. Sept 20<br>
Due Mon. Sept 29 at MIDNIGHT.<br>
</h4>
<h4><br>
<a href="http://bingweb.binghamton.edu/%7Ehead/CS471/requirements.html">
General Submission Instructions</a></h4>
You hardcopy should begin with the following identification:
<ul>
  <blockquote><font color="#000000">CS471 - Programming Languages</font>
    <br>
    <font color="#000000">Section: </font><font color="#cc0000">&lt;YOUR
Section number&gt;</font> <br>
    <font color="#000000">Assignment #</font><font color="#cc0000">&lt;number&gt;
    </font><font color="#000000">due:</font><font color="#cc0000">
&lt;DATE&gt;</font> <br>
    <font color="#000000">Author:</font><font color="#cc0000">
&lt;LastName&gt;, &lt;FirstName&gt; </font><font color="#000000">(</font><font
 color="#cc0000"> &lt;EMail&gt;</font><font color="#000000">)</font> <br>
    <font color="#000000">Date:</font><font color="#cc0000">
&lt;DATE&gt;</font></blockquote>
</ul>
<h4> Manditory reading ---</h4>
<li> Reading for Prolog</li>
<ul>
</ul>
<h3> Written assignment:</h3>
<b>Purpose:</b><br>
<ul>
  <li><b>To see you if you can figure out the runtime implementation of
lists for Prolog.</b></li>
</ul>
<ol>
  <li>Briefly explain how lists are implemented at runtime in prolog.</li>
  <li>How would your stategy about implement the following lists (you
may draw a picture of your structure)<br>
  </li>
  <ol>
    <li>[1, [ 2, 3 ]]</li>
    <li>[ 1, [ 2<span style="color: rgb(204, 0, 0);">,</span> [ 3, 4, 5
], 6 ] ]<br>
    </li>
  </ol>
</ol>
<br>
<br>
<h3> <b>Programming Assignment:<br>
Try:</b></h3>
<li> <b>What is the difference between the use of <font
 color="#cc0000"> "</font> and<i> </i><font color="#990000">'</font><i>
.</i></b></li>
<blockquote><b>?- X = "ABD".</b> <br>
  <b>?- X = 'ABD'.</b></blockquote>
<li> <b>What is the difference between</b></li>
<br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/2 and @&lt;/2? (/2
is arity of 2),</b> <br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&lt;/2 and @=&lt;/2 ?</b>
<br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;/2 and @&gt;/2?</b> <li> <b>
What does name do? Try</b></li>
<blockquote><b>?-name(What, "abc").</b> <br>
  <b>?- name(What, "abc 123").</b> <br>
  <b>?- name(abc, What).</b></blockquote>
<li> <b>What does write do?&nbsp; Try</b></li>
<blockquote><b>?-write("abc123") , write('abc') ,write(abc).</b></blockquote>
<b>Purpose:</b> <li> <b>The purpose is this assignment is</b></li>
<br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1) reenforce recursive
programming</b>, <br>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2) reenforce the use of the
list data structure in Prolog</b> <br>
<b></b><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3) difference between <i>
strings</i> and <i>atoms</i></b> <br>
&nbsp;
<ol>
You may find this <a
 href="http://computing.unn.ac.uk/staff/cgpb4/prologbook/">
tutorial</a> or&nbsp; <a
 href="http://www.amzi.com/AdventureInProlog/advfrtop.htm"> another
tutorial</a> helpful.&nbsp; All code from my notes are in <a
 href="http://bingweb.binghamton.edu/%7Ehead/CS471/CODE/PL/example.pl">
example.pl .</a> <br>
Files with hints and format :
</ol>
<blockquote>
  <blockquote><a href="XXXAs4.pl"> XXXAs4.pl</a></blockquote>
</blockquote>
<ol>
</ol>
<ol>
  <li>
    <pre>(Last week's problem) Write a predicate ordered(L) that succeeds if and only if the list of numbers, L is in non-decreasing order --each element is less than or equal to the next.</pre>
  </li>
  <li>
    <pre>(last week's problem) Define a predicate, listOfFacts(Functor,ListOfArgs,ListOfTerms), where each term in the ListOfTerms is a term with one argument from the ListOfTerms and the name is the functor.<br>      Type "help" in swipl<br>         help(functor).<br>         help(=..)<br>         help(arg).<br>      for information on the built-in predicates functor,=.., arg.<br><br>      ?- listOfFacts(foo,[a,b,23,4],T).<br>         T = [foo(a), foo(b), foo(23), foo(4)]<br>	 Yes</pre>
  </li>
  <li>Given a list of predicates, applylist(L) succeeds only if&nbsp;
each of the predicates in the list succeeds. Note: the scope of
variables names is the entire list. You can apply each predicate at the
prompt to see how they work.&nbsp; Make up your own. i.e</li>
  <ol>
    <li><span style="font-family: monospace;">?-
applylist([=(A,5),is(B,+(4,5)),C is max(5,2),A=C]).</span></li>
    <li><span style="font-family: monospace;">A = 5</span></li>
    <li><span style="font-family: monospace;">B = 9</span><span
 style="font-family: monospace;">&nbsp;&nbsp;&nbsp; <br>
      </span></li>
    <li><span style="font-family: monospace;">C = 5</span><span
 style="font-family: monospace;">&nbsp;&nbsp;&nbsp; <br>
      </span></li>
    <li><span style="font-family: monospace;">yes</span></li>
    <li><span style="font-family: monospace;">?-
applylist([=(A,5),is(B,+(4,5)),C is max(9,2),A=C]).</span><span
 style="font-family: monospace;"> &nbsp;&nbsp; <br>
      </span></li>
    <li><span style="font-family: monospace;">no<br>
      <br>
      </span></li>
  </ol>
  <li> Implement a prolog program<tt><br>
&nbsp;<b>deleteE (+E, +Lst1, -Lst2)<br>
    </b></tt>that succeeds if Lst2 has the same sequence of
elements as Lst1 except there are no element E in Lst2.<br>
&nbsp; <br>
&nbsp; <b><tt>&nbsp;?- deleteE(x,[x,a,b,c,x],R).<br>
&nbsp; R = [a, b, c] <br>
&nbsp; Yes<br>
&nbsp; ?- deleteE(3,[1,2,4,5,6],R).<br>
&nbsp; R = [1, 2, 4, 5, 6] <br>
&nbsp; Yes<br>
&nbsp; ?- deleteE(3,[1,2,3,4,3,2,1,1,2,3,4,33],R).<br>
&nbsp; R = [1, 2, 4, 2, 1, 1, 2, 4, 33] <br>
&nbsp; Yes<br>
&nbsp; % my code gives this error.<br>
&nbsp; ?- deleteE(3,R,[1,2,6]).<br>
&nbsp; ERROR: Out of local stack<br>
&nbsp; Exception: (29,513) deleteE(3, _G88567, [1, 2, 6]) ? <br>
    </tt></b><br>
    <br>
  </li>
  <li>Implement <br>
&nbsp; <b><tt>bagToSet(Bag,Set). &nbsp;</tt><br>
    </b>where Set has the same elements as Bag but has not duplicates.
(You may assume that the elements are stored in the same sequence in
both Bag and Set)<br>
    <br>
    <b><tt>&nbsp; &nbsp;?- bagToSet([a,b,c,x,a,y,b,a,z],R).<br>
&nbsp; &nbsp;R = [a, b, c, x, y, z] <br>
&nbsp; &nbsp;Yes<br>
    <br>
&nbsp; &nbsp;?- bagToSet([a,b,c,x,a,y,b,a,z],[a,b,c,x,y,z]).<br>
&nbsp; &nbsp;Yes<br>
    <br>
&nbsp; &nbsp;?- bagToSet([a,b,c,x,a,y,b,a,z],[b,a,c,x,y,z]). &nbsp;%
Fails because of the order of the elements.<br>
&nbsp; &nbsp;No<br>
    </tt></b><br>
    <br>
  </li>
  <li>A list is a <i>palindrome</i> if it reads the same in the
forward direction and the backward direction. &nbsp; [m,a,d,a,m] and
[2,0,0,2] and [g,o,h,a,n,g,a,s,a,l,a,m,i,i,m,a,l,a,s,a,g,n,a,h,o,g] are
palindrome.
One way to implement the predicate is to use reverse: <br>
&nbsp; <b>palindrome (List) :- reverse(List, List).<br>
    </b>You are to supply an alternate solution using the built in
predicate <b>append</b>.</li>
  <dl>
    <dd><br>
    </dd>
  </dl>
  <li>Implement<b><tt> <br>
&nbsp; &nbsp; myMerge(+List1, +List2, -Result)</tt></b><br>
that combines two sorted lists of atoms, List1 and List2 into a sorted
list of atoms, Result.&nbsp; (I used cuts to eliminate wrong alternate
solutions.)<br>
    <br>
    <b>myMerge([ ab,ccd,gg], [ bag, ccz, fix,zoo], R]<br>
R = [ ab, <span style="color: rgb(255, 0, 0);">bag,</span> ccd, ccz,
fix, gg, zoo];<br>
no (</b>if you use cuts ... not required)<br>
    <br>
  </li>
  <li>Implement <b><tt>partition (+List, -List1, -List2)</tt></b> ,
that divides List in two parts, List1, List2 of about equal size.
&nbsp;Each list should have at one element. (partition should work for
any kind of lists).<br>
    <tt><b>?- partition([1,2,3], L1, L2<br>
    </b></tt><b><tt>L1 = [1,3] %% or order or elements do not matter
for correct solution</tt><br>
    <tt>L2 = [2]</tt><br>
    <tt>yes</tt><br>
    <tt>?- partition([1,2,3,4],L1,L2).</tt><br>
    <tt>L1 = [1,3]</tt><br>
    <tt>L2 = [2,4]</tt><br>
    <tt>yes</tt></b><br>
    <br>
  </li>
  <li> Using <b><tt>myMerge</tt></b> and<b><tt> partition </tt></b>
implement<b><tt> mergesort<font color="#000000">X</font>(+UnsortedList,
-SortedList),</tt></b> which will sort a list of atoms.<br>
    <br>
    <br>
  </li>
  <li> 4 Colors Map Coloring Problem:<br>
On a geographic map, let us define two countries as neighbors, if they
share a piece of border.&nbsp; Two countries are not neightbors, if
they join in a common point only or if they do not join at all.&nbsp;
Your problem is to write a logical prolog program that given a map with
countries A,
B, ...G (figure below), the program will allocate one of four colors to
each country, so that no adjacent counties will have the same country.<br>
First use atoms for each color you want to use.&nbsp; i.e. red, blue,
green, pink, black. <br>
You can either enumerate all permutation of colors neighbors can have.
That will be 12 facts. <br>
OR you can enumerate all combination of colors that can be
adjacent.&nbsp; That will be 6 facts and then include 2 neighbor rules
that defines the remaining possible permutations of color pairs.<br>
Now you are ready to define the one rule, <tt>mapcolor(A,B,C,D,E,F)</tt>
,&nbsp; to find the possible color combinations for the map
below.&nbsp; (Writing the Prolog for this is much easier than
describing the problem.) &nbsp;Note: the country names will be unified
with a color: i.e A = blue, B=red..etc<br>
    <br>
    <a href="mapS02.jpeg"></a><a href="mapF03.jpeg"><img
 src="mapF03.jpeg" alt="Map coloring."
 style="border: 0px solid ; width: 250px; height: 201px;" title=""
 width="250" height="201" border="0"></a> <br>
Possible examples of output include:<br>
    <tt>&nbsp; &nbsp;?- mapcolor(A,B,C,D,E,F).<br>
    <br>
&nbsp; &nbsp;A = red<br>
&nbsp; &nbsp;B = blue<br>
&nbsp; &nbsp;C = pink<br>
&nbsp; &nbsp;D = black<br>
&nbsp; &nbsp;E = pink<br>
&nbsp; &nbsp;F = red ;<br>
    <br>
&nbsp; &nbsp;A = red<br>
&nbsp; &nbsp;B = blue<br>
&nbsp; &nbsp;C = pink<br>
&nbsp; &nbsp;D = black<br>
&nbsp; &nbsp;E = pink<br>
&nbsp; &nbsp;F = blue <br>
    <br>
&nbsp; &nbsp;Yes</tt><br>
    <br>
  </li>
  <li>&nbsp;Write the code for sumRtoL(+L,S), such that given a list of
numbers, L, S is a list of the sum of the numbers in L where&nbsp; that
first number in S is the sum of all the number L, the second
number&nbsp; in S the sum of all the numbers in L except the first
number in
L, etc.&nbsp;&nbsp; i.e:</li>
  <dl>
    <dd><tt><br>
3 ?- sumRtoL([1,2,3,4],S).&nbsp; <br>
S = [10, 9, 7, 4]<br>
      <br>
      </tt></dd>
  </dl>
  <dd><br>
  </dd>
  <dl>
    <dd><tt><br>
      </tt></dd>
  </dl>
  <li>&nbsp;sumLtoR(+L,?S)&nbsp; is simular to sumRtoL(+L,?S), except
that sum totals accumulate left to right.<br>
    <br>
&nbsp;&nbsp;&nbsp;<tt>&nbsp; 13 ?- sumLtoR([1,2,3,4],S).<br>
&nbsp;&nbsp; S = [1, 3, 6, 10] <br>
    </tt><br>
  </li>
  <li>Ackermann's function is a simple but very interesting
non-trivially recursive function.&nbsp; It is surprising that for such
a
simple definition ack(4,4) can NOT be computed within a resonable time
.&nbsp; <br>
  </li>
</ol>
<table style="margin-left: 40px;">
  <tbody>
    <tr>
      <td>ack( <i>m,n</i> ) =</td>
      <td>2<i>n</i></td>
      <td>&nbsp;&nbsp;&nbsp; if <i>m</i> = 0</td>
    </tr>
    <tr>
      <td>ack( <i>m,n</i> ) =&nbsp;</td>
      <td>0</td>
      <td>&nbsp;&nbsp;&nbsp; if <i>m</i> &gt;=1 and <i>n</i> =
0&nbsp;</td>
    </tr>
    <tr>
      <td>ack( <i>m,n</i> ) =</td>
      <td>2</td>
      <td>&nbsp;&nbsp;&nbsp; if <i>m</i> &gt;=1 and <i>n</i> =
1&nbsp;</td>
    </tr>
    <tr>
      <td>ack( <i>m,n</i> ) =</td>
      <td>ack( <i>m</i>-1, ack( <i>m, n</i>-1 ) )</td>
      <td>&nbsp;&nbsp;&nbsp; if <i>m</i> &gt;=1 and <i>n</i>
&gt;=2</td>
    </tr>
  </tbody>
</table>
<ol>
  <ol>
  </ol>
  <p>In the early days of imperative languages, recursion was not very
fashionable and implementions put restrictions on what depth of
recursion was achievable.&nbsp; The Ackermann function was used to
measure the recursion capability of a compiler by defining the
Ackermann Number N of the compiler as the largest N for which </p>
  <ol>
    <tt>ack(3,N)</tt>
  </ol>
gives an answer without a stack overflow. <br>
Turn in the code and the answers written as comments in the program.
  <ol type="A">
    <li> What value does your program calculate for&nbsp; <tt>ack(2,4)?</tt>
&nbsp; <br>
    </li>
    <li> Program Ackermann's function in Prolog and find the Ackermann
Number N of your Swipl environment.</li>
  </ol>
</ol>
<br>
<br>
<font color="#3333ff"><br>
<br>
Remember Programming is an individual task... :</font>
<p><font color="#3333ff">Resources use:</font> </p>
<p><a href="mailto:head@binghamton.edu">Questions?(For E. Head)</a> </p>
</body>
</html>
