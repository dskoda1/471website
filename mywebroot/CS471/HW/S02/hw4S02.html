<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
                            
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
                            
  <meta name="Author" content="E Head">
                            
  <meta name="GENERATOR" content="Mozilla/4.73 [en] (Win98; U) [Netscape]">
                            
  <meta name="Description" content="Introduction">
  <title>4 - Prolog Programming</title>
</head>
  <body text="#000000" bgcolor="#fffdff" link="#ff0000" vlink="#990000" alink="#cc0000">
       <font size="-2">&nbsp; </font><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/471hwIndex.html">
      Back</a>       
<h4> </h4>
     
<h4>Given:Friday Feb 15, <br>
   Due Friday, &nbsp;Feb 22</h4>
           
<h4><br>
       <a href="http://bingweb.binghamton.edu/%7Ehead/CS471/requirements.html">
      General Submission Instructions</a></h4>
       You hardcopy should begin with the following identification:     
 
<ul>
                         
  <blockquote><font color="#000000">CS471 - Programming Languages</font> 
   <br>
          <font color="#000000">Section: </font><font color="#cc0000">&lt;YOUR 
  Section number&gt;</font> <br>
          <font color="#000000">Assignment #</font><font color="#cc0000">
&lt;number&gt;        </font><font color="#000000">due:</font><font color="#cc0000">
 &lt;DATE&gt;</font>       <br>
          <font color="#000000">Author:</font><font color="#cc0000"> &lt;LastName&gt;, 
   &lt;FirstName&gt; </font><font color="#000000">(</font><font color="#cc0000">
      &lt;EMail&gt;</font><font color="#000000">)</font> <br>
          <font color="#000000">Date:</font><font color="#cc0000"> &lt;DATE&gt;</font></blockquote>
                         
  </ul>
                          
  <h4> Manditory reading ---</h4>
        <li> Reading for Prolog</li>
                          
  <ul>
       <li> Read: 625-641</li>
         <li>Read: 401-403, 384 -386<br>
         </li>
                         
  </ul>
                          
  <h3> Written assignment:</h3>
       <b>Purpose:</b><b><br>
       </b>               
  <ul>
         <li><b>To reenforce your understanding of the backtracking search
 used  in Prolog</b></li>
         <li><b>To see you if you can figure out the runtime implementation 
 of  lists for Prolog.</b><br>
             </li>
                   
  </ul>
                             
  <ol>
                          <li> Consider the following Prolog program:</li>
                   
  </ol>
                   
  <blockquote><br>
         <tt>locatedIn(albany,newYork).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
   &nbsp; %1</tt><br>
         <tt>locatedIn(binghamton,newYork).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
   &nbsp; %2</tt><br>
         <tt>locatedIn(london,ontario).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
   &nbsp; &nbsp; &nbsp; %3</tt><br>
         <tt>locatedIn(toronto,ontario).&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
   &nbsp; %4</tt><br>
         <tt>locatedIn(X,usa):-locatedIn(X,georgia).&nbsp;&nbsp;&nbsp;&nbsp;
  &nbsp; %5</tt><br>
         <tt>locatedIn(X,usa):-locatedIn(X,newYork).&nbsp;&nbsp;&nbsp;&nbsp;
  &nbsp; %6</tt><br>
         <tt>locatedIn(X,canada):-locatedIn(X,ontario).&nbsp; &nbsp; %7</tt><br>
         <tt>locatedIn(X,northAmerica):-locatedIn(X,usa). &nbsp;%8</tt><br>
         <tt>locatedIn(X,northAmerica):-locatedIn(X,canada).%9</tt><br>
      Draw (by hand is ok) the search path with backtracking that is created
  when  this code executes: <br>
         <tt>?locatedIn(toronto,northAmerica).</tt><br>
         <tt>yes.</tt><br>
         </blockquote>
                             
    <ol>
           <tt><br>
           <br>
           </tt>                            
    </ol>
                                    
    <h3> <b>Programming Assignment:<br>
       Try:</b></h3>
        <li> <b>What is the difference between the use of <font color="#cc0000">
      "</font> and<i> </i><font color="#990000">'</font><i> .</i></b></li>
                                    
    <blockquote><b>?- X = "ABD".</b> <br>
          <b>?- X = 'ABD'.</b></blockquote>
        <li> <b>What is the difference between</b></li>
        <br>
          <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/2 and @&lt;/2? 
 (/2   is arity of 2),</b> <br>
          <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =&lt;/2 and @=&lt;/2
  ?</b>   <br>
          <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt;/2 and @&gt;/2?</b>
       <li>     <b> What does name do? Try</b></li>
                                                
      <blockquote><b>?-name(What, "abc").</b> <br>
            <b>?- name(What, "abc 123").</b> <br>
            <b>?- name(abc, What).</b></blockquote>
        <li> <b>What does write do?&nbsp; Try</b></li>
                                                            
        <blockquote><b>?-write("abc123") , write('abc') ,write(abc).</b></blockquote>
       <b>Purpose:</b> <li> <b>The purpose is this assignment is</b></li>
        <br>
              <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1) reenforce recursive
  programming</b>   <br>
              <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2) reenforce the use
 of  the  list data structure in Prolog</b> <br>
              <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3) use of pattern recognition 
   in programming</b> <br>
              <b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4) difference between 
           <i>   strings</i> and <i>atoms</i></b> <br>
      &nbsp;                                                            
    
          <ol>
      You may find this <a href="http://cbl.leeds.ac.uk/%7Etamsin/prologtutorial/index.html#menu">
      tutorial</a> or&nbsp; <a href="http://www.amzi.com/AdventureInProlog/advfrtop.htm">
      another tutorial</a> helpful.&nbsp; All code from my notes are in <a href="http://bingweb.binghamton.edu/%7Ehead/CS471/CODE/PL/example.pl">
     example.pl .</a>            <br>
     Files with hints and format :                       
          </ol>
                       
          <blockquote>                          
            <blockquote><a href="XXXAs4.pl">  XXXAs4.pl</a></blockquote>
                </blockquote>
                               
              <ol>
                                                                 
              </ol>
                                                                   
              <ol>
                                      <li> Implement a prolog program<tt><br>
     &nbsp;<b>deleteE (+E, +Lst1, -Lst2)<br>
                  </b></tt>that succeeds if Lst2 has the same sequence of 
elements   as Lst1 except there are no element E in Lst2.<br>
      &nbsp; <br>
   &nbsp; <b><tt>&nbsp;?- deleteE(x,[x,a,b,c,x],R).<br>
   &nbsp; R = [a, b, c] <br>
   &nbsp; Yes<br>
   &nbsp; ?- deleteE(3,[1,2,4,5,6],R).<br>
   &nbsp; R = [1, 2, 4, 5, 6] <br>
   &nbsp; Yes<br>
   &nbsp; ?- deleteE(3,[1,2,3,4,3,2,1,1,2,3,4,33],R).<br>
   &nbsp; R = [1, 2, 4, 2, 1, 1, 2, 4, 33] <br>
   &nbsp; Yes<br>
   &nbsp; % my code gives this error.<br>
   &nbsp; ?- deleteE(3,R,[1,2,6]).<br>
   &nbsp; ERROR: Out of local stack<br>
   &nbsp; Exception: (29,513) deleteE(3, _G88567, [1, 2, 6]) ? <br>
                 </tt></b><br>
                  <br>
                </li>
                 <li>Implement <br>
      &nbsp; <b><tt>bagToSet(Bag,Set). &nbsp;</tt><br>
                  </b>where Set has the same elements as Bag but has not
duplicates.    (You may assume that the elements are stored in the same sequence
in both    Bag and Set)<br>
                 <br>
                 <b><tt>&nbsp; &nbsp;?- bagToSet([a,b,c,x,a,y,b,a,z],R).<br>
   &nbsp; &nbsp;R = [a, b, c, x, y, z] <br>
   &nbsp; &nbsp;Yes<br>
                 <br>
   &nbsp; &nbsp;?- bagToSet([a,b,c,x,a,y,b,a,z],[a,b,c,x,y,z]).<br>
   &nbsp; &nbsp;Yes<br>
                 <br>
   &nbsp; &nbsp;?- bagToSet([a,b,c,x,a,y,b,a,z],[b,a,c,x,y,z]). &nbsp;% Fails 
 because of the order of the elements.<br>
   &nbsp; &nbsp;No<br>
                 </tt></b><br>
                   <br>
                 </li>
                 <li>A list is a <i>palindrome</i> if it reads the same in
 the  forward direction and the backward direction. &nbsp; [m,a,d,a,m] and
 [2,0,0,2]  and [g,o,h,a,n,g,a,s,a,l,a,m,i,i,m,a,l,a,s,a,g,n,a,h,o,g] are
palindrome. One way to implement the predicate is to use reverse: <br>
     &nbsp; <b>palindrome (List) :- reverse(List, List).<br>
                   </b>You are to supply an alternate solution using the
built   in predicate <b>append</b>.<br>
                   <br>
                 </li>
                 <li>Implement<b><tt> <br>
      &nbsp; &nbsp; myMerge(+List1, +List2, -Result)</tt></b><br>
       that combines two sorted lists of atoms, List1 and List2 into a sorted 
  list of atoms, Result.&nbsp; (I used cuts to eliminate wrong alternate solutions.)<br>
                  <br>
                  <b>myMerge([ ab,ccd,gg], [ bag, ccz, fix,zoo], R]<br>
      R = [ ab, bag, ccd, ccz, fix, gg, zoo];<br>
      no (</b>if you use cuts ... not required)<br>
                  <br>
                 </li>
                <li>Implement <b><tt>partition (+List, -List1, -List2)</tt></b>
      , that divides List in two parts, List1, List2 of about equal size. 
&nbsp;Each  list should have at one element. (partition  should work for any
kind of lists).<br>
                  <tt><b>?- partition([1,2,3], L1, L2<br>
                  </b></tt><b><tt>L1 = [1,3] %% or order or elements do not 
 matter  for correct solution</tt><br>
                  <tt>L2 = [2]</tt><br>
                  <tt>yes</tt><br>
                  <tt>?- partition([1,2,3,4],L1,L2).</tt><br>
                  <tt>L1 = [1,3]</tt><br>
                  <tt>L2 = [2,4]</tt><br>
                  <tt>yes</tt></b><br>
                  <br>
                </li>
                <li> Using <b><tt>myMerge</tt></b> and<b><tt> partition </tt></b>
      implement<b><tt> mergesort<font color="#000000">X</font>(+UnsortedList, 
  -SortedList),</tt></b> which will sort a list of atoms.<br>
                  <br>
                  <br>
                </li>
                <li> 4 Colors Map Coloring Problem:<br>
     On a geographic map, let us define two countries as neighbors, if they 
 share  a piece of border.&nbsp; Two countries are not neightbors, if they 
 join in  a common point only or if they do not join at all.&nbsp; Your problem 
 is to write a logical prolog program that given the following&nbsp; map
with countries A, B,  ...G  (figure below), the program will allocate one
of four colors to each  country,  so that no adjacent countries will have
the same color.<br>
     First use atoms for each color you want to use.&nbsp; i.e. red, blue,
 green,  pink, black. <br>
     You can either enumerate all permutation of colors neighbors can have. 
 That  will be 12 facts. <br>
     OR you can enumerate all combination of colors that can be adjacent.&nbsp;
   That will be 6 facts and then include 2 neighbor rules that defines the
 remaining possible permutations of color pairs.<br>
     Now you are ready to define the one rule, <tt>mapcolor(A,B,C,D,E,F)</tt>
     ,&nbsp; to find the possible color combinations for the map below.&nbsp; 
  (Writing the Prolog for this is much easier than describing the problem.) 
  &nbsp;Note: the country names will be unified with a color: i.e A = blue, 
  B=red..etc<br>
                   <br>
                   <a href="file:///home/head/Courses/471/HW/map1.jpg"></a><a href="mapS02.jpeg"><img src="mapS02.jpeg" alt="Map coloring." width="250" height="201">
                  </a>               <br>
    Possible examples of output include:<br>
                  <tt>&nbsp; &nbsp;?- mapcolor(A,B,C,D,E,F).<br>
                  <br>
    &nbsp; &nbsp;A = red<br>
    &nbsp; &nbsp;B = blue<br>
    &nbsp; &nbsp;C = pink<br>
    &nbsp; &nbsp;D = black<br>
    &nbsp; &nbsp;E = pink<br>
    &nbsp; &nbsp;F = red ;<br>
                  <br>
    &nbsp; &nbsp;A = red<br>
    &nbsp; &nbsp;B = blue<br>
    &nbsp; &nbsp;C = pink<br>
    &nbsp; &nbsp;D = black<br>
    &nbsp; &nbsp;E = pink<br>
    &nbsp; &nbsp;F = blue <br>
                  <br>
    &nbsp; &nbsp;Yes</tt><br>
                  <br>
                  <br>
                  <br>
                 </li>
                 <li>Ackermann's function is a simple but very interesting
 non-trivially   recursive function.&nbsp; It is surprising that for such
a simple definition   ack(4,4) can NOT be computed within a resonable time
.</li>
                                                                   
              </ol>
                                                                   
              <ol>
        <br>
      &nbsp;                                                            
                        
                <table border="0" width="76%">
       <caption>&nbsp;Definition of Ackermann's function: </caption>  <tbody>
        <tr>
       <td><tt>ack(0,<i>n</i>) = <i>n +</i> 1</tt></td>
        <td>m &gt; 0</td>
       </tr>
        <tr>
       <td><tt>ack(<i>m</i>,0) = </tt><tt>ack(<i>m</i><i>-</i>1,1)</tt></td>
        <td>n = 0 &amp; m &gt; 0</td>
       </tr>
        <tr>
       <td><tt>ack(<i>m,n</i>) = ack(<i>m</i>-1,ack(m,n-1))</tt></td>
        <td>n &gt; 0&nbsp; &amp; m &gt; 0</td>
       </tr>
                                                                        
                              
                  </tbody>                                              
                                     
                </table>
                                                                        
                   
                <p>In the early days of imperative languages, recursion was
 not   very fashionable and implementions put restrictions on what depth
of  recursion   was achievable.&nbsp; The Ackermann function was used to
measure  the recursion   capability of a compiler by defining the Ackermann
Number  N of the compiler   as the largest N for which </p>
                                                                         
               
                <ol>
                  <tt>ack(3,N)</tt>                                     
                                              
                </ol>
       gives an answer without a stack overflow. <br>
      Turn in the code and the answers written as comments in the program.
                                                                        
            
                <ol type="A">
       <li> What value does your program calculate for&nbsp; <tt>ack(2,4)?</tt>
      &nbsp; Does it match the result expected proved in HW1?</li>
        <li> Program Ackermann's function in Prolog and find the Ackermann
 Number   N of your Swipl environment.<br>
                    </li>
                                                                        
    
                </ol>
                                                                   
              </ol>
               <br>
              <font color="#3333ff"><br>
              <br>
      Remember Programming is an individual task... :</font>            
                                                            
              <p><font color="#3333ff">Resources use:</font> </p>
                                                                        
    
              <p><a href="mailto:head@binghamton.edu">Questions?(For E. Head)</a>
       </p>
                                                                        
    
              </body>
              </html>
