<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="Author" content="Eileen Head">
  <meta name="GENERATOR"
 content="Mozilla/4.73 [en] (Win98; U) [Netscape]">
  <title>CS471 Assignment 11- Function programming, HOF, list
comprehension, lambda expressions, tail recursion</title>
</head>
<body style="color: rgb(0, 0, 0); background-color: rgb(255, 255, 249);"
 alink="#3333ff" link="#000099" vlink="#000099">
<center>
<h3> Programming Languages<br>
Assignment<i> </i>11<br>
<i>Due: </i>Monday, Nov 22, 2004<br>
</h3>
</center>
<h4>Purpose:</h4>
To understand the use function applications of higher order functions
to replace explicit recursion, the use of list comprehension notation
to express solutions. To be able to identify the tail recursion form of
a function definition..<br>
<h4>References and Reading:</h4>
<ul>
  <li><a href="http://www.haskell.org/aboutHaskell.html">Introduction
to Haskell</a>&nbsp; (Look over)<br>
  </li>
  <li><a href="http://www.haskell.org/tutorial/">A Gentle Guide to
Haskell</a></li>
  <ul>
    <li><a href="http://www.haskell.org/tutorial/functions.html#sect3.4">Infinite
data structure</a><br>
    </li>
  </ul>
</ul>
<ul>
</ul>
<ul>
  <li>Thompson (optional but very helpful)<br>
  </li>
  <ul>
    <li>Chapter 5.3 - 5.5<br>
    </li>
    <li>Chapter 9 <br>
    </li>
    <li>Chapter 10<br>
    </li>
  </ul>
</ul>
<ul>
  <li>Louden <br>
  </li>
  <ul>
    <li>Chapter 9.1 - 9.4 (optional 9.7)</li>
  </ul>
  <ul>
    <li>Chapter 6.8 (optional)<br>
    </li>
  </ul>
  <ul>
    <li>(On going) Chapter 11 <br>
    </li>
    <li>section 11.6<br>
    </li>
  </ul>
</ul>
<h4>Written questions:</h4>
<ol>
  <li>What makes a function tail recursive?&nbsp; <br>
  </li>
  <ol style="list-style-type: upper-alpha;">
    <li>Give an example (other than the ones in the problem below) of
code which is NOT
tail recursive.&nbsp; <br>
    </li>
    <li>Give an example of code which has the same values as part A
except the code is tail recursive.<br>
    </li>
  </ol>
  <li>page 529 exercise 11.1<br>
  </li>
  <li>Here&#8217;s a tail-recursive definition of reverse :: [a] -&gt; [a].
It uses an auxiliary<span style="font-family: monospace;"> function
shunt :: [a] -&gt; [a] -&gt; [a]</span>.<br>
    <span style="font-family: monospace;">&nbsp; reverse2 = shunt []</span><br>
    <div style="margin-left: 40px; font-family: monospace;">where<br>
shunt xs [] = xs<br>
shunt xs (y:ys) = shunt (y:xs) ys<br>
    </div>
Show the steps in the evaluation of<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span
 style="font-family: monospace;">reverse "abcd"</span><br>
using the original reverse function<span style="font-family: monospace;">r<br>
&nbsp;&nbsp;&nbsp; reverse1 [] = []<br>
&nbsp;&nbsp;&nbsp; reverse1 (x:xs) = reverse1 xs ++ [x]</span><br
 style="font-family: monospace;">
and do the same for<br>
&nbsp;&nbsp;&nbsp;&nbsp; reverse2 "abcd"<br>
using the tail-recursive one. In the reverse1 case, use the following
definition of (++):<br>
&nbsp;<span style="font-family: monospace;">&nbsp;&nbsp; [] ++ ys = ys</span><br
 style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp; x:xs) ++ ys = x
: (xs ++ ys)</span><br>
What do you conclude about the two reverse functions&#8217; big-O complexity?<br>
  </li>
</ol>
<br>
<ol>
</ol>
<h4>Programming:</h4>
<blockquote></blockquote>
Purpose: to learn new ways of expressing solutions using list
comprehension notation, function application of higher order functions
and using lambda expression.<br>
Problems found here:<br>
<a href="Haskell2F04.lhs">&nbsp;&nbsp;&nbsp; Haskell2F04.lhs</a><br>
<br>
<br>
</body>
</html>
