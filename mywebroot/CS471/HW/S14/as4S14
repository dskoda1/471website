/*
        CS471 - Programming Languages
        Section: <YOUR Section number>
        Assignment #<number> due: <DATE>
        Author: <LastName>, <FirstName> (<EMail>)
        Date: <DATE>
 */

/* Purpose:
   * to reenforce search order.
   * to reenforce recursive programming
   * to reenforce the use of the list data structure in Prolog

	1) For some of the problems below you need only generate a correct
      result from the query without requesting alternative results.
      You may use cuts but it is not required.
 */


/* 1:  : (From Learn Prolog NOW! exercise 3.3)
 * Binary trees are trees where all internal nodes have exactly two
 * children. The smallest binary trees consist of only one leaf node. We
 * will represent leaf nodes as leaf(Label). For instance, leaf(3) and
 * leaf(7) are leaf nodes, and therefore small binary trees. Given two
 * binary trees B1 and B2 we can combine them into one binary tree using
 * the predicate tree: tree(B1,B2). So, from the leaves leaf(1) and
 * leaf(2) we can build the binary tree tree(leaf(1), leaf(2)). And from
 * the binary trees tree(leaf(1), leaf(2)) and leaf(4) we can build the
 * binary tree tree(tree(leaf(1), leaf(2)), leaf(4)).

 * Now, define a predicate swap/2, which produces a mirror image of the
 * binary tree that is its first argument. For example:

    ?- swap(tree(tree(leaf(1), leaf(2)), leaf(4)),T).
    T = tree(leaf(4), tree(leaf(2), leaf(1))).
    yes

  2 clauses
**/

/* 2: Define a predicate, addTree/2 that computes of all the values
      in a binary tree. Assume the tree structure define in problem 1 and all
      the values in the leaves are integers. (2 clauses)
    e.g.
      ?- addTree(tree(leaf(4), tree(leaf(2), leaf(1))),S).
      S = 7.
      ?- addTree(tree(tree(leaf(-2),leaf(-4)), tree(leaf(2), leaf(1))),S).
      S = -3.
      ?- addTree(tree(tree(leaf(-2),leaf(4)), tree(leaf(2), leaf(-1))),S).
      S = 3.
      ?- addTree(tree(tree(leaf(0), leaf(2)), leaf(4)),S).
      S = 6.

  */


/** 3 sumR(+N,?P).
   Given a number, N, S is a list of the sum of the numbers from N
   down to 1 such that first number in S is the sum of all the number from N to 1,
   the second number in P the sum of all the numbers from N-1 down to 1
    etc.
   For example:

     ?- sumR(6,S).
     S = [21, 15, 10, 6, 3, 1] .

   2 clauses
*/


/* 4:  sumL(+N,?S).
   Is simular to sumR(+N,?S), except that sum totals
   accumulate left to right. e.g. The first value in S will be N,
   the second value will be N + N-1, etc.

     ?- sumL(6,S).
     S = [6, 11, 15, 18, 20, 21]


    It would be helpful to overload sumL/2 and include the following
    clause:

       sumL(N,Lst):-sumL(N,N,Lst).

    2 additional clauses.

*/

/** :  "Send more money" is a well-known puzzle. Each of the letters
    D,E,M,N,O,R,S and Y represents a different digit. Moreover, when each
    letter is mapped to its corresponding digit the equation SEND + MORE =
    MONEY holds. Below is a very naive . Since there are 8 letters to be
    solved, it simply explore the 10*9*...*3 mappings of letters to
    digits.
    A little insight can simplify things. Clearly, SEND < 9999 and
    MORE < 9999. Thus MONEY < 19998 and hence M = 1.
    Now we have SEND + 1ORE = 1ONEY. Again SEND < 9999
     and now 1ORE < 1999 so 1ONEY < 11998. Since M is already bound to 1,
     O must be bound to 0. A little more thought shows that S must be
     bound to 8 or 9, and that N = E + 1. Using these insights to reduce
     the number of solutions that must be explored, write a Prolog
     predicate soln([D,E,M,N,O,R,S,Y]) that solves this puzzle by binding
     the correct digits to each of the variables in the list. (Modified
     from http://www.cs.wisc.edu/~fischer/)
    (1 clause with multiple subgoals.)

*/

solvSlow( [D,E,M,N,O,R,S,Y]) :-
	Lst = [S,E,N,D,M,O,R,Y],
	Digits = [0,1,2,3,4,5,6,7,8,9],
	assign_digits(Lst, Digits),
	M > 0,
	S > 0,
	1000*S + 100*E + 10*N + D +
	1000*M + 100*O + 10*R + E =:=
	10000*M + 1000*O + 100*N + 10*E + Y,
	write(Lst).


assign_digits([], _List).
assign_digits([D|Ds], List):-
        select(D, List, NewList),
        assign_digits(Ds, NewList).

 % --------------------------
   /*     ?- solv([D,E,M,N,O,R,S,Y]).
          [9, 5, 6, 7, 1, 0, 8, 2]
          D = 7,
          E = 5,
          M = 1,
          N = 6,
          O = 0,
          R = 8,
          S = 9,
          Y = 2
   */


/* 6:  Syntax-Directed Differentiation:  A motivating example illustrating the
         power of pattern matching in Prolog.
         Consider the following rules for symbolic differentiation
         (U, V are mathematical expressions, x is a variable):

        dx/dx = 1
        d(C)/dx = 0.
        d(Cx)/dx = C               (C is a constant)
        d(-U)/dx = -(dU/dx)
        d(U+V)/dx = dU/dx + dV/dx
        d(U-V)/dx = dU/dx - dV/dx
        d(U*V)/dx = U*(dV/dx) + V*(dU/dx)
        d(U^n)/dx = nU^(n-1)*(dU/dx)

        These rules can easily be translated into Prolog, for instance,
        the second rule can be defined as
                   d(C,x,0):-number(C).
          and the fifth rule can be defined as
                   d(U+ V ,x, DU+ DV)):- d(U,x,DU),d(V,x,DV).

         Write the remaining rules. Here is a test query:

           ?- d(3*(x +2*x*x),x,Result).
           Result = 3* (1+ (2*x*1+x*2))+ (x+2*x*x)*0 ;
           Result = 3* (1+ (2*x*1+x* (2*1+x*0)))+ (x+2*x*x)*0 ;
           false.


        Keep in mind, though, that terms such as U+V are still trees with the
        functor at the root, and that evaluation of such terms requires
        additional processing .  See next week's assignment.
        1 clause for each definition.
*/




/* 7: regularEx(Lst).
 Using the ideas presented on slides 15-19
(http://dingo.sbs.arizona.edu/~sandiway/ling388n/lecture6.ppt)
Write a recognizer/generator for the regular expression:
      (a(bb)+a)|(b(aa)+b)

i.e.
   1 ?- regularEx([a,b,b,b,b,a]).
   true
   2 ?- regularEx([a,b,b,b,b]).
   false
   3 ?- regularEx([b,a,a,a,a,a,a,b]).
   true
   4 ?- regularEx([X,Y,Z]).
   false
  5 ?- regularEx(X).
    X = [a, b, b, a] ;
    X = [a, b, b, b, b, a] ;
    X = [a, b, b, b, b, b, b, a] ;   
    etc
 The order of your causes is important.

*/



%8: Binary Tree
/* 8:
   Section 14.4 of Touch of Class: An Introduction to Programming Well 
   Using Objects and Contracts,
   by Bertrand Meyer, Springer Verlag, 2009. © Bertrand Meyer, 2009.
   (http://touch.ethz.ch/recursion.pdf) 
   has the following definition of a binary tree.

  " Definition: binary tree

   A binary tree over G, for an arbitrary data type G, is a finite set of items 
   called nodes, each containing a value of type G, such that the nodes, if any, 
   are divided into three disjoint parts:
      • A single node, called the root of the binary tree.
      • (Recursively) two binary trees over G, called the  
        left subtree and right subtree."


   The "if any" implies that the 'empty' tree
   is a binary tree.

   We can represent a binary tree prolog as follows:

   empty %  'empty' tree
   node( V, LT, RT)  % V is a value and LT and RT are binary trees.


   Define isBinaryTree(T) that succeeds if T is a binary tree.

   i.e.

   ?- tree1(T),isBinaryTree(T).
   T = node(10, empty, node(100, empty, empty)).

   ?- tree2(T),isBinaryTree(T).
   T = node(-1, node(5, empty, node(100, empty, empty)), node(2, node(9, empty, empty), empty)).

   ?- tree3(T),isBinaryTree(T).
   T = node(5, node(10, empty, node(100, empty, empty)), node(-1, node(5, empty, node(100, empty, empty)), node(2, node(9, empty, empty), empty))).


   ?- badTree(T),isBinaryTree(T).
   false.

   */
/* Below are samples you can use to test your program    */

tree1(node(10,empty, node(100,empty, empty))).
tree2(node(-1, node(5, empty, node(100, empty, empty)), node(2, node(9,empty, empty),empty))).
tree3(T):- tree1(T1), tree2(T2), T= node(5,T1,T2).  %% Fixed brain dead typo
tree4(node(~, node(+, empty, node(*, empty, empty)), node(!, node(/,empty, empty),empty))).
badTree( node(3, node(5, empty), empty)) .



%9: memberT/2
/* 9: Define the predicate memberT(E,BT), that succeeds if E is a value in BT, a binary tree.  
      BT uses the representation defined in problem 8.
       ?- tree4(T), memberT(E,T).
       T = node(~, node(+, empty, node(*, empty, empty)), node(!, node(/, empty, empty), empty)),
       E = ~ ;
       T = node(~, node(+, empty, node(*, empty, empty)), node(!, node(/, empty, empty), empty)),
       E = (+) ;
       T = node(~, node(+, empty, node(*, empty, empty)), node(!, node(/, empty, empty), empty)),
       E = (*) ;
       T = node(~, node(+, empty, node(*, empty, empty)), node(!, node(/, empty, empty), empty)),
       E = ! ;
       T = node(~, node(+, empty, node(*, empty, empty)), node(!, node(/, empty, empty), empty)),
       E = (/) ;
       false.
      ?- tree4(T), memberT(!,T).
      T = node(~, node(+, empty, node(*, empty, empty)), node(!, node(/, empty, empty), empty)) .
      ?- tree1(T),memberT(100,T).
      T = node(10, empty, node(100, empty, empty)) .
      */






