<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>Week 13 Monday</title></head>
<body>Monday Week 13<span style="text-decoration: underline;"><br></span>Scott<br>page 539-545<br><br>Here is the definition of "foldr" that is in <br>&nbsp; "C:\Program Files\Hugs98\lib\Prelude.hs"<br><br><span style="font-family: monospace;">&nbsp; foldr f z []&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = z</span><br style="font-family: monospace;"><span style="font-family: monospace;">&nbsp; foldr f z (x:xs)&nbsp; = f x (foldr f z xs)</span><br style="font-family: monospace;"><br>&nbsp;Next,
recall from "Higher Order Function" notes that&nbsp; we can use the
notation "e1~&gt;e2" to mean expression e1 evaluates to expression e2
when we want to explain how a function is reduced step-by-step. &nbsp;
For example, in this question we are looking for a function "f" that
would produce the following sequence of evaluations:<br><br><div style="margin-left: 40px;"><span style="font-family: monospace; font-weight: bold;">foldr f [] [1,2,3]</span><br style="font-family: monospace; font-weight: bold;"><span style="font-family: monospace; font-weight: bold;">~&gt; f 1 (foldr f [] [2,3])</span><br style="font-family: monospace; font-weight: bold;"><span style="font-family: monospace; font-weight: bold;">~&gt; f 1 (f 2 (foldr f [] [3]))</span><br style="font-family: monospace; font-weight: bold;"><span style="font-family: monospace; font-weight: bold;">~&gt; f 1 (f 2 (f 3 (foldr f [] [])))</span><br style="font-family: monospace; font-weight: bold;"><span style="font-family: monospace; font-weight: bold;">~&gt; f 1 (f 2 (f 3 []))</span><br style="font-family: monospace; font-weight: bold;"><span style="font-family: monospace; font-weight: bold;">~&gt; f 1 (f 2 [3])</span><br style="font-family: monospace; font-weight: bold;"><span style="font-family: monospace; font-weight: bold;">~&gt; f 1 [3,2]</span><br style="font-family: monospace; font-weight: bold;"><span style="font-family: monospace; font-weight: bold;">~&gt; [3,2,1]</span><br></div><br>&nbsp;Now,
Haskell has a function "reverse" that reverses the order of the
&nbsp;elements in a list, e.g. reverse [1,2,3,4] =&gt; [4,3,2,1]. The
definition &nbsp;in Prelude.hs consists of <br><div style="margin-left: 40px;">&nbsp;<span style="font-family: monospace;">foldl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a</span><br style="font-family: monospace;"><span style="font-family: monospace;">&nbsp;foldl f z []&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = z</span><br style="font-family: monospace;"><span style="font-family: monospace;">&nbsp;flip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</span><br style="font-family: monospace;"><span style="font-family: monospace;">&nbsp;flip f x y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = f y x</span><br style="font-family: monospace;"><span style="font-family: monospace;">&nbsp;foldl f z (x:xs)&nbsp; = foldl f (f z x) xs</span><br style="font-family: monospace;"><span style="font-family: monospace;">&nbsp;reverse&nbsp;&nbsp; :: [a] -&gt; [a]</span><br style="font-family: monospace;"><span style="font-family: monospace;">&nbsp;reverse&nbsp;&nbsp;&nbsp; = foldl (flip (:)) []</span><br style="font-family: monospace;"></div><br>&nbsp;Complete
reverse1 by replacing YOURLAMBDAEXPRESS with a lambda expression which
will reverse a list.&nbsp; You should _NOT_ use "flip"<br>&nbsp;<br>&nbsp;&gt; reverse1 = foldr YOURLAMBDAEXPRESS []<span style="text-decoration: underline;"><br><br></span><br><br>

<ol>



</ol>
</body></html>