<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>





  


  
  
  
  
  
  
  
  
  
  <title>Types and Control Structures- Louden Chapter 6 and 7</title>
  <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">






  
  
  
  
  
  <meta name="author" content="E Head">
</head>


<body>






<div style="text-align: center;">
<h3>Homework
Assignment 7<br>






</h3>






</div>






Due: &nbsp;Extended to Wed.,&nbsp; Oct 26<br>






<h4>
Purpose: Understand data types , type equivalents,&nbsp; some
control structures.<br>






</h4>






You can work in teams of 2 people.<br>






<br>






<h3>Reading/References:</h3>






<ul>






  <li>Completion of Chapter 5</li>




  <li>Chapter 6&nbsp;<br>






  </li>






</ul>






<h3>Assignment:<br>






</h3>







  
<ol>






  <li>For each of the following, give a formula for computing the
effective address.&nbsp; Assume the array <span style="font-style: italic;">ARR</span> is allocated as a single block
at address, <span style="font-style: italic;">baseAdr</span>, and let <span style="font-style: italic;">size</span> be the size of an individual
array element.</li>




  
  
  
  
  <ol style="list-style-type: lower-alpha;">




    <li>The element <span style="font-family: monospace;">Arr[</span><span style="font-style: italic; font-family: monospace;">i</span><span style="font-family: monospace;">]</span>, where 0&lt;= <span style="font-style: italic;">i</span> &lt;<span style="font-style: italic;"> n</span></li>




    <li>The element <span style="font-family: monospace;">Arr[</span><span style="font-style: italic; font-family: monospace;">i</span><span style="font-family: monospace;">]</span>, where 0&lt; <span style="font-style: italic;">i</span> &lt;<span style="font-style: italic;">= n</span></li>




    <li>The element <span style="font-family: monospace;">Arr[</span><span style="font-style: italic; font-family: monospace;">i</span><span style="font-family: monospace;">][<span style="font-style: italic;">j</span>]
      </span>, where 0&lt;= <span style="font-style: italic;">i</span>
&lt;<span style="font-style: italic;"> m </span>and 0 &lt;= <span style="font-style: italic;">j</span> <span style="font-style: italic;">&lt;
n </span>and where the array is allocated in row-major order.</li>




    <li>The element <span style="font-family: monospace;">Arr[</span><span style="font-style: italic; font-family: monospace;">i</span><span style="font-family: monospace;">][<span style="font-style: italic;">j</span>]
      </span>, where 0&lt;= <span style="font-style: italic;">i</span>
&lt;<span style="font-style: italic;"> m </span>and 0 &lt;= <span style="font-style: italic;">j</span> <span style="font-style: italic;">&lt;
n </span>and where the array is allocated in column-major order.</li>




  
  
  
  
  </ol>





  <li> The keyword <b><i>static</i></b> has two different
semantics in Ansi C depending on where it is used, either inside a
function
definition or outside of a function definition.&nbsp; What does <b><i>static</i></b>
mean in both settings?</li>





  <li>page 185 exercise 5.24 (Think about the type of '&amp;' and '*'
operators.)<br>






  </li>





  <li>page 185 exercise 5.28</li>

  <li>page 354 exercise 8.34 &nbsp;</li>





  <li>page 250 exercise 6.7 (Hint: Which "type equivalance" algorithm is used for functions in C &amp; C++?)</li>






  

  <li>page 253 exercise 6.15</li>




  




  <li>page 254 exercise 6.22</li>

  <li>page 257 exercise 6.47</li>






  <li>Given the following C
declarations,<br>


    <br>



  </li>






  
  


    
  
  
  
  <ol>



    <span style="font-family: monospace;">double
d = 2.0;</span><br>



    <span style="font-family: monospace;">


double* p = &amp;d;</span><br>



    <span style="font-family: monospace;">


void* q;</span><br>



    <span style="font-family: monospace;">


int* r;</span>


    <br>



    <br>



  
  
  
  </ol>



which of the following
assignments does the c compiler complain about (i.e. gives a warning)?


    <span style="font-family: monospace;"><br>



  <br>



  </span>
  
  
  
  <ol>



    <span style="font-family: monospace;">r = p;</span><br>



    <span style="font-family: monospace;">q = p;</span><br>



    <span style="font-family: monospace;">


p&nbsp; = q;</span><br>



    <span style="font-family: monospace;">


p = r;</span><br>



    <span style="font-family: monospace;">


r = q;</span><br>



    <span style="font-family: monospace;">


r = (int*)q;</span>


    <br>



    <br>



  
  
  
  </ol>


  <br>


  
  
  <ol style="list-style-type: lower-alpha;">


    <li>Try to explain the
behavior of the C compiler.&nbsp; Will *r ever have the value 2 after
one of the assignments to r?&nbsp; Why?</li>


    <li>What happens when this code is compiled with a C++ compiler?
&nbsp;Which compiler result is better for the programmer? &nbsp;Why? </li>


  
  
  </ol>


  <br>





  
  


  <li> Suppose this C++ code </li>






  
  
  
  
  
  <ol>





    <dd><span style="font-family: monospace;">const
int k = ???;</span><span style="font-family: monospace;"></span></dd>





    <dd><span style="font-family: monospace;">int * i
= 0;</span><span style="font-family: monospace;"></span></dd>





    <dd style="margin-left: 0px; width: 161px;"><span style="font-family: monospace;">struct A
{<br>






      </span></dd>





    <dd><span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
int x
[k]; <br>






      </span></dd>





    <dd><span style="font-family: monospace;">};</span></dd>





    <dd><span style="font-family: monospace;"></span><span style="font-family: monospace;">A* a = 0;</span><span style="font-family: monospace;"></span></dd>





    <dd><span style="font-family: monospace;">printf(
"%d&nbsp;
%d&nbsp;
%d %d&nbsp; %d&nbsp; %d &nbsp;",</span></dd>





  
  
  
  
  
  </ol>












  
    
  
  
  
  
  <div style="margin-left: 40px;"><span style="font-family: monospace;">&nbsp;</span><span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
i+1, i+k, k, a+k,
&amp;(a[10]),</span><span style="color: rgb(204, 0, 0); font-family: monospace;"> </span><span style="font-family: monospace;">&amp;(a[10])
-(a+1)&nbsp;
); </span><br style="font-family: monospace;">





    </div>






    <br>






outputs the values for the first two expressions<br>






&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">&nbsp;4
&nbsp;20</span><br>






What are its remaining outputs? &nbsp;Briefly explain how the output is obtained. &nbsp;(Hint: pay attention to coersion.)<br>




  <br>






  

  
  
  
  
  
  <ol>






  
  
  
  
  
  </ol>






  <li>Discuss one way <span style="font-weight: bold;"><span style="font-style: italic;">const</span> </span>behavior
differently
in C
vs C++?&nbsp; Which is a better specification of <span style="font-style: italic;">const </span>for the
programmer?<br>






  </li>






  <li><span style="color: rgb(153, 0, 0);"></span>Recall&nbsp;<a href="http://bingweb.binghamton.edu/%7Ehead/CS471/HW/hw5F05/trouble.cpp">trouble.cpp</a>.
Should the
equality test be available for floating-point
types(explain)? Give a C code example which test for&nbsp;equality
without the "==" operator. &nbsp;This code does not have to check
whether two values are exactly the same. &nbsp;Why is your code better
than using the "==" operator?<br>






  </li>



  <li>Let the size of <span style="font-style: italic;">char
    </span>be
1 byte and the size of an int be 4 bytes,&nbsp; what is the size of
the
following struct, rec,&nbsp; if the the system is allowed to
rearrange
the fields to optimize the space but it is required to keep ints on a
word boundary?&nbsp; Write a <span style="font-weight: bold;">C
or C++</span>
program to determine the size of the struct.&nbsp; What is the
size?&nbsp; Briefly explain how C/C++ lays out the struct in
memory..</li>






  
  
  
  
  
  <ol>






    <span style="font-family: monospace;"><br>
struct
rec {</span><br style="font-family: monospace;">






      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
char a;</span><br style="font-family: monospace;">






      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
int x;</span><br style="font-family: monospace;">






      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
char b;</span><br style="font-family: monospace;">






      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
int y;</span><br style="font-family: monospace;">






      <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
char c;</span><br style="font-family: monospace;">






      <span style="font-family: monospace;">}<br>
    </span>
  </ol>
  <li> given the following program fragment in C:<br>






    
    
    
    
    <div style="margin-left: 40px;"><span style="font-family: monospace; font-weight: bold;">int a = 4; &nbsp; &nbsp; &nbsp; </span><br>



    <span style="font-family: monospace; font-weight: bold;">int b = (a++
&gt;= ++a) &amp;&amp; (++a &gt; (a=2));</span><br>



    </div>






Assuming that all side-effects take effect immediately, what are the
possible final values of a and b? Give the values in pairs, for example
(a = ..., b = ...). &nbsp;Remember in Java, C and C++, <span style="font-weight: bold;">&amp;&amp;</span> is a <a href="http://en.wikipedia.org/wiki/Lazy_evaluation#Minimal_evaluation">short circuit</a> operator which is always evaluated left to right.<br>






a. Assume that, wherever there is an option, operands are evaluated
left to right:<br>






b. Assume that, wherever there is an option, operands are evaluated
right to left:</li>



  
  
  
  <ol>






    
    
    
    
    
    <ol>






    
    
    
    
    
    </ol>






    
    
    
    
    
    <ol>






    
    
    
    
    
    </ol>






  
  
  
  
  
  </ol>






</ol>






</body>
</html>
