<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="E Head">
   <meta name="GENERATOR" content="Mozilla/4.7 [en] (WinNT; U) [Netscape]">
   <meta name="KeyWords" content="Prolog assignments">
   <title>Homework assignment 4  Due Feb 18</title>
</head>
<body text="#000000" bgcolor="#FFFFF4" link="#FF0000" vlink="#800080" alink="#0000FF">
<a href="http://bingweb.binghamton.edu/~head/CS471/471hwIndex.html">Back</a>
<br>Due Friday, Feb. 18, 2000
<br><a href="http://bingweb.binghamton.edu/~head/CS471/requirements.html">General
Submission Instructions,</a>
<br>For this assignment put all the code in one file called
<blockquote><font color="#000099">&lt;lastName>&lt;firstName>4.pl</font><font color="#000000">.</font>
<br><font color="#000000">You will need to turn in a hard copy of the code
as well as email the file to </font><a href="mailto:cs471h@binghamton.edu">cs471h@binghamton.edu</a>
<br>NOTE:The subject of your email should be YOUR NAME, and NAME of The
FILE&nbsp; ATTACHED.</blockquote>
<b>Written</b>
<ol>
<li>
<b>What is the definition of a binary tree?</b></li>

<li>
<b>What is the definition of a binary search tree?</b></li>

<li>
<b>What is the difference between a heap data structure and a binary search
tree?</b></li>
</ol>
<b>Programming</b>
<br>The purpose of this assignment is to re-enforce your understanding
of recursive data structures.
<ol>
<li>
<a href="http://bingweb.binghamton.edu/~head/CS471/CODE/PL/tree.pl">Attached
is partial binary search trees code.</a> (Modified 10:22 pm 2/11).</li>

<ol TYPE=a>
<li>
Write a procedure <b><tt>isBinaryTree(Tree),</tt></b>that succeeds if Tree
is a binary tree (it is not necessary for Tree to be a binary search tree).</li>

<ol TYPE=a><b><tt>?- isBinaryTree(empty).</tt></b>
<br><b><tt>yes</tt></b>
<br><b><tt>?-isBinaryTree(node(5,empty,empty)).</tt></b>
<br><b><tt>yes</tt></b>
<br><b><tt>?-notBST(T),isBinaryTree(T).</tt></b>
<br><b><tt>yes</tt></b>
<br><b><tt>?- isBinaryTree(node(5)).</tt></b>
<br><b><tt>no</tt></b></ol>

<li>
Write a procedure <b><tt>isBST(Tree),</tt></b>that succeeds if Tree is
a binary search tree.</li>

<ol TYPE=a><b><tt>?- isBST(empty).</tt></b>
<br><b><tt>yes.</tt></b>
<br><b><tt>?-isBST(node(5,empty,empty)).</tt></b>
<br><b><tt>yes.</tt></b>
<br><b><tt>?-notBST(T),isBST(T).</tt></b>
<br><b><tt>no.</tt></b></ol>

<li>
Define a procedure, <b><tt>insert( NewItem, Tree, NewTree)</tt></b> that
inserts an item into a binary search tree, Tree, by instantiating NewTree
to be a binary search tree composed of Tree and the NewItem.&nbsp; <i>Note:
The location where the value is inserted in your BST does not have to be
the same exact location as my code but you must build a binary search tree.
</i>(Hint:&nbsp;
It is helpful to use pattern matching to "pull a part" the trees.).</li>

<ol TYPE=a>?-insert(5, empty, NT).
<br>NT = node(5, empty, empty).
<br>?- tree1(T), insert(44, T, NT).
<br>T = node (33, empty, empty).
<br>NT = node (44, node(33, empty, empty), empty).</ol>
</ol>
</ol>

<ol START=2>
<li>
Write a procedure called <b>smashed</b> that takes a list whose elements
may be either atoms or lists (with any degree of embedding) and returns
a list of all the atoms contained in the original list, thus:</li>

<ol START=2>?-<b><tt>smashed([ [a,b,c],[d,[e,f],g],h], S)</tt></b>
<br><b><tt>S= [a,b,c,d,e,f,g,h].</tt></b></ol>
(HINT:Only 3 rules needed.)
<br>Extra credit if your code does not produce non-sense results during
backtracking.&nbsp; (You will need to use cuts.)
<br>&nbsp;
<li>
Define a predicate append3DL&nbsp; that concatenates three difference lists:</li>

<br>&nbsp;&nbsp;&nbsp; <tt>?- append3DL( [z,y|A] - A, [x,w | B] -B, [u,v
| C] - C, What).</tt>
<br><tt>&nbsp; What = [z, y, x, w, u, v | _n] - _n</tt>
<br><tt>&nbsp; yes</tt>
<br>&nbsp;
<li>
Extra credit if done by Feb 18.&nbsp; Otherwise due one week later.&nbsp;
I created two predicates to solve this problem.&nbsp; In addition I used
append.</li>

<br>Define a procedure <tt>powerset(+Set,-PowerSet),</tt>given a Set, represented
by a list, it creates the powerset of Set. i.e.
<br><tt>?- powerset([],X).</tt>
<br><tt>X = [[]]</tt>
<br><tt>?- powerset([1],X).</tt>
<br><tt>X = [[],[1]]&nbsp; % order of sets not important</tt>
<br><tt>?- powerset([a,b],P).</tt>
<br><tt>P = [[a,b], [a], [b], []]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % order
of sets not important</tt>
<p><tt>?- powerset(S,[[a],[b],[a,b],[]]).</tt>
<br><tt>%%%&nbsp; May run out of stack ... YOUr code does not need</tt>
<br><tt>%%%&nbsp; to work for this query.</tt>
<br><tt>?- powerset([a,b],[[a],[b],[a,b],[]]).</tt>
<br><tt>%%%&nbsp; may run out of stack ... YOUr code does not need</tt>
<br><tt>%%%&nbsp; to work for this query.</tt>
<br>&nbsp;</ol>

<h5>
<a href="mailto:head@binghamton.edu">Questions?(For E. Head)</a></h5>
2/11/00 2:46
</body>
</html>
