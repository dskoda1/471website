Problem 2:
Define a function replicate which given a list of numbers returns a 
list with each number duplicated its value. Use  this problem using a fold, map 
-- I also used a lambda expression, (++) and a take.  Only restrictions is you 
should use HOF no recursion and no list comprehension.
.

> replicate' lst = [n | n<-lst, c<-[1..n]]

     ...> replicate' [3,4,2,5,1,6]
     [3,3,3,4,4,4,4,2,2,5,5,5,5,5,1,6,6,6,6,6,6]
     (0.00 secs, 1049676 bytes)

> rep lst  = foldr1 (++) (map (\n->take n [n,n..]) lst) 


Problem 6: Use 'map', a 'fold', (.), length and "()"  to define  sumLengths 
           that takes a list of lists and returns the sum of all 
           their lengths. (A little tricky) i.e.  
           
  ...> sumlengths [[12,4,5,6],[1,2,4],[1,2]]
  9

  > sumlengths = 

> sumlengths = (foldr1 (+)) . (map length)
> noneTrue = foldl ((||).not) False

Prelude> :t foldr map
foldr map :: [b] -> [b -> b] -> [b]
Prelude> :t foldl map

<interactive>:1:6:
    Couldn't match expected type `a -> b' against inferred type `[b]'
    In the first argument of `foldl', namely `map'
    In the expression: foldl map
Prelude> :t foldr1 map

<interactive>:1:7:
    Couldn't match expected type `a -> b' against inferred type `[a]'
    In the first argument of `foldr1', namely `map'
    In the expression: foldr1 map
Prelude> :t foldr1 (+)
foldr1 (+) :: (Num a) => [a] -> a
Prelude> :t foldl fold

<interactive>:1:6: Not in scope: `fold'
Prelude> :t foldl foldl

<interactive>:1:6:
    Couldn't match expected type `b -> [b]' against inferred type `[b]'
    In the first argument of `foldl', namely `foldl'
    In the expression: foldl foldl
Prelude> :t foldl . foldl
foldl . foldl :: (a -> b -> a) -> a -> [[b]] -> a

What is the value of :
   (map . foldl1) (-) [[1,2,3],[3,2,1],[100,200,300]]
    map (\v ->  v [4000,1000]) (map foldr1 [div,(-)])
    map (\f -> f [3,4,5])  (map map [(*) 3,(-) 4])


What is the value of mapmap ? Try and figure it out then run it
 
> mapmap = map (\x-> x [1,2,3])(map map [odd,even])

Prelude> :t foldl . foldl
foldl . foldl :: (a -> b -> a) -> a -> [[b]] -> a
Prelude> (map . foldl1) (-) [[1,2,3],[3,2,1],[100,200,300]]
[-4,0,-400]
Prelude>  map (\v ->  v [4000,1000]) (map foldr1 [div,(-)])
[4,3000]
Prelude>  map (\f -> f [3,4,5])  (map map [(*) 3,(-) 4])
[[9,12,15],[1,0,-1]]
Prelude> map (\x-> x [1,2,3])(map map [odd,even])
[[True,False,True],[False,True,False]]

Prelude> :t (.) foldl
(.) foldl :: (a1 -> a -> b -> a) -> a1 -> a -> [b] -> a
Prelude> :t (.) foldl foldl
(.) foldl foldl :: (a -> b -> a) -> a -> [[b]] -> a


