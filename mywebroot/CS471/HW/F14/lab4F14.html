<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>












<meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>lab 4: Prolog 2</title></head><body>
<h3 style="text-align: center;">Programming Languages<br>
Lab activity 4: Prolog</h3>
Turn in one file prolog file (lab4.pl). Turn in only questions/parts with points.&nbsp; <br>
Due at end of day, Tues, 9/30<br>
<ol>
  <li>(10)Define <span style="font-style: italic;">homoiconic.</span> Is Prolog <span style="font-style: italic;">homoiconic</span>? What does it mean to say a language is <span style="font-style: italic;">fully reflective</span>? Is Prolog <span style="font-style: italic;">fully reflective?&nbsp; <br>
<br>
    </span></li>
  <li>(0)
Try to predict the results of the following queries (you do not need to
include answer in the file you submit.&nbsp; You can use help to remind
you what these predicates do. eg. ?- help(functor).<br>
<br>
  </li>
  <dl style="font-family: monospace; font-weight: bold;">
    <dd>?- functor(foo(a,b,c),F,N).<br>
?- functor(foo(a,b,c),F,N), write('\n'), write(F),write('\nlast write \n.').<br>
?- functor(T,foo,3).<br>
?- arg(3, foo(a,b,c),A).<br>
?- T =.. [foo,x, y, z].<br>
?- foo(who, what) =.. T.<br>
?- foo(who, what) =.. [A, B,C].</dd><dd>?- T =.. [ack, 10, 0, X], assert(T).<br>

?- clause(ack(M,0,B),C).<br>

?- clause(ack(3,0,B),C).<br>
?- write('Hello').<br>
?- write(Hello).<br>
      <br>
    </dd>

  </dl>
  <li>(10)Define a predicate, listOfTerms(ListOfArgs,Name,
ListOfResults),&nbsp; where each term in the ListOfResults is a term
with one argument from the ListOfArgs and the functor name is the
Name. <br>
  </li>
  <dl style="font-family: monospace; font-weight: bold;">
    <dd><br>
?- listOfTerms([[1,2],[a,s,v],[100]],foo,T). <br>
T = [foo(1, 2), foo(a, s, v), foo(100)].<br>
?- listOfTerms([[1,2],[100,99],[5,11]],+,T).<br>
T = [1+2, 100+99, 5+11].<br>
?- listOfTerms(Lst,F,[1+2, 100+99, 5+11]).<br>
Lst = [[1, 2], [100, 99], [5, 11]],<br>
F = + .<br>
      <br>
</dd>
  </dl>
  <li>(0pts) Copy the contents of<a href="http://bingweb.binghamton.edu/%7Ehead/CS471/CODE/PL/ghezzi"> ghezzi</a>
to a file name test.pl.&nbsp; Open this file in swipl and in
emacs.&nbsp; Try to predict the steps need to execute the following query.</li>
  <dl>
    <dd style="font-family: monospace; font-weight: bold;">?- clos(a,g).</dd>
    <dt>At the prompt (in the swipl window) type trace, clos(a,g). eg.</dt>
    <dd><span style="font-family: monospace; font-weight: bold;">?- trace, clos(a,g), notrace, nodebug.</span><br>
</dd>
    <dt>If after each response you type "enter" you will see the exact execution of clos(a,g). <br>
    </dt>
    <dt>Redo using the following query: <span style="font-family: monospace;">trace, clos(a,C), notrace, nodebug</span>.</dt><dt><br>
    </dt>

  </dl>
  <li>(0pts) We will now use graphical debugger for our prolog environment.&nbsp;
There are many ways to get to it -- here is one way.&nbsp;&nbsp; </li>
  <ol style="list-style-type: lower-alpha;">
    <li>Redo question 5 -- except instead use gtrace instead of trace.<br>
<br>
</li>
    <dl style="font-family: monospace; font-weight: bold;">
      <dd>?- gtrace, clos(a,g), notrace, nodebug.<br>
</dd>
    </dl>
<dl>
      <dd><span style="font-family: monospace; font-weight: bold;">?- gtrace, clos(A,f), notrace, nodebug.</span><br style="font-weight: bold;">
<br>
</dd>
      <dt>You should see
another window, which is the graphical debugger.&nbsp; If you have
questions about the different frames in the debugger window please feel
free to ask me during lab.<br>
        <br>
</dt>
    </dl>
  </ol>
  <li>(10pts) Lets explore <span style="font-style: italic;">select</span> built-in predicate.&nbsp; <br>
<br>
</li>
  <ol style="list-style-type: lower-alpha;">
    <li>(0pts) Type the following query:</li>
    <dl>
      <dd><span style="font-family: monospace;">?- help(select).<br>
?- select(c, [a,b,c,d,e], R).<br>
        </span><span style="font-family: monospace;">?- select(c, [a,b,X,d,e], R).</span><br>
        <span style="font-family: monospace;">?- select(c, R, </span><span style="font-family: monospace;">[a,b,d,e]</span><span style="font-family: monospace;">).</span> % use the ";" instead of return<br>
        <br>
      </dd>
    </dl>
    <li>(10pts) Define <span style="font-style: italic;">insert</span>(<span style="font-style: italic;"> ?Elem, ?Lst, ?LstWithElem</span>) using only the builtin predicate <span style="font-style: italic;">select.&nbsp; insert </span>succeeds <span style="font-style: italic;"><span style="font-style: italic;"></span></span><span style="font-style: italic;"></span>if the only difference between&nbsp; <span style="font-style: italic;">Lst</span> and <span style="font-style: italic;">LstWithElem <span style="font-style: italic;"><span style="font-style: italic;"></span></span></span>is<span style="font-style: italic;"><span style="font-style: italic;"><span style="font-style: italic;"></span></span> LstWithElem </span>includes <span style="font-style: italic;">Elem.&nbsp; i.e.</span></li>
    <dl>
      <dd><span style="font-family: monospace; font-weight: bold;">?- insert(c,[a,b,d,e],[a, c, b, d, e]).</span><br style="font-family: monospace; font-weight: bold;">
        <span style="font-family: monospace; font-weight: bold;">true .</span><br style="font-family: monospace; font-weight: bold;">
        <br style="font-family: monospace; font-weight: bold;">
        <span style="font-family: monospace; font-weight: bold;">?- insert(c,[a, b, d, e],[a, b, c, d, e]).</span><br style="font-family: monospace; font-weight: bold;">
        <span style="font-family: monospace; font-weight: bold;">true .</span><span style="font-style: italic;"><br>
</span></dd>
    </dl>
  </ol><dl><dd><br>
    </dd>
  </dl>

  <li>[10pts]&nbsp; A student submitted the following solution for HW 3 exercise 1:<br>
    <br style="font-weight: bold;">
</li>
  <dl>
    <dd>
      <div style="font-family: monospace; font-weight: bold;">convertToDecimal(A,0).&nbsp;</div>
      <div style="font-family: monospace; font-weight: bold;">convertToDecimal(succ(S), Y) :-
	numeral(S),
	Y1 is Y-1,
	convertToDecimal(S, Y1).&nbsp;</div>
      <br>
    </dd>
  </dl>
  <ol style="list-style-type: lower-alpha;">
    <li>[8pts] Explain why the following query gives the result it does:<br>
      <span style="font-family: monospace; font-weight: bold;">?- convertToDecimal(succ(succ(0)),N). </span><br>
    </li>
    <li>[2pts] How would you fix it?<br>
      <br>
    </li>
  </ol>
  <li>(0) Type
manpce at the prompt.&nbsp; You should see a pop-up window (the icon is
books). In the "Browsers" pull down menu select "Prolog&nbsp;
manual".&nbsp; Another window will open which will allow us to browse
the Prolog manual.&nbsp; Click on the "+" next to "Built-in predicates"
-- this will open sub-menu.&nbsp; Clicking on the words "Built-in
predicates" opens the manual page.&nbsp;</li>


  <dl>
    <dd>On the
bottom of this window you will see the label "On:" , type "number" and
enter in the next box.&nbsp; You should see the specification of <span style="font-style: italic;">number </span>in the manual page frame on the right.&nbsp; Repeat this for <span style="font-style: italic;">atom.<br>
      <br>
</span></dd></dl>
  
  <li>(10pts) (From Learn Prolog NOW! exercise 3.3)&nbsp; Binary trees
are trees where all internal nodes have exactly two children. The
smallest binary trees consist of only one leaf node. We will represent
leaf nodes as leaf(Label). For instance, leaf(3) and leaf(7) are leaf
nodes, and therefore small binary trees. Given two binary trees B1 and
B2 we can combine them into one binary tree using the predicate tree:
tree(B1,B2). So, from the leaves leaf(1) and leaf(2) we can build the
binary tree tree(leaf(1), leaf(2)). And from the binary trees
tree(leaf(1), leaf(2)) and leaf(4) we can build the&nbsp; * binary tree,
tree(tree(leaf(1), leaf(2)), leaf(4)).<br>
Now, define a predicate swap/2, which produces a mirror image of the binary tree that is its first argument. For example:<br>
&nbsp;&nbsp;<span style="font-family: monospace; font-weight: bold;">&nbsp; ?- swap(tree(tree(leaf(1), leaf(2)), leaf(4)),T).</span><br style="font-family: monospace; font-weight: bold;"><span style="font-family: monospace; font-weight: bold;">
&nbsp;&nbsp; T = tree(leaf(4), tree(leaf(2), leaf(1))).</span><br style="font-family: monospace; font-weight: bold;"><span style="font-family: monospace; font-weight: bold;">
&nbsp;&nbsp;&nbsp; true</span><br>
<br>
2 clauses<br>
    <br>
    <br>
  </li>

  <li>(10pts) Given a tree, define a predicate equivT(Tree,ETree), that success
if Tree and ETree have the same structure and all the corresponding
leaves have equivalent values. Use the tree definition from above
problem (#9). <br>
&nbsp;(2 clauses)<br>
    <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family: monospace; font-weight: bold;">?- equivT(tree(tree(leaf(1), leaf(2)),leaf(3)), tree(leaf(1), leaf(2))).</span><br style="font-family: monospace; font-weight: bold;"><span style="font-family: monospace; font-weight: bold;">
&nbsp;&nbsp;&nbsp;&nbsp; false.</span><br style="font-family: monospace; font-weight: bold;"><span style="font-family: monospace; font-weight: bold;">
&nbsp;&nbsp;&nbsp;&nbsp; ?- equivT(tree(tree(leaf(1), leaf(2)),leaf(3)), tree(tree(leaf(1), leaf(2)),leaf(3))).</span><br style="font-family: monospace; font-weight: bold;"><span style="font-family: monospace; font-weight: bold;">
&nbsp;&nbsp;&nbsp;&nbsp; true.</span><br style="font-family: monospace; font-weight: bold;"><span style="font-family: monospace; font-weight: bold;">
&nbsp;&nbsp;&nbsp;&nbsp; ?- equivT(tree(tree(leaf(1), leaf(2)),leaf(3)), tree(tree(leaf(1), leaf(2)),leaf(10))).</span><br style="font-family: monospace; font-weight: bold;"><span style="font-family: monospace; font-weight: bold;">
&nbsp;&nbsp;&nbsp;&nbsp; false.</span><br style="font-family: monospace;">
    <br>
    <br>
</li>
  <li>(10pts)Explain the result of the follow query:<br>
    <span style="font-family: monospace; font-weight: bold;">..?-&nbsp; A=B, not(not(A=apple)), B=what.</span><br>
    <br>
  </li>
  <li>(0pts) Prolog is a great language to solve puzzles.&nbsp; Below
is a solution to the "Send more money puzzle".&nbsp; Type the program
into your .pl file.&nbsp; Execute the program (i.e.)<br>
    <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ?- solv(L).<br>
    <br>
Make sure you understand how Prolog solves "Send more money puzzle" and
observe how long it takes to execute.&nbsp; Why do you think it takes
so long?<br>
    <br>
/** "Send more money" is a well-known puzzle. Each of the letters<br>
&nbsp;&nbsp;&nbsp; D,E,M,N,O,R,S and Y represents a different digit. Moreover, when each<br>
&nbsp;&nbsp;&nbsp; letter is mapped to its corresponding digit the equation SEND + MORE =<br>
&nbsp;&nbsp;&nbsp; MONEY holds. Below is a very naive implementation. */<br>
<br>
    solv( [D,E,M,N,O,R,S,Y]) :-<br>
&nbsp;&nbsp;&nbsp; Lst = [S,E,N,D,M,O,R,Y],<br>
&nbsp;&nbsp;&nbsp; Digits = [0,1,2,3,4,5,6,7,8,9],<br>
&nbsp;&nbsp;&nbsp; assign_digits(Lst, Digits),<br>
&nbsp;&nbsp;&nbsp; M &gt; 0, <br>
&nbsp;&nbsp;&nbsp; S &gt; 0,<br>
&nbsp;&nbsp;&nbsp; 1000*S + 100*E + 10*N + D +<br>
&nbsp;&nbsp;&nbsp; 1000*M + 100*O + 10*R + E =:=<br>
&nbsp;&nbsp;&nbsp; 10000*M + 1000*O + 100*N + 10*E + Y.<br>
    <br>
assign_digits([], _List).<br>
assign_digits([D|Ds], List):-<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; select(D, List, NewList),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assign_digits(Ds, NewList).<br>
    <br>
  </li>

  <dl>

  
  </dl>
</ol><br>
<ol>

  <dl>
    <dd><br>
    </dd>
  </dl>
  <dl>
    <dd><br>
      <br>
    </dd>
  </dl>
</ol>

<br>
</body></html>