<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>









  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>Haskell Lab 2 and HW 2</title><meta http-equiv="content-type" content="text/html; charset=utf-8"></head><body>
Haskell Lab 2<br>

You may use either HUGS or GHCi for the assignments.<br>

<br>

You should add you code to <big><a style="font-weight: bold;" href="LabH2S15.lhs">LabH2S15.lhs</a></big><br>

<span style="font-family: monospace; font-weight: bold;"></span><span style="font-weight: bold;"><span style="font-weight: bold;"><br>
Part 1 Data types</span></span><br>
<ol>

  
  
  <li>[10pts] EASY The Point datatype is defined as follow<br>
    <span style="font-family: monospace; font-weight: bold;">&gt; data Point a = Pt a a deriving (Show, Eq) </span><br>
(I will explain deriving in class this week.)</li>
  <ol>
    <li>&nbsp;Now define a function "isOrigin" that returns true if the point is the origin&nbsp; and false otherwise.&nbsp; <br>
      <span style="font-family: monospace; font-weight: bold;">&nbsp;....&gt; isOrigin (Pt 0 0)</span><br style="font-family: monospace; font-weight: bold;">
      <span style="font-family: monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; True&nbsp; </span><br style="font-family: monospace; font-weight: bold;">
      <span style="font-family: monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; ....&gt; isOrigin (Pt 3.0 0.0)</span><br style="font-family: monospace; font-weight: bold;">
      <span style="font-family: monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; False&nbsp;&nbsp;&nbsp;</span></li>
    <li>Redefine isOrigin (name it isOriginL) using lambda expression only.&nbsp; <br>
      <br>
    </li>
  </ol>
  <li>[10pts]EASY Write a Haskell function "inside point r " which returns
true if
and only if the point lies inside a circle of radius r and false
otherwise.&nbsp; <br>
&nbsp;"<span style="font-style: italic;">inside</span>" can be defined
as: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inside r point (x, y) is
true&nbsp; if and only if x^2 + y^2 &lt; r^2 <br>
where x and y are the coordinates of the point. <br>
Your Haskell code should not be using tuples.
If your contructor for Point is Pt then to execute you type:</li>

  <dl>
    <dd style="font-family: monospace; font-weight: bold;">Lab2&gt;
inside 10.0 (Pt 3.0 2.5) <br>
True <br>
Lab2&gt; inside 10.0 (Pt (-1) (-2)) <br>
    </dd>
    <dd><span style="font-family: monospace; font-weight: bold;">True&nbsp;
      </span><br style="font-family: monospace; font-weight: bold;">
      <span style="font-family: monospace; font-weight: bold;">Lab2&gt;
inside 2.0 (Pt 3.0 2.5) </span><br style="font-family: monospace; font-weight: bold;">
      <span style="font-family: monospace; font-weight: bold;">False&nbsp;
      <br>
      </span></dd>
    <dd><br>
      <span style="font-family: monospace; font-weight: bold;"></span></dd>
  </dl>
  <span style="font-weight: bold;"></span>
  <div style="margin-left: 40px;"><span style="font-weight: bold;"></span></div>
</ol>

<span style="font-weight: bold;">Part 2 Recursion:</span><br>

<ol>

  <li>[10pts]Write a recursive definition, <span style="font-style: italic;">mul x y</span>, that returns the product <span style="font-style: italic;">x*y.</span> <br>
(Do not use "*" operator.)<br>
    <br>
  </li>
  <li>[10 pts]Write
a Haskell script which implements Ackermann's function as defined
in homework 1 problem 7.&nbsp; Name your script "ack".&nbsp; You may
use guards, and/or pattern matching and/or if expressions in your
definition.&nbsp; Predict the inferred type of ack.&nbsp; Check
you guess. <br>
    <table style="width: 600px; height: 89px; margin-left: 40px;">
      <tbody>
        <tr>
          <td style="font-weight: bold;">ack( <i>m,n</i>
) =</td>
          <td style="font-weight: bold;">2 * <span style="font-style: italic;">n</span><br>
          </td>
          <td style="font-weight: bold;">if <i>m</i>
= 0</td>
        </tr>
        <tr>
          <td style="vertical-align: top;">ack( <i>m,n</i>
) =</td>
          <td style="vertical-align: top;"><span style="font-weight: bold;">0</span><br>
          </td>
          <td style="vertical-align: top;"> if <span style="font-style: italic;">n</span> = 0 and&nbsp;<span style="font-style: italic;">m&nbsp;</span>&gt;
0&nbsp;<br>
          </td>
        </tr>
        <tr>
          <td style="font-weight: bold;">ack( <i>m,n</i>
) =&nbsp;</td>
          <td style="font-weight: bold;"><span style="font-weight: bold;">2</span><span style="font-style: italic;"></span><br>
          </td>
          <td style="font-weight: bold;">if <span style="font-style: italic;">n</span> = 1 and&nbsp;<span style="font-style: italic;">m&nbsp;</span>&gt;
0&nbsp;</td>
        </tr>
        <tr>
          <td style="font-weight: bold;">ack( <i>m,n</i>
) =</td>
          <td style="font-weight: bold;">ack( <i>m</i>-1,
ack( <i>m, n</i>-1 ) ) &nbsp; &nbsp; &nbsp;</td>
          <td style="font-weight: bold;">otherwise<span style="font-style: italic;"></span><span style="font-style: italic;"></span></td>
        </tr>
      </tbody>
    </table></li>
</ol><span style="font-weight: bold;">Part 3 Tail Recursion</span><br>
<br>


<div style="text-align: left; height: 60px;"><big><span style="font-weight: bold;">Code
for the questions below is supplied in </span><br style="font-weight: bold;">
</big>
<div style="margin-left: 40px;"><big><a style="font-weight: bold;" href="LabH2S15.lhs">LabH2S15.lhs</a></big><br style="font-weight: bold;">
</div>
<big><span style="font-weight: bold;">
</span></big><br>
</div>

1) Our example is the exponentiation function, which raises a
number
to a positive integer power. Here is a very simple implementation: <br>


<ol>

  <span style="font-family: monospace; font-weight: bold;">&gt; power
:: Integer
-&gt; Integer -&gt; Integer&nbsp;&nbsp;</span><span style="font-weight: bold;">&nbsp;&nbsp; </span><br style="font-weight: bold;">
  <span style="font-family: monospace; font-weight: bold;">&gt; power a
0 = 1&nbsp;</span><span style="font-weight: bold;">&nbsp;</span><span style="font-family: monospace; font-weight: bold;">&nbsp;&nbsp;
  <br>
  </span><span style="font-family: monospace;"><span style="font-weight: bold;">&gt;
power a b = a *
power a (b-1)</span><br>
  </span><span style="font-family: monospace;"><br>
  </span>
</ol>

<ol style="list-style-type: lower-alpha; margin-left: 40px;">

  <li>[5pts] Show the steps in the evaluation of the expression<span style="font-family: monospace; font-weight: bold;"> power 2 5</span>,&nbsp;
making sure not to
reduce any subexpression prematurely.
How do the time and maximum space
required by the
evaluation of <span style="font-family: monospace;">power
n k</span>
depend on <span style="font-style: italic;">n </span>and <span style="font-style: italic;">k</span>?
&nbsp;What is the time complexity of <span style="font-style: italic;">power?<br>
    </span><br>
    <br>
  </li>
  <li>[5pts] Because of lazy evaluation, the definition of <span style="font-family: monospace; font-weight: bold;"><span style="font-style: italic;">power</span></span> accumulates of
pending
multiplications. It is inherent in the way power is
defined&#8212;
each multiplication has to wait until its right argument has been
evaluated.<br>
  </li>
One way to eliminate the multiplication delay is to convert
the function&#8217;s definition to a tail-recursive implementation: <br>
  <br>
  <span style="font-family: monospace; font-weight: bold;">&gt; powerT
:: Integer -&gt;
Integer -&gt; Integer</span><br style="font-family: monospace; font-weight: bold;">
  <span style="font-family: monospace; font-weight: bold;">&gt; powerT
a b = trp b 1</span><br style="font-family: monospace; font-weight: bold;">
  <span style="font-family: monospace; font-weight: bold;">&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
where</span><br style="font-family: monospace; font-weight: bold;">
  <span style="font-family: monospace;"><span style="font-weight: bold;">&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
trp n p = if (n==0) then p else trp (n-1) (a*p)</span><br>
  </span><br style="font-family: monospace;">
Show the steps in the evaluation of the expression <span style="font-family: monospace; font-weight: bold;">powerT 2 5</span>,
making sure not to
reduce any subexpression prematurely.&nbsp;&nbsp; <br>
  <br>
  <br>
  <li><span style="font-family: monospace;"></span>[5pts]Convert the
powerT to an iterative form (while loop) using the <a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/2HrF10.html">conversion</a>
technique discussed in class.<br>
    <br>
  </li>
</ol>

2) In the exercise above we improved power&#8217;s space
performance, but both take time linear in the exponent argument.<br>
<ol style="list-style-type: lower-alpha;">

  <li>[5pt]Here is an algorithm which improves both time and
space
performance:</li>
  <dd style="margin-left: 80px; font-weight: bold;"><span style="font-family: monospace;"><br>
&nbsp; &nbsp; &gt;
turboPower a 0 = 1 <br>
&nbsp; &nbsp; &gt; turboPower a b <br>
&nbsp; &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp;
| even b = turboPower
(a*a) (b `div` 2) <br>
&nbsp; &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp;
| otherwise = a *
turboPower a (b-1)</span></dd>
  <dd><span style="font-family: monospace; font-weight: bold;"></span><br>
  </dd>
Instead of merely decrementing its first argument, this
algorithm
halves it whenever it is even, thereby reaching termination much more
quickly. What is the complexity of this algorithm? <span style="font-family: monospace;"><br>
  </span><br>
  <span style="font-family: monospace;"></span><span style="font-family: monospace;"></span>
  <li>[10pts] Convert <span style="font-style: italic; font-family: monospace;">turboPower</span><span style="font-style: italic;">&nbsp; </span>to a tail recursive version
-- call you new version&nbsp;<span style="font-family: monospace; font-weight: bold;">turboPowerT.&nbsp; </span>What
is the complexity of this algorithm? <span style="font-style: italic;">
    </span></li>
  <br>
</ol>

<span style="font-weight: bold;"></span><span style="font-weight: bold;">Part 4<br>
</span>
<ol></ol>


<ol>
  <li>[10pt] List comprehension notation is defined as follows <br>
&nbsp;[&lt;expr&gt; | &lt;generators&gt; ]<br>
    <br>
where &lt;expr&gt; is an expression,&nbsp; and &lt;generators&gt; is a generator<br>
and the notation denotes a finite or infinite list.<br>
    <br>
For example the function, lc, below converts a list of items to a list of tuples of the item using list comprehension technique.<br>
    <br>
&gt; lc lst = [(n,n) | n &lt;- lst]<br>
    <br>
The symbol "&lt;-" reads as "belongs to" "x &lt;- xs"&nbsp; is called the generator.<br>
The symbol "|" reads as such that <br>
    <br>
Define a function add10 that takes a list of numbers and builds a list <br>
of with 10 added to each number in the origin list.<br>
    <br>
i.e.<br>
&nbsp;&nbsp;<span style="font-family: monospace; font-weight: bold;">&nbsp;&nbsp; ... &gt; add10&nbsp; [1,4,9]</span><br style="font-family: monospace; font-weight: bold;">
    <span style="font-family: monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp; ...&gt;&nbsp; [11,14,19]</span><br>
  </li>
  <li>[10pts] Tree below is a data type used to build a binary tree. and tree1 is an example of a tree.<span style="font-family: monospace; font-weight: bold;"><br>
&gt; data Tree a = Leaf&nbsp; | Node a (Tree a) (Tree a) deriving Show<br>
&gt; tree1 = Node 5 (Node 10 Leaf (Node 12 Leaf Leaf) ) Leaf<br>
    <br>
    </span>&nbsp;Define toList which changes a tree to a list.&nbsp;
You may use "++". What are your assumptions?&nbsp; Can you predict the
most general type of toList?<br>
    <span style="font-family: monospace; font-weight: bold;"><br>
&nbsp;&nbsp;&nbsp; ...&gt; toList tree1<br>
&nbsp;&nbsp;&nbsp; [10,12,5]<br>
<br>
    </span></li>
  <li>[10 pts] Define toList which changes a list to a tree.  You may use "drop", "take"
and "length". What are your assumptions?  Can you predict the most general type of toTree?

    <br>
    <br>
    <div style="margin-left: 40px;"><span style="font-family: monospace; font-weight: bold;">...&gt; fromList [0,1,2,3,4]
    </span><br style="font-family: monospace; font-weight: bold;">
    <span style="font-family: monospace; font-weight: bold;">Node 0 (Node 1 Leaf (Node 2 Leaf Leaf)) (Node 3 Leaf (Node 4 Leaf Le</span>af))
    <br class="Apple-interchange-newline">
    </div>
  </li>

</ol>


</body></html>