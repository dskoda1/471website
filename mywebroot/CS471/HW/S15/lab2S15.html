<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-us"><head>




  
  <meta content="text/html; charset=UTF-8" http-equiv="content-type" /><title>Lab 2</title></head><body>
<div style="text-align: center;">
<h3>Programming Languages<br />
Lab activity 2<br />
</h3>
</div>

<span style="font-weight: bold;">PART 1</span><br />

<ol>

  <li>(0pts)&nbsp; <a href="lab2/Fig4_12R.c">Fig4_12R.c</a> is a program
that will
evaluate expressions.&nbsp; The Fig4_12R binary created by the Makefile will read a string from 
standard input (the terminal) to interpret. &nbsp;Look at the code to get an 
idea of what it is doing. Using the make utility and this <span style="text-decoration: underline;"> </span><a href="lab2/Makefile">Makefile</a>'s
target XQTR,
compile and execute this program. e.g.<br />
  </li>
  <dl style="font-family: monospace; font-weight: bold;">
    <dd>$ make XQTR<br />
gcc -std=c99 -Wall -o Fig4_12 Fig4_12.c<br />
./Fig4_12&nbsp;&nbsp;&nbsp; <br />
2 + 4 * 3 + 1<br />
The result is: 15<br />
      <br />
    </dd>
  </dl>
  <li>(10pts)The comment above each function in <a href="lab2/Fig4_12R.c">Fig4_12R.c</a>
includes the rules in BNF.&nbsp; <br />
  </li>
  <ol style="list-style-type: lower-alpha;">
    <li>On a piece
of paper write (or in the text editor) the grammar rules down (You may
consider numbers as terminal symbols for this part.) Notice that
terminal symbols (operators) are 'match'ed and then used to calculate
the result, terminal symbols (digits)&nbsp; are used to build the
numbers and non-terminal symbols are function calls.&nbsp;&nbsp; <br />
    </li>
    <li>From the grammar can you determine the precedence of the
operators, + and * ?&nbsp; Highest means tightest bound.&nbsp; <br />
    </li>
    <li>Parenthesize the following expressions according to the rules
of the grammar: <br />
    </li>
    <ol>
      <li style="font-family: monospace;">3 + 5 * 7<br />
</li>
      <li><span style="font-family: monospace;">3 * 5 * 7</span><br />
</li>
    </ol>
    <li>Using the grammar rules from 2.a write the left derivation for 2.c.1 and 2.c.2<br />
      <br />
    </li>
  </ol>
  <li>(10pts) Add an average (@) operator to your grammar. &nbsp;Average should have the 
highest precedence of all operators in your grammar, and should have the
 same associativity as + and *.
  </li>
  <ol style="list-style-type: lower-alpha;">
    <li>What changes need to be made to the grammar itself for @?
    </li>
    <li>Parenthesize the following expressions according to the rules
of the grammar: </li>
    <ol style="font-family: monospace;">
      <li>10 + 20 + 30</li>
      <li>10 @ 20 * 2 @ 6<br />
      </li>
      <li><span style="font-weight: bold;">2 @ 10 + 51 @ 5</span></li>
    </ol>
    <li>What is the associativity of "+", "*",&nbsp; and "@" ?<br />
    </li>
  </ol>
  <dl>
    <dd><br />
      <br />
    </dd>
  </dl>
  <li>(10pts)Modify <a href="lab2/Fig4_12R.c">Fig4_12R.c</a>
add the code to include "@" operator. Submit only the changes to the code. Remember the
general idea for converting a grammar to a code is<br />
  </li>
  <ul>
    <li>&nbsp;non-terminals are
function calls <br />
    </li>
    <li>"match" terminals</li>
  </ul>
  <dl>
    <dt>eg.<br style="font-family: monospace;" />
      <span style="font-family: monospace; font-weight: bold;">&nbsp;
&nbsp;&nbsp; $ make XQTR<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: monospace;">gcc -o Fig4_12R -std=c99
-Wall Fig4_12R.c</span><br />
      <span style="font-family: monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;
./Fig4_12R<br />
&nbsp;&nbsp;&nbsp;&nbsp; 3 @ 2 @ 20 + 10<br />
&nbsp;&nbsp;&nbsp;&nbsp; The result is: 17<br />
      </span><span style="font-family: monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;
$ make XQTR</span><span style="font-family: monospace;"><br />
      <span style="font-family: monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;
./Fig4_12R<br />
&nbsp;&nbsp;&nbsp;&nbsp; 4 @ 2 @ 20 + 10<br />
&nbsp;&nbsp;&nbsp;&nbsp; The result is: 17</span><br />
    
  </span></dt></dl>
</ol>

<ol>

  <dl>
    <dt><span style="font-family: monospace; font-weight: bold;">&nbsp;
&nbsp;&nbsp; $ make XQTR<br /></span><span style="font-family: monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;
./Fig4_12R<br />
&nbsp;&nbsp;&nbsp;&nbsp; 3 @ 2 @ 20 * 10<br />
&nbsp;&nbsp;&nbsp;&nbsp; The result is: 70</span><br />
      <span style="font-style: italic;"><span style="font-family: monospace; font-weight: bold;"><span style="font-style: italic;"><br />
      <span style="font-family: monospace; font-weight: bold;"><span style="font-style: italic;"><span style="font-family: monospace; font-weight: bold;"><span style="font-style: italic;"> </span></span> </span></span></span></span>
  </span></dt></dl>
  <span style="font-weight: bold;">
</span>
</ol>

<span style="font-weight: bold;">PART 2</span><br />

<ol>

  <li>(0pts)<a href="lab2/Fig4_12.c">Fig4_12.c</a>
is another program that evaluates expressions.&nbsp; Using the make
utility and this <span style="text-decoration: underline;"> </span><a href="lab2/Makefile">Makefile</a>'s
target XQT,
compile and execute this program. e.g.</li>
  <dl>
    <dd><span style="font-family: monospace;">$ make XQT<br />
./Fig4_12&nbsp;&nbsp;&nbsp; <br />
2 + 4 * 3 + 1<br />
The result is: 15</span></dd>
    <dd><br />
    </dd>
  </dl>
  <li>(10pts)The comment above each function in <a href="lab2/Fig4_12.c">Fig4_12.c</a>
includes the grammar rules in BNF followed by the same rule using EBNF <br />
  </li>
  <ol style="list-style-type: lower-alpha;">
    <li>On a piece of paper write BNF grammar rules down (You may
consider numbers as terminal symbols for this part.) Notice that
terminal symbols (operators) are 'match'ed and then used to calculate
the result, terminal symbols (digits)&nbsp; are used to build the
numbers and non-terminal symbols are function calls.&nbsp;&nbsp; <br />
    </li>
    <li>From the grammar can you determine the precedence of the
operators, + and * ?&nbsp; Highest -&gt; tightest bound.&nbsp; <br />
    </li>
    <li>Parenthesize the following expressions according to the rules
of the grammar: <br />
    </li>
    <ol>
      <li style="font-family: monospace;">3 + 5 * 7<br />
      </li>
      <li><span style="font-family: monospace;">3 * 5 * 7</span></li>
</ol>
    <li>Using the BNF rules in 2.a, write the left derivation for the
expressions in 2.c1 and 2.c.2.<br />
      <br />
    </li>
  </ol>
  <li>(10pts) Add an average (@) operator to your grammar. &nbsp;Average should have&nbsp; <span style="font-weight: bold; text-decoration: underline;">lower
precedence than "*" and higher precedence than "+"</span>, and should have the
 same associativity as + and *.
  </li>
  <ol style="list-style-type: lower-alpha;">
    <li>What changes need to be made to the grammar itself for @?
    </li>
    <li>Parenthesize the following expressions according to the rules
of the grammar: </li>
    <ol style="font-family: monospace;">
      <li>10 + 20 + 30</li>
      <li>10 @ 20 * 2 @ 6<br />
      </li>
      <li><span style="font-weight: bold;">2 @ 10 + 51 @ 5</span></li>
    </ol>
    <li>What is the associativity of "+", "*",&nbsp; and "@" ?<br />
      <br />
    </li>
  </ol>
  <li>(10pts)Modify <a href="lab2/Fig4_12.c">Fig4_12.c</a>
add the code to include "@" operator.&nbsp; Submit only the changes to the code.&nbsp; Remember the
general idea for converting a grammar to code is<br />
  </li>
  <ul>
    <ul>
      <li>&nbsp;non-terminals are
function calls <br />
      </li>
    </ul>
    <ul>
      <li>"match" terminals</li>
    </ul>
  </ul>
However for this grammar the above strategy will cause
problems.&nbsp; Which type of recursive grammar rule causes the problem
and why?&nbsp; Examining the code you see that EBNF suggests a
solution, replace recursive calls with <span style="font-style: italic;">while loops</span>.&nbsp; Below is an
example output.<br />
  <dl>
    <div style="margin-left: 40px;"><span style="font-family: monospace;">$ make XQT</span><br style="font-family: monospace;" />
    <span style="font-family: monospace;">gcc -o Fig4_12B -std=c99
-Wall
Fig4_12.c</span><br style="font-family: monospace;" />
    <span style="font-family: monospace;">./Fig4_12</span><br style="font-family: monospace;" />
    <span style="font-family: monospace;">3 @ 2 @ 20 + 10</span><br style="font-family: monospace;" />
    <span style="font-family: monospace;">The result is:&nbsp; 21 </span><br />
    </div>
&nbsp;
    <li>(10pts) Download this <a href="lab2/RubyRE.rb">Ruby
code</a>&nbsp; into the directory in which you downloaded <a href="../../../%7Ehead/CS471/HW/lab2/Fig4_12.c">Fig4_12.c</a>,
make the Ruby code executable, and run it. Notice that the Ruby code
produces a new file called "Names.txt". Browse through the Ruby code to
see what is going on. You might find these <a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/GRAMMAR/RubyD.html">brief notes</a> helpful. Other helpful resources are "<a href="http://www.wellho.net/solutions/php-pattern-matching-a-primer-on-regular-expressions.html">Pattern
Matching - a primer on regular Expressions</a>" and "<a href="http://media.pragprog.com/titles/ruby3/ruby3_extract_regular_expressions.pdf">Regular
Expressions from PickAxe</a>".
Now, modify the Ruby code to extract all the arguments to the "match"
function invocations in Fig4_12.c. These arguments are the text inside
the parenthesis of a string that starts with "match", followed
immediately by an open parenthesis ('('), and terminated by a close
parenthesis (')'). Hint - you will have to escape parenthesis in your
regular expression to have them treated as literal matching characters
instead of grouping indicators. Note - the results may include the
argument definition in the prototype or definition of the match
function. <br />
      <br />
When you turn in your lab, include the resulting file that shows both
your modified regular expression, and the arguments to "match" that you
found.
<br />
    </li>
  </dl>
</ol>

<br />

<br />

</body></html>