/*******************************************************************
        CS471 - Programming Languages
        Assignment #<number> due: <DATE>
        Author: <LastName>, <FirstName> (<EMail>)
        Date: <DATE>
*****************************************************************/
/*1: The following Finite State machine accepts all even parity "strings". 
     Write a Prolog program that accept all valid strings in the language. 
     We will represent the strings as a list of atoms.  
Sigma = { 0,1 }, Start state = {q0},  Final state = { q0,q1 }, and
    delta(q0,0) = q1
    delta(q0,1) = q3
    delta(q1,0) = q0
    delta(q1,1) = q2
    delta(q2,0) = q3
    delta(q2,1) = q1
    delta(q3,0) = q2
    delta(q3,1) = q0.

    You are provided with the final state and start state. You need to provide the "delta facts".
    Remember you will need to define deltaHat(Q1,Str).  The definition of deltaHat is:
    deltaHat(Q,[]) = Q (Our program will represent the empty string as the empty list).
    deltaHat(Q, [C|Cs]) = deltaHat(delta(Q,C),Cs).  (You will have convert delta and deltaHat
    from functional notation to relational notation.)  accept/1 also needs to be define.

A string is accepted if deltaHat(q0, String) is in a final state (q0 or q1).

    ?- accept([0,0,0,0,1,1,1,1,0,1,1]).
    Yes
    ?- accept([0,0,0,0,1,1,1,1,1]).
    No
    ?- accept([0,0,0,0,1,1,1,1,1,1]).
    Yes
    ?- accept([0,0,1,1,0,0,1,1,1,1,1,1]).
    Yes
    ?- accept([0,0,0,0,1]).
    No
    ?- accept([1,1,1,0,1,0,1,0,1,0]).
   Yes
*/

% 1. FSM -- 
%    

final(q0).
final(q1).
start(q0).



/* 2: Define a predicate "simplity/3" that succeeds if the last arguement is 
      a list with items with the form Var:Value,  
      the first argument is a "var" atom in the list and 
      the second argument is the var's Value.  Requires only one clause.
      (hint::member, atom).
      ?- simplify(b,Value,[a:100,b:(-5)]).
      Value = -5
      ?- simplify(b,Value,[a : 1,b : 5, c : 10]).
      Value = 5 .
      */

      
/* 3: Now extend predicate "simplity/3" to  evaluates an algebraic expression.
   The algebraic expression consists of variable with operators 'plus', 
   'minus' and 'times'. Here are two test queries:
          ?- simplify(plus(times(x,y),times(3 ,minus(x,y))),V,[x:4,y:2]).
          V = 14
          ?- simplify(times(2,plus(a,b)),Val,[a:1,b:5]).
          Val = 12
          ?- simplify(times(2,plus(a,b)),Val,[a:1,b:(-5)]).
          Val = -8 .
    Requires only a total 5 clauses including the clause from %2.  
    You may use "number" in one of your clauses.      
*/




%3: value(+Coin, +Num, ?Amt)
/* Below is a database of US coins. */

coin(dollar, 100).
coin(half, 50).
coin(quarter, 25).
coin(dime,10).
coin(nickel,5).
coin(penny,1).

/* 3: Write a predicate, value(Coin, Num, Amt), where Coin is the name,
      Num is how many and Amt is the total value, 
     (the value of the coin (in pennies) times the number of coins. )
     You should use the facts created in question 1 as
      as subgoal to find the value in pennies of the coin.
        ?- value(quarter,5, Amt).
        Amt = 125
        ?- value(dime,10, 100).
        Yes
        ?- value(dime,N, 100).
        ERROR: is/2: Arguments are not sufficiently instantiated
 */



%4. sumL(N,S).
/* Is simular to prodR(+N,?S), except that sum totals
   accumulate left to right. e.g. The first value in S will be N,
   the second value will be N + N-1, etc.

     ?-sumL(6,S).
     S = [6, 11, 15, 18, 20, 21, 21]

    It would be helpful to overload sumL/2 and include the following
    clause:

       sumL(N,Lst):-sumL(N,N,Lst).

    2 additional clauses.

*/




/* 5: (Do not turn in. Practice for the test.)
   Given the 4 logically equivalent predicates try to predict the outcome of 
   ?- subList1(X,[a]),fail.
   ?- subList2(X,[a]),fail.
   ?- subList3(X,[a]),fail.
   ?- subList4(X,[a]),fail.
   Try to understand why some produce "ERROR: Out of global stack"

*/ 

subList1(S,L):-append(_,S,P),append(P,_,L).
subList2(S,L):-append(P,_,L),append(_,S,P).
subList3(S,L):-append(S,_,T),append(_,T,L).
subList4(S,L):-append(_,T,L),append(S,_,T).

/* Using writes to see the backtracking */

subList1w(S,L):-write('1-1'),append(_,S,P),write(' 1-2'),write(P),append(P,_,L).
subList2w(S,L):-write('2-1'),append(P,_,L),write(' 2-2'),write(P),append(_,S,P).
subList3w(S,L):-write('3-1'),append(S,_,T),write(' 3-2'),write(T),append(_,T,L).
subList4w(S,L):-write('4-1'),append(_,T,L),write(' 4-2'),write(T),append(S,_,T).


