<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>Week 14</title></head><body>Week 14 --<br>Read Scott Chapter 10.<br><br>Other resources:<br>
<ul><li><a href="http://www.inf.ed.ac.uk/teaching/courses/inf1/fp/competition/2008/competition.html">2008 Inf1&#8211;FP Programming Competition Entries</a></li><li><a href="http://en.wikipedia.org/wiki/List_comprehension">List Comprehension&nbsp;</a></li><li><a href="http://sneezy.cs.nott.ac.uk/fun/nov-06/FunPm.ppt">C# is a Functional Programming Language (slides)</a></li><li><a href="http://www.youtube.com/watch?v=faJ8N0giqzw&amp;sdig=1">Tangible Functional Programming (You Tube)</a></li></ul><br>Here is the definition of "foldr" that is in <br>&nbsp; "C:\Program Files\Hugs98\lib\Prelude.hs"<br><br><span style="font-family: monospace;">&nbsp; foldr f z []&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = z</span><br style="font-family: monospace;"><span style="font-family: monospace;">&nbsp; foldr f z (x:xs)&nbsp; = f x (foldr f z xs)</span><br style="font-family: monospace;"><br>&nbsp;Next,
recall from "Higher Order Function" notes that&nbsp; we can use the
notation "e1~&gt;e2" to mean expression e1 evaluates to expression e2
when we want to explain how a function is reduced step-by-step. &nbsp;
For example, in this question we are looking for a function "f" that
would produce the following sequence of evaluations:<br><br><div style="margin-left: 40px;"><span style="font-family: monospace; font-weight: bold;">foldr f [] [1,2,3]</span><br style="font-family: monospace; font-weight: bold;"><span style="font-family: monospace; font-weight: bold;">~&gt; f 1 (foldr f [] [2,3])</span><br style="font-family: monospace; font-weight: bold;"><span style="font-family: monospace; font-weight: bold;">~&gt; f 1 (f 2 (foldr f [] [3]))</span><br style="font-family: monospace; font-weight: bold;"><span style="font-family: monospace; font-weight: bold;">~&gt; f 1 (f 2 (f 3 (foldr f [] [])))</span><br style="font-family: monospace; font-weight: bold;"><span style="font-family: monospace; font-weight: bold;">~&gt; f 1 (f 2 (f 3 []))</span><br style="font-family: monospace; font-weight: bold;"><span style="font-family: monospace; font-weight: bold;">~&gt; f 1 (f 2 [3])</span><br style="font-family: monospace; font-weight: bold;"><span style="font-family: monospace; font-weight: bold;">~&gt; f 1 [3,2]</span><br style="font-family: monospace; font-weight: bold;"><span style="font-family: monospace; font-weight: bold;">~&gt; [3,2,1]</span><br></div><br>&nbsp;Now,
Haskell has a function "reverse" that reverses the order of the
&nbsp;elements in a list, e.g. reverse [1,2,3,4] =&gt; [4,3,2,1]. The
definition &nbsp;in Prelude.hs consists of <br>
<div style="margin-left: 40px;"><span style="font-family: monospace;">&nbsp;foldl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :: (a -&gt; b -&gt; a) -&gt; a -&gt; [b] -&gt; a</span><br style="font-family: monospace;"><span style="font-family: monospace;">&nbsp;foldl f z []&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = z</span><tt></tt><span style="font-family: monospace;"><br>
&nbsp;foldl f z (x:xs)&nbsp; = foldl f (f z x) xs</span><br style="font-family: monospace;"><span style="font-family: monospace;"><br>
&nbsp;flip&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</span><br style="font-family: monospace;"><span style="font-family: monospace;">&nbsp;flip f x y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = f y x</span><br style="font-family: monospace;"><span style="font-family: monospace;">&nbsp;</span><br style="font-family: monospace;"><span style="font-family: monospace;"><br>
&nbsp;reverse&nbsp;&nbsp; :: [a] -&gt; [a]</span><br style="font-family: monospace;"><span style="font-family: monospace;">&nbsp;reverse&nbsp;&nbsp;&nbsp; = foldl (flip (:)) []</span><br style="font-family: monospace;"></div><br>Complete
reverse1 by replacing YOURLAMBDAEXPRESS with a lambda expression which
will reverse a list.&nbsp; You should _NOT_ use "flip"<br>&nbsp;<br>&nbsp;&gt; reverse1 = foldr YOURLAMBDAEXPRESS []<span style="text-decoration: underline;"><br></span><br>What is the most general type (if any) of<br>
&nbsp;&nbsp; A) map map<br>
&nbsp;&nbsp; B) foldl foldl<br>
&nbsp;&nbsp; C) map foldl<br>
&nbsp;&nbsp; D) map . foldl<br>
<br>
What is the value of :<br>
&nbsp;&nbsp; (map . foldl1) (-) [[1,2,3],[3,2,1],[100,200,300]]<br>
&nbsp;&nbsp;&nbsp; map (\v -&gt;&nbsp; v
[4000,1000]) (map foldr1 [div,(-)])<br>
&nbsp;&nbsp;&nbsp; map (\f -&gt; f [3,4,5])&nbsp;
(map map [(*) 3,(-) 4])<br><br>What is the value of mapmap ? Try and figure it out then run it.<br>&nbsp;<br>&gt; mapmap = map (\x-&gt; x [1,2,3])(map map [odd,even])<br><br><span style="text-decoration: underline;"></span></body></html>