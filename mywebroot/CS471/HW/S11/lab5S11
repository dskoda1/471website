/*******************************************************************
        CS471 - Programming Languages
        Assignment #<number> due: <DATE>
        Author: <LastName>, <FirstName> (<EMail>)
        Date: <DATE>
*****************************************************************/

/* 1: Define a predicate "simplity/3" that succeeds if the last arguement is 
      a list with items with the form Var:Value,  
      the first argument is a "var" atom in the list and 
      the second argument is the var's Value.  Requires only one clause.
      (hint::member, atom).
      ?- simplify(b,Value,[a:100,b:(-5)]).
      Value = -5
      ?- simplify(b,Value,[a : 1,b : 5]).
      Value = 5 .
      */
      
      
/* 2: Now extend predicate "simplity/3" to  evaluates an algebraic expression.
   The algebraic expression consists of variable with operators 'plus', 
   'minus' and 'times'. Here are two test queries:
          ?- simplify(plus(times(x,y),times(3 ,minus(x,y))),V,[x:4,y:2]).
          V = 14
          ?- simplify(times(2,plus(a,b)),Val,[a:1,b:5]).
          Val = 12
          ?- simplify(times(2,plus(a,b)),Val,[a:1,b:(-5)]).
          Val = -8 .
    Requires only a total 5 clauses.  You may use "number" in one of your clauses.      
*/



%3: value(+Coin, +Num, ?Amt)
/* Below is a database of US coins. */

coin(dollar, 100).
coin(half, 50).
coin(quarter, 25).
coin(dime,10).
coin(nickel,5).
coin(penny,1).

/* 3: Write a predicate, value(Coin, Num, Amt), where Coin is the name,
      Num is how many and Amt is the total value, 
     (the value of the coin (in pennies) times the number of coins. )
     You should use the facts created in question 1 as
      as subgoal to find the value in pennies of the coin.
        ?- value(quarter,5, Amt).
        Amt = 125
        ?- value(dime,10, 100).
        Yes
        ?- value(dime,N, 100).
        ERROR: is/2: Arguments are not sufficiently instantiated
 */


%4. prodL(+N,S).
/* Is simular to prodR(+N,?S), except that product
   accumulate left to right. e.g. The first value in P will be N,
   the second value will be N * N-1, etc.  

       ?- prodL(6,P).
       P = [6, 30, 120, 360, 720, 720] .
   It would be helpful to overload prodL/2 and include the following
   clause:
         prodL(N,Lst):- prodL(N,N,Lst).
      plus 
      2 additional clauses.
      
   What happens if your put the trivial case last?  

*/


/*****************************************************/

/* 5: (Do not turn in. Practice for the test.)
   Given the 4 logically equivalent predicates try to predict the outcome of 
   ?- subList1(X,[a]),fail.
   ?- subList2(X,[a]),fail.
   ?- subList3(X,[a]),fail.
   ?- subList4(X,[a]),fail.
   Try to understand why some produce "ERROR: Out of global stack"

*/ 

subList1(S,L):-append(_,S,P),append(P,_,L).
subList2(S,L):-append(P,_,L),append(_,S,P).
subList3(S,L):-append(S,_,T),append(_,T,L).
subList4(S,L):-append(_,T,L),append(S,_,T).

/* Using writes to see the backtracking */

subList1w(S,L):-write('1-1'),append(_,S,P),write(' 1-2'),write(P),append(P,_,L).
subList2w(S,L):-write('2-1'),append(P,_,L),write(' 2-2'),write(P),append(_,S,P).
subList3w(S,L):-write('3-1'),append(S,_,T),write(' 3-2'),write(T),append(_,T,L).
subList4w(S,L):-write('4-1'),append(_,T,L),write(' 4-2'),write(T),append(S,_,T).


