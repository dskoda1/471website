/*
      CS471 - Programming Languages
        Assignment #<number> due: <DATE>
        Author: <LastName>, <FirstName> (<EMail>)
        Date: <DATE>

      You will find this site helpful in studing for the test.
      https://sites.google.com/site/prologsite/prolog-problems
 */

/*  Below is a database of US coins. */

coin(dollar, 100).
coin(half, 50).
coin(quarter, 25).
coin(dime,10).
coin(nickel,5).
coin(penny,1).

/* 1: (Very Easy) Write a predicate, value(Coin, Num, Amt), where Coin is the name,
      Num is how many coins and Amt is the total value, 
     (the value of the coin (in pennies) times the number of coins. )
     You should use the facts created above as
      as subgoal to find the value.
      
        ?- value(quarter,5, Amt).
        Amt = 125
        ?- value(dime,10, 100).
        Yes
        ?- value(dime,N, 100).
        ERROR: is/2: Arguments are not sufficiently instantiated
 */
 



/* 2: Write a predicate change/2 that given the change amount, computes the ways 
      in which we can give change.  Use USA's  coin denominations above.
      
      The predicate "change" is such that an positive integer S, 
      change(S,T) "returns" a list of tuples, T, where the tuple contains the
      name of the denomination (Name,Count), 
      the atom Name of the denomination and integer Count that gives 
      the number of coins of each denomination in D that add up to S.
      (Notice that you do not have to be able to generate or 
      validate all possible solutions.)
      For example::
        ?- change(127,L).
        L = [ (dollar, 1), (quarter, 1), (penny, 2)] 
        Yes
        ?- change(44,L).
        L = [ (quarter, 1), (dime, 1), (nickel, 1), (penny, 4)] ;
        L = [ (quarter, 1), (dime, 1), (penny, 9)] ;
        L = [ (quarter, 1), (nickel, 3), (penny, 4)] ;
        L = [ (quarter, 1), (penny, 19)] ;
        L = [ (dime, 4), (penny, 4)] ;
        L = [ (nickel, 8), (penny, 4)] ;
        L = [ (penny, 44)] ;
        No
      
      This can be solved with only 2 clauses.
      
      The Coin Changing problem is an interesting problem usually studied in
      Algorthms.  http://condor.depaul.edu/~rjohnson/algorithm/coins.pdf is a 
      nice discussion.
      Think about ::
         1) How could we generalize this problem to handle different 
            denominations?  
         2) What are the different techinques to find the change with the
            fewest number of coins ?         
         3) What happens if the order of the "coin" facts change? 

  */



/* 3: Below are 3 structures that representation expression trees using Prolog.
      (Op is any Prolog operator.)

     expTree(Op,Lt,Rt).
     expTree(lit,Value).
     expTree(Op,T).

    Write a Prolog program:
         eval(Tree,Value).
    which succeeds if Value is the result of computing the expressions 
    represented by an expression tree.  For example:

   ?- eTree4(T),eval(T,V).
   T = expTree(float, expTree(sin, expTree(/, expTree(lit, pi), expTree(lit, 2))))
   V = 1.0

   ?- eTree1(T),eval(T,V).
   T = expTree(+, expTree(lit, 5), expTree(*, expTree(lit, 3), expTree(lit, 2)))
   V = 11

   Below are trees you can use for testing.
   
   This can be done with only 3 clauses  -- if you understand lab 4.
*/

eTree1(expTree('+',
	      expTree(lit, 5),
	      expTree('*',
	           expTree(lit, 3),
	           expTree(lit, 2)
	       )
       )
 ).


eTree2(expTree('*',
	expTree('-', 
	     expTree(lit, -3),
	     expTree(lit, 2)
	 ),

	expTree('+', 
	      expTree(lit, 3),
	      expTree('-',
		     expTree(lit, 2)
		   )
	   )
	 )
 ).

eTree3(expTree('*',
	expTree('min', 
	     expTree(lit, -3),
	     expTree(lit, 2)
	 ),

	expTree('+', 
	     expTree(lit, 3),
	     expTree('-',
		    expTree(lit, 2)
		    )
	     )
	 )
 ).


eTree4(expTree(float,
	   expTree('sin',
	        expTree('/',
		       expTree(lit, pi),
		       expTree(lit, 2)
		     )
	    )
	   )
 ).




/*4. countLit(ExpTree,NumLit) is successful if  number of "lit" nodes in an 
     expTree structure unifies with NumLit. i.e.
     
     ?- eTree1(T).
     T = expTree(+, expTree(lit, 5), expTree(*, expTree(lit, 3), expTree(lit, 2))).

     ?- eTree1(T), countLit(T,N).
     T = expTree(+, expTree(lit, 5), expTree(*, expTree(lit, 3), expTree(lit, 2))),
     N = 3 .

     ?- eTree2(T), countLit(T,N).
     T = expTree(*, expTree(-, expTree(lit, -3), expTree(lit, 2)), 
               expTree(+, expTree(lit, 3), expTree(-, expTree(lit, 2)))) ,
     N = 4 .

     ?- eTree3(T), countLit(T,N).
     T = expTree(*, expTree(min, expTree(lit, -3), expTree(lit, 2)), 
             expTree(+, expTree(lit, 3), expTree(-, expTree(lit, 2)))) ,
     N = 4 .

     ?- eTree4(T), countLit(T,N).
     T = expTree(float, expTree(sin, expTree(/, expTree(lit, pi), expTree(lit, 2)))),
     N = 2 .

     This can be done with 3 clauses.  It is not too hard.

  */
  
   
/* 5: The following Finite State machine accepts all even parity "strings". Write a Prolog program 
that accept all valid strings in the language. We will represent the strings as a list of atoms.  
Sigma = { 0,1 }, Start state = {q0},  Final state = { q0,q1 }, and
    delta(q0,0) = q1
    delta(q0,1) = q3
    delta(q1,0) = q0
    delta(q1,1) = q2
    delta(q2,0) = q3
    delta(q2,1) = q1
    delta(q3,0) = q2
    delta(q3,1) = q0.

    You need to convert the above FSA definition to Prolog and add
    definition of  'accept' and 'deltaHat(Q1,Str)'.  The definition of deltaHat is:
    deltaHat(Q,[]) = Q (Our program will represent the empty string as the empty list).
    deltaHat(Q, [C|Cs]) = deltaHat(delta(Q,C),Cs).

A string is accepted if deltaHat(q0, String) is in a final state (q0 or q1).
      ?- accept([0,0,0,0,1,1,1,1,0,1,1]).
    true
    ?- accept([0,0,0,0,1,1,1,1,1]).
    false
    ?- accept([0,0,0,0,1,1,1,1,1,1]).
    true
    ?- accept([0,0,1,1,0,0,1,1,1,1,1,1]).
    true
    ?- accept([0,0,0,0,1]).
    false
    ?- accept([1,1,1,0,1,0,1,0,1,0]).
    true
*/





/* 6: In Lab 5 problem 1 we had the following:
      Syntax-Directed Differentiation:  A motivating example illustrating the 
      power of pattern matching in Prolog. ....
      Below is a solution for this exercise.
*/ 
    
d(x,x,1).
d(C,x,0):-number(C).
d(C*x,x,C):-number(C).
d(-U, X, -DU) :- d(U, X, DU).
d( U + V, x, RU + RV ):-d(U,x,RU), d(V,x,RV).
d( U - V, x, RU - RV ):-d(U,x,RU), d(V,x,RV).
d(U * V,x, U * DV + V * DU):- d(U,x,DU), d(V,x,DV).
d(U^N, x, N*U^N1*DU) :- integer(N), N1 is N-1, d(U, x, DU).

/*
      Keep in mind, though, that terms such as U+V are still trees with the
      functor at the root, and that evaluation of such terms requires 
      additional processing which you will complete.
        
      Define the predicate, 'evaluate', that uses the result from 
      differentiation (above) and a list of values for each variable and 
      computes the resulting value. e.g.

   ?- d(3*(x +2*x*x),x,Result), LVarValue=[x:3], evaluate(Result,Value,LVarValue).
   Result = 3* (1+ (2*x*1+x*2))+ (x+2*x*x)*0
   LVarValue = [x:3]
   Value = 39 .
   ?- d((3*x) ^ 4,x,Result), LVarValue=[x:2] , evaluate(Result,Value,LVarValue).
   Result = 4* (3*x)^3*3,
   LVarValue = x:2,
   Value = 2592 .
 
     The only built-predicates you may use are (You won't need all of them):
     is, //, /, +, -, ^, *,=..,>, <, 
     atom, is_list, functor, arg, integer, number, member, append 
   
 */





/** 7: Define a procedure unNested, such that unNested(LstOfNestedLsts,UnNestedLst)
     succeeds if UnNestedLst is a list with only atoms and numbers and
     the numbers and atoms are elements of nested list in LstOfLsts and these
     elements occur in the same in both lists. e.g.

       ?- unNested([1,[1,3,2,[a,b,c]] ,[x,[y],[]],  [a], [x,y,z]],U).
       U = [1, 1, 3, 2, a, b, c, x, y|...].

   %%To get all the elements printed out set the prolog flag as follows:

       ?- set_prolog_flag(toplevel_print_options, [quoted(true), portray(true), max_depth(1000)]).
       true.

       ?- unNested([1,[1,3,2,[a,b,c]] ,[x,[y],[]],  [a], [x,y,z]],U).
       U = [1, 1, 3, 2, a, b, c, x, y, a, x, y, z].

       ?- unNested([[],[whoIs(a),[[^,X - Y,[+,is]],[c]],[]], [[[+(1,2)],91],*] ],C).
       C = [whoIs(a), ^, X-Y, +, is, c, 1+2, 91, *].
       ?- unNested([1,[1,3,2,[a,[b,c],[]]] ,[x,[],[y],[]],[a,[b]],[x,y,z]],U).
       U = [1, 1, 3, 2, a, b, c, x, y, a, b, x, y, z].

   (Order of clauses is important if you don't use cuts. Only 3 clauses necessary. The only builtin
    predicate you may use is "append")

*/


/*  8. Do exercise 11.14 page 572.  You may have use TWO or Three functors. 
       You may overload "insertionSort". 
       One for the outer loop and one for the inner loop.

       ?- insertionSort([4,53,5,1,7],S).
       S = [1, 4, 5, 7, 53] .
 */



