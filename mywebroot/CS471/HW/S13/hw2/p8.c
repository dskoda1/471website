/* p8.c
   Does (0.1 + x) * 10.0 equal 1.0 + ( x * 10.0) ?

       * Compile the code, p8.c, on a  Intel platform twice as follows:
                   gcc p8.c -o hw2a.exe -std=iso9899:1999
                   gcc p8.c -o hw2b.exe -O -std=iso9899:1999
       *  Run both executables:
                     ./hw2a.exe
              and
                     ./hw2b.exe
       * To aid in your explanation you may use the -S switch:
                        gcc p8.c  -o hw2a.S -S -std=iso9899:1999
                        gcc p8.c -o hw2b.S -O -S -std=iso9899:1999
         to see the assembly code generated by the different opinions. 
         You are also encouraged to use a debugger such as ddd or gdb.
             DDD manual
             GDB Documentation
             
         You might take this opportunity to create a Makefile and use make 
         to build the different executables.  You can use the Makefile 
         supplied in problem 2 as an example.  It will be easier if you 
         locate p8.c and your new Makefile in the same directory.  
         (Helpful links on make:http://www.eng.hawaii.edu/Tutor/Make/ 
             and http://www.gnu.org/software/make/

         If you have time try this same problem on the Sparc machines.  
         You can access Bingsuns via an ssh client
              ssh bingsuns.binghamton.edu -l<yourLogin>
    
*/
  
#include <stdio.h>
float s;
float t;

float y;
float x;

float x10;
float y10;

void why() {
	y = 0.1;
	x = -9.999998e-02;  
	printf("y = %e\n", y);
	printf("x = %e\n", x);
 
	t = (y + x)*10.0;
	x10 = (x* 10.0);
	y10 = (y * 10.0);
	s = x10+y10;

	printf("(x+y)*10 = %e\n", t);
	printf("(x*10) + (y*10) = %e\n\n", s);
}
int main(void) {
	why();
	return 0;
}
