<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>




  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>Haskell Lab 2</title></head><body>Lab 2 due Tuesday Nov 26 @ end of day.&nbsp; There will be no homework due next week.<br>
<br>
Haskell Lab 2:<br>

You may use either HUGS or GHCi for the assignments.<br>

<br>
You should add you code to <big><a style="font-weight: bold;" href="LabH2F13.lhs">LabH2F13.lhs</a></big><br>

<span style="font-family: monospace; font-weight: bold;"></span><br>

<span style="font-weight: bold;"><span style="font-weight: bold;"><br>
Part 1 Data types<br>
</span></span>
<ol>

  <li>[10pts]Define a data type Point that represents a point in a
plane and the coordinate values should be Doubles.&nbsp; You should
include "deriving Show" in your data type definition.&nbsp; Can you guess the purpose of&nbsp; including "deriving Show"? </li>
  <li>[10pts]Write a Haskell function "inside point r " which returns
true if
and only if the point lies inside a circle of radius r and false
otherwise.&nbsp; <br>
&nbsp;"<span style="font-style: italic;">inside</span>" can be defined
as: <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inside r point (x, y) is
true&nbsp; if and only if x^2 + y^2 &lt; r^2 <br>
where x and y are the coordinates of the point. <br>
Your Haskell code should not be using tuples.
If your contructor for Point is Pt then to execute you type:</li>
  <dl>
    <dd style="font-family: monospace; font-weight: bold;">LabH2F13&gt;
inside 10.0 (Pt 3.0 2.5) <br>
True <br>
LabH2F13&gt; inside 10.0 (Pt (-1) (-2)) <br>
    </dd>
    <dd><span style="font-family: monospace; font-weight: bold;">True&nbsp;
      </span><br style="font-family: monospace; font-weight: bold;">
      <span style="font-family: monospace; font-weight: bold;">LabH2F13&gt;
inside 2.0 (Pt 3.0 2.5) </span><br style="font-family: monospace; font-weight: bold;">
      <span style="font-family: monospace; font-weight: bold;">False <br>
</span></dd></dl></ol><br>
<ol>

  <span style="font-weight: bold;"></span>
  <div style="margin-left: 40px;"><span style="font-weight: bold;"></span></div>
</ol>


<span style="font-weight: bold;">Part 2 Recursion:</span><br>

<ol>

  <li>[10pts]Write a recursive definition, <span style="font-style: italic;">mul x y</span>, that returns the product <span style="font-style: italic;">x*y.</span> <br>
(Do not use "*" operator.)<br>
    <br>
  </li>
  <li>[10 pts]Write
a Haskell script which implements Ackermann's function as defined
in homework 1 problem 7.&nbsp; Name your script "ack".&nbsp; You may
use guards, and/or pattern matching and/or if expressions in your
definition.&nbsp; Predict the inferred type of ack.&nbsp; Check
you guess. <br>
    <table style="width: 600px; height: 89px; margin-left: 40px;">

<tbody>
<tr>
<td style="font-weight: bold;">ack( <i>m,n</i>
) =</td>
<td style="font-weight: bold;">&nbsp;<span style="font-style: italic;">n +</span> 1<br>
</td>
<td style="font-weight: bold;">if <i>m</i>
= 0</td>
</tr>

<tr>
<td style="font-weight: bold;">ack( <i>m,n</i>
) =&nbsp;</td>
<td style="font-weight: bold;"><span style="font-weight: bold;"></span><span style="font-weight: bold;"><span style="font-weight: bold;">ack(<span style="font-style: italic;">m</span>
- 1, 1)</span></span>
</td>
<td style="font-weight: bold;">if <span style="font-style: italic;">n</span> = 1 and&nbsp;<span style="font-style: italic;">m&nbsp;</span>&gt;
0&nbsp;</td>
</tr>
<tr>
<td style="font-weight: bold;">ack( <i>m,n</i>
) =</td>
<td style="font-weight: bold;">ack( <i>m</i>-1,
ack( <i>m, n</i>-1 ) )&nbsp; <br>
</td>
<td style="font-weight: bold;">if n &gt;0 and m &gt; 0<span style="font-style: italic;"></span><span style="font-style: italic;"></span></td>
</tr>
</tbody>
    </table><br>
    <br>


    </li>
  <li>[15pt]" A) A common way to compute the square root is to use
Newton's
method of successive approximations. &nbsp; <a href="http://mitpress.mit.edu/sicp/full-text/sicp/book/node12.html">Newton's
method says that whenever
we have a guess <em>y</em> for the value of the square
root of a
number <em>x</em>, we can perform a simple manipulation to
get a
better guess (one closer to the actual square root) by averaging <em>y</em>
with <em>x</em>/<em>y</em>. </a>&nbsp;<a href="http://mitpress.mit.edu/sicp/full-text/sicp/book/node12.html">
For
example, we can compute the square root of 2 as follows. Suppose our
initial guess is 1:</a>
    <p>
</p><table cellpadding="3">
  <tbody>
    <tr>
      <td align="left">Guess</td>
      <td align="left">Quotient</td>
      <td align="left">Average</td>
    </tr>
    <tr>
      <td align="left">&nbsp;</td>
      <td align="left">&nbsp;</td>
      <td align="left">&nbsp;</td>
    </tr>
    <tr>
      <td align="left">1</td>
      <td align="left">&nbsp;<img style="border: 0px solid ; width: 44px; height: 49px;" src="../../img7.gif" alt="${\displaystyle \frac{2}{1} = 2}$" align="middle"></td>
      <td align="left"> <comment title=" MATH: ${\displaystyle \frac{(2+1)}{2} = 1.5}$ " xmlns="http://disruptive-innovations.com/zoo/nvu"><!-- MATH: ${\displaystyle
\frac{(2+1)}{2} = 1.5}$ --></comment>
      <img style="border: 0px solid ; width: 96px; height: 53px;" src="../../img8.gif" alt="${\displaystyle" align="middle"></td>
    </tr>
    <tr>
      <td align="left">&nbsp;</td>
      <td align="left">&nbsp;</td>
      <td align="left">&nbsp;</td>
    </tr>
    <tr>
      <td align="left">1.5</td>
      <td align="left"> <comment title=" MATH: ${\displaystyle \frac{2}{1.5} = 1.3333}$ " xmlns="http://disruptive-innovations.com/zoo/nvu"><!-- MATH: ${\displaystyle \frac{2}{1.5} = 1.3333}$ --></comment>
      <img style="border: 0px solid ; width: 93px; height: 49px;" src="../../img9.gif" alt="${\displaystyle \frac{2}{1.5} = 1.3333}$" align="middle"></td>
      <td align="left"> <comment title=" MATH: ${\displaystyle \frac{(1.3333+1.5)}{2} = 1.4167}$ " xmlns="http://disruptive-innovations.com/zoo/nvu"><!-- MATH: ${\displaystyle
\frac{(1.3333+1.5)}{2} = 1.4167}$ --></comment>
      <img style="border: 0px solid ; width: 169px; height: 53px;" src="../../img10.gif" alt="${\displaystyle" align="middle"></td>
    </tr>
    <tr>
      <td align="left">&nbsp;</td>
      <td align="left">&nbsp;</td>
      <td align="left">&nbsp;</td>
    </tr>
    <tr>
      <td align="left">1.4167</td>
      <td align="left"> <comment title=" MATH: ${\displaystyle \frac{2}{1.4167} = 1.4118}$ " xmlns="http://disruptive-innovations.com/zoo/nvu"><!-- MATH: ${\displaystyle \frac{2}{1.4167} = 1.4118}$ --></comment>
      <img style="border: 0px solid ; width: 117px; height: 49px;" src="../../img11.gif" alt="${\displaystyle \frac{2}{1.4167} = 1.4118}$" align="middle"></td>
      <td align="left">&nbsp;<img style="border: 0px solid ; width: 193px; height: 53px;" src="../../img12.gif" alt="${\displaystyle" align="middle"></td>
    </tr>
    <tr>
      <td align="left">&nbsp;</td>
      <td align="left">&nbsp;</td>
      <td align="left">&nbsp;</td>
    </tr>
    <tr>
      <td align="left">1.4142</td>
      <td align="left">...</td>
      <td align="left">...</td>
    </tr>
  </tbody>
</table>
    



Continuing this process, we obtain better and better
approximations to
the square root. " (From <span style="font-style: italic;">Structure
and
Interpretation of Computer Programs</span> by Abelson and
Sussman).<br>



Using&nbsp; a spreadsheet or calculator apply Newton's method to
find
the square root of 144 using an initial guess of
1.&nbsp;&nbsp;&nbsp; How do
you know when to stop?&nbsp; How many steps did it take you?<span style="font-family: monospace; font-weight: bold;"></span><br>
    <br>
B) Code ack in Haskell.<br>

    <br>

  </li>

  <li>[10pts]The harmonic series is the following infinite series:<br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp; 1&nbsp;&nbsp; 1&nbsp;&nbsp;
1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1 +&nbsp;&nbsp; - + - + - + - + ...&nbsp;&nbsp; + ... - ..</span><br style="font-family: monospace;">
    <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp; 3&nbsp;&nbsp; 4&nbsp;&nbsp;
5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
i</span><br style="font-family: monospace;">
(http://en.wikipedia.org/wiki/Harmonic_series_(mathematics)). Write a
function sumHarmonic such that sumHarmonic <span style="font-style: italic;">i</span> is the sum of the first <span style="font-style: italic;">i</span> terms of this series. <span style="font-family: monospace;"><br>
    </span></li>
  <span style="font-family: monospace;">For example, sumHarmonic 4
~&gt; 1 + 1 + 1 + 1 ~&gt; 2.08333...</span><br style="font-family: monospace;">
  <span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp; 3&nbsp;&nbsp; 4 </span><br style="font-family: monospace;">
&nbsp;
My version has the following type, <span style="font-family: monospace; font-weight: bold;">sumHarmonic :: (Eq a,
Fractional a) =&gt; a -&gt; a </span><br>
  <br>
  <br>
</ol>

<span style="font-weight: bold;">Part 3 Tail Recursion</span><br>

<div style="text-align: left;"><big><span style="font-weight: bold;">Code for the questions below is supplied in </span><br style="font-weight: bold;">
</big>
<div style="margin-left: 40px;"><big><a style="font-weight: bold;" href="LabH2F13.lhs">LabH2F13.lhs</a></big><br style="font-weight: bold;">
</div>
<big><span style="font-weight: bold;">
</span></big><br>
</div>


1) Our example is the exponentiation function, which raises a
number
to a positive integer power. Here is a very simple implementation: <br>




<ol>
<span style="font-family: monospace;">&gt; power
:: Integer
-&gt; Integer -&gt; Integer&nbsp;&nbsp;</span>&nbsp;&nbsp; <br><span style="font-family: monospace;">&gt; power a
0 = 1&nbsp;</span>&nbsp;<span style="font-family: monospace;">&nbsp;&nbsp;
  <br>
  </span><span style="font-family: monospace;">&gt;
power a b = a *
power a (b-1)<br>
  </span><span style="font-family: monospace;"><br>
  </span>
</ol>


<ol style="list-style-type: lower-alpha; margin-left: 40px;">
<li>[5pts] Show the steps in the evaluation of the expression<span style="font-family: monospace; font-weight: bold;"> power 2 5</span>,&nbsp; making sure not to
reduce any subexpression prematurely.
How do the time and maximum space
required by the
evaluation of <span style="font-family: monospace;">power
n k</span>
depend on <span style="font-style: italic;">n </span>and <span style="font-style: italic;">k</span>?
&nbsp;What is the time complexity of <span style="font-style: italic;">power?<br>
    </span><br>
<br>
  </li><li>[5pts] Because of lazy evaluation, the definition of <span style="font-family: monospace; font-weight: bold;"><span style="font-style: italic;">power</span></span> accumulates of
pending
multiplications. It is inherent in the way power is
defined&#8212;
each multiplication has to wait until its right argument has been
evaluated.<br>
  </li>
One way to eliminate the multiplication delay is to convert
the function&#8217;s definition to a tail-recursive implementation: <br><br><span style="font-family: monospace;">&gt; powerT
:: Integer -&gt;
Integer -&gt; Integer</span><br style="font-family: monospace;"><span style="font-family: monospace;">&gt; powerT
a b = trp b 1</span><br style="font-family: monospace;"><span style="font-family: monospace;">&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
where</span><span style="font-family: monospace;"></span><br style="font-family: monospace;"><span style="font-family: monospace;">&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
trp n p = if (n==0) then p else trp (n-1) (a*p)<br>
  </span><br style="font-family: monospace;">
Show the steps in the evaluation of the expression <span style="font-family: monospace; font-weight: bold;">powerT 2 5</span>,
making sure not to
reduce any subexpression prematurely.&nbsp;&nbsp; <br>
  <br>
  <br>
<li><span style="font-family: monospace;"></span>[5pts]Convert the
powerT to an iterative form (while loop) using the <a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/2HrF10.html">conversion</a>
technique discussed in class.<br>
    <br>
  </li>
</ol>


2) In the exercise above we improved power&#8217;s space
performance, but
all three versions take time linear in the exponent argument.<br>


<br>

<ol style="list-style-type: lower-alpha;">
<li>[5pt]Here is an algorithm which improves both time and
space
performance:</li><dd style="margin-left: 80px;"><span style="font-family: monospace;"><br>
&nbsp; &nbsp; &gt;
turboPower a 0 = 1 <br>
&nbsp; &nbsp; &gt; turboPower a b <br>
&nbsp; &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp;
| even b = turboPower
(a*a) (b `div` 2) <br>
&nbsp; &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp;
| otherwise = a *
turboPower a (b-1)</span></dd><dd><span style="font-family: monospace;"></span><br>
  </dd>
Instead of merely decrementing its first argument, this
algorithm
halves it whenever it is even, thereby reaching termination much more
quickly. What is the complexity of this algorithm? <span style="font-family: monospace;"><br>
 </span><br><span style="font-family: monospace;"></span><span style="font-family: monospace;"></span><li>[10pts] Convert <span style="font-style: italic; font-family: monospace;">turboPower</span><span style="font-style: italic;">&nbsp; </span>to a tail recursive version -- call you new version&nbsp;<span style="font-family: monospace; font-weight: bold;">turboPowerT.&nbsp; </span>What is the complexity of this algorithm? <span style="font-style: italic;"> </span></li><br>
</ol>
<span style="font-weight: bold;">Part 4 List Comprehension - and recursion<br>
</span>
<ol style="list-style-type: lower-alpha;">
  <li>[10pts]Define <span style="font-style: italic;">sq</span>,
which creates a list of square values from a list of numbers.&nbsp; Use
list comprehension notations in your solution. (Very easy)</li>
  <li>[10pts]Define a function "repl" which given a list of numbers returns a
list with each number duplicated its value.&nbsp; Use only recursion (no list comprehension notation).&nbsp; i.e.<br>
    <br>
    <div style="margin-left: 40px; font-family: monospace;">&nbsp; ..&gt; repl [5,1,3,2,8,1,2]<br>
&nbsp; [5,5,5,5,5,1,3,3,3,2,2,8,8,8,8,8,8,8,8,1,2,2]<br>
    </div>
    <br>
  </li>
</ol>

</body></html>