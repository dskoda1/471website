<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html lang="en-us">
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">

  <meta name="Author" content="E Head">

  <meta name="GENERATOR" content="Mozilla/4.73 [en] (Win98; U) [Netscape]">

  <meta name="Description" content="Introduction">
  <title>HW 11 -- Haskell --</title>


</head>


<body>

<h4 style="text-align: left;">Assignment 11:</h4>

<h4 style="text-align: left;">Non-grade problem--</h4>

<ol start="4">

Friday Nov. 16::<br>

Define subSeq which given a sequence of values in a list create a list<br>

of lists that contain all the suffixes of the original list.<br>

e.g.<br>

  <br>

&nbsp;&nbsp; Haskell2F07&gt; subSeq [1,1,2,3,5]<br>

&nbsp;
&nbsp;[[1,1,2,3,5],[1,2,3,5],[2,3,5],[3,5],[5],[]]&nbsp;<br>

  <br>

</ol>

Due lecture after topic covered in class.<br>

<ol start="4">

Show the steps in the evaluation of the expression<br>

  <span style="font-family: monospace;"><br>

&nbsp; &nbsp;let f x y = if x &lt; 0 then x else x * y in f
  </span><span style="font-family: monospace;">(-2) </span><span style="font-family: monospace;">(f&nbsp;3 5)</span><br>

  <br>

For each evaluation policy, count the number of addition operations and
the number of comparisons. In each step, underline the subexpression
evaluated in the next step (as in <a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/2EhS05.html">notes</a>).<br>

  <br>

  <ol style="list-style-type: lower-alpha;">

    <li>Use the leftmost-innermost policy.</li>

    <li>Use the outermost policy.</li>

    <li>Use the lazy policy.</li>

  </ol>

</ol>

<h4 style="text-align: left;">GRADED :: Due:: Wed Nov
21&nbsp; 1pm</h4>

<div align="left">
<ul>

  <li>Recommended reading: Thompson, Chapter 1 -7, Appendix A</li>

  <li><span style="text-decoration: underline;"><a href="http://www.haskell.org/haskellwiki/Haskell_in_5_steps">Getting
Started</a></span></li>

  <li><span style="text-decoration: underline;"><a href="http://www.haskell.org/haskellwiki/Learning_Haskell">Learning
Haskell -- links to tutorals and books</a></span></li>

  <li>Scott: 7.2.3 (p332) , 7.8, page 425
(delegates in c#), 10,10.1,
10.2,10.4 , 10.4.1, 10.5, 10.7</li>

  <ul>

    <li>cyu: chap 7:53, chap 10::1,2,4,12,14,15,17,18,20,21</li>

  </ul>

</ul>

References:
<br>

<ul>

  <li><a href="http://www-128.ibm.com/developerworks/java/library/j-fp.html">Functional
programming in the Java language</a></li>

  <li><a href="http://www.defmacro.org/ramblings/fp.html">Functional
Programming For The Rest of Us</a></li>

  <li><a href="http://www.haskell.org/haskellwiki/">Haskellwiki</a></li>

  <li><a href="http://www.gnu.org/software/guile/manual/html_node/About-Closure.html#About-Closure">About
Closure</a></li>

  <li><a href="http://en.wikipedia.org/wiki/Closure_%28computer_science%29">Closure
(computer science)</a></li>

  <li><a href="http://en.wikipedia.org/wiki/Callback_%28computer_science%29">Callback
(computer science)</a></li>

  <li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1968.pdf">Lambda
Expressions and Closures for C++ &nbsp;&nbsp;</a></li>

  <li><a href="http://www.developer.com/net/csharp/article.php/3598381">New
Lambda Expressions Feature in C# 3</a></li>

  <li><a href="http://docs.python.org/tut/node6.html#SECTION006750000000000000000">Lambda
Forms in Python</a></li>

  <li><a href="http://www.secnetix.de/%7Eolli/Python/lambda_functions.hawk">Python
Lambda Expressions</a></li>
  <li><a href="http://www.ibm.com/developerworks/java/library/j-cb01097.html">Crossing borders: Closures</a></li>
  <li><a href="http://samdanielson.com/2007/9/6/an-introduction-to-closures-in-ruby">An Introduction to Closures in Ruby</a></li>

</ul>

<h4>Programming assignment found in <a href="Haskell2F07.lhs">
Haskell2F07.lhs</a> </h4>

<h4>Written assignment&nbsp;</h4>

<ol>

  <li>[10pts] What is the definition of closure? What is the
purpose of a <span style="font-style: italic;">callback</span>
function? &nbsp;Give an example of a callback function in a
language of you choice. &nbsp;What is the relationship between<span style="font-style: italic;"> closure</span>
and&nbsp; <span style="font-style: italic;">callback
? &nbsp;</span>Give an example of closure in Ruby ( You may
use an example from previous homework.)<br>

    <br>

  </li>

  <li>[5pts] Define a function <span style="font-style: italic;">swap</span> in Python
using the specification from
the Haskell programming problem 2. &nbsp;You should
use&nbsp;Python's
lambda expression. &nbsp;Note:&nbsp;operators can not be passed
as
arguments like we can in Haskell, however, functions can be passed.
&nbsp;Some sample function invocations are<br>

  </li>

  <dl style="font-weight: bold;">

    <dd><span style="font-family: monospace;">&gt;&gt;&gt;
swap ((lambda x,y: y - 2*x),4,5)</span><br style="font-family: monospace;">

      <span style="font-family: monospace;">-6</span><br style="font-family: monospace;">

      <span style="font-family: monospace;">&gt;&gt;&gt;&nbsp;def
sb(x,y):</span><br style="font-family: monospace;">

      <span style="font-family: monospace;">&nbsp;
&nbsp; &nbsp;&nbsp; &nbsp;return x - y</span><br style="font-family: monospace;">

      <span style="font-family: monospace;">&gt;&gt;&gt;
swap(sb,4,5)</span><br style="font-family: monospace;">

      <span style="font-family: monospace;">1</span></dd>

  </dl>

  <dl>

    <dd></dd>

  </dl>

  <li>Exercise 3 and 4 illustrates how changing a given
function&rsquo;s
implementation can affect its time and space performance.</li>

</ol>

<dl>

  <dd>Our example is the exponentiation function, which raises a
number
to a positive integer power. Here is a very simple implementation: <br>

  </dd>

</dl>

<ol start="4">

  <ol>

    <span style="font-family: monospace;">&gt; power
:: Integer
-&gt; Integer -&gt; Integer&nbsp;&nbsp;</span>&nbsp;&nbsp;
    <br>

    <span style="font-family: monospace;">&gt; power a
0 = 1&nbsp;</span>&nbsp;<span style="font-family: monospace;">&nbsp;&nbsp; <br>

    </span> <span style="font-family: monospace;">&gt;
power a b = a *
power a (b-1)<br>

    <br>

    </span>
  </ol>

  <ol style="list-style-type: lower-alpha;">

    <li>[10pt]Show the steps in the evaluation of the expression<span style="font-family: monospace; font-weight: bold;"> power 2 5</span>.&nbsp;&nbsp;
How do the time and maximum space
required by the
evaluation of <span style="font-family: monospace;">power
n k</span>
depend on <span style="font-style: italic;">n </span>and
      <span style="font-style: italic;">k</span>?<br>

      <br>

    </li>

    <li>[5pt]Experiment with Hugs to determine for approximately
(&plusmn;100) how large a value of <span style="font-style: italic;">k</span>
the expression <span style="font-family: monospace; font-weight: bold;">power
2 k</span> can be
evaluated. The symptoms of failure vary somewhat depending on the
platform on which you&rsquo;re running Hugs&mdash; Hugs may
report a
stack overflow, or it may crash.<br>

      <br>

    </li>

    <li>[10pt]The cause of the limitation is the accumulation of
pending
multiplications, which is inherent in the way power is
defined&mdash;
each multiplication has to wait until its right argument has been
evaluated.<br>

    </li>

One way to eliminate the multiplication delay is to convert
the function&rsquo;s definition to a tail-recursive implementation:<br>

    <br>

    <span style="font-family: monospace;">&gt; powerT
:: Integer -&gt;
Integer -&gt; Integer</span><br style="font-family: monospace;">

    <span style="font-family: monospace;">&gt; powerT
a b = trp b 1</span><br style="font-family: monospace;">

    <span style="font-family: monospace;">&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
where</span><span style="font-family: monospace;"></span><br style="font-family: monospace;">

    <span style="font-family: monospace;">&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
trp n p = if (n==0) then p else trp (n-1) (a*p)<br>

    </span><br style="font-family: monospace;">

Show the steps in the evaluation of the expression <span style="font-family: monospace; font-weight: bold;">powerT 2 5</span>,
making sure not to
reduce any subexpression prematurely.&nbsp;&nbsp; <br>

Does the space
problem appear to be solved?<br>

    <br>

    <li>[5pt]Repeat the experiment for part (b)&nbsp; for <span style="font-family: monospace;">powerT.<br>

      <br>

      </span></li>

    <li>[10pt]Define <span style="font-family: monospace;">powerS
      </span>by
modifing <span style="font-family: monospace;">powerT</span>
to force
the accumulator argument to be evaluated prematurely, using the
operator ($!) as illustrated in <a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/2EhS05.html#factS">factS</a><span style="font-family: monospace;">.</span>Repeat the
experiment of part
(b) using your version of powerS, demonstrating that Hugs no longer
crashes.<br>

      <br>

    </li>

    <li><span style="font-family: monospace;"></span>[10pt]
Convert the
powerT to an iterative form (while loop) using the <a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/2EhS05.html#iterativeform">conversion</a>
technique discussed in class.<br>

      <br>

    </li>

  </ol>

  <li>In Exercise 3 we improved power&rsquo;s space
performance, but
all three versions take time linear in the exponent argument.] <br>

  </li>

  <ol style="list-style-type: lower-alpha;">

    <li>Confirm this by running power, powerT, and powerS on the
largest exponent for which you&rsquo;ve discovered that all three
succeed. Have Hugs count the number of reduction steps by turning on
the statistics flag: <br>

      <br>

    </li>

    <dl>

      <dd><span style="font-family: monospace;">Haskell2F07&gt;
:s +s <br>

        </span><br>

      </dd>

    </dl>

    <li>[5pt]Here is an algorithm which improves both time and
space
performance:</li>


    <dd>


      <dd style="margin-left: 80px;"><span style="font-family: monospace;"><br>
&nbsp; &nbsp; &gt;
turboPower a 0 = 1 <br>
&nbsp; &nbsp; &gt; turboPower a b <br>
&nbsp; &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; | even b = turboPower
(a*a) (b `div` 2) <br>
&nbsp; &nbsp; &gt;&nbsp;&nbsp;&nbsp;&nbsp; | otherwise = a *
turboPower a (b-1)</span></dd>
      <dd><span style="font-family: monospace;"></span></dd>
Instead of merely decrementing its first argument, this
algorithm
halves it whenever it is even, thereby reaching termination much more
quickly. Demonstrate it on the same arguments you used in part (a).<span style="font-family: monospace;"> </span><br>
      <span style="font-family: monospace;"></span><span style="font-family: monospace;">
      <br>

      </span>

    </dd>


    <li>Repeat the calculation of Exercise 3c using
turboPower.
You do not need to show the evaluation of the guard expression even b.
The recursive applications of turboPower give rise to multiple
instances of the parameter a; handle this by adding digits or prime
characters (') to distinguish between them.<br>
    </li>

    <li>In the <a href="Haskell2F07.lhs">programming
assignment</a>
you will convert turboPower version to a tail recursive version</li>

  </ol>

  <ol style="list-style-type: lower-alpha;">

    <br>
    <br>

  </ol>

</ol>

<br>

</div>

</body>
</html>
