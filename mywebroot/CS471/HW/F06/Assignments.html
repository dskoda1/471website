<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <title>Assignments</title>
</head>
<body>
<header>

</header>


<p>
Latest update Sep 21, 2000 (fixed typo from the Sep 5 version)
</p>


<p>To avoid spam, all mail addresses on this page have the "@" replaced by
"#".</p>


<h1>Assignments</h1>


<p> Credits: these assignments are to quite some degree based on <a href="http://www.it.kth.se/%7Ekff/">Karl-Filip Fax&eacute;n's</a> assignments for the
similar reading course "Nonstrict Functional Programming Languages" at <a href="http://www.it.kth.se/">KTH/IT</a>.  Some assignments are fetched from
Antony J. T. Davie: <a href="http://www.cup.org/Titles/25/0521258308.html"><em>An Introduction to
Functional Programming Systems Using Haskell</em></a>, and Simon Thompson:
<i><a href="http://www.cs.ukc.ac.uk/people/staff/sjt/craft2e/">Haskell: The
Craft of Functional Programming</a></i>. </p>


<p> Note that the assignments follow the order in Thompson's book only
crudely. In particular, there are sometimes follow-up questions which
request redoing an example using a more general technique which appears
later in the book.</p>


<p>
</p>
<ol>


  <p></p>
  <li>
    <p>(Thompson 3.12) Define a function to convert small letters to capitals
that returns unchanged characters which are not letters.</p>


    <p>Thus, write a function to convert all small letters in a string to
capitals! Write both a version that uses direct recursion, and a version
that uses some appropriate higher-order function on lists (guess
which...). </p>

  </li>
  <p></p>


  <p></p>
  <li>(Davie 2.3) Define a function to evaluate <i>m over n</i> = 
    <i>m!/n!(m-n)!</i>, <i>m</i>  &gt;= <i>n</i> (binomial numbers):</li>
  <p></p>


  <p>
  </p>
  <ol>


    <p></p>
    <li>Using the factorial function <i>fact</i> as a subsidiary.</li>
    <p></p>


    <p></p>
    <li>Using the recurrence relation 
      <ul>

        <li><i>m over n</i> =
  (<i>m</i>/<i>n</i>)(<i>m-1 over n-1</i>),
  for <i>m</i> &gt;= <i>n</i> &gt; 0</li>

        <li><i>m over 0</i> = 1, <i>m</i>  &gt;= 0</li>

      </ul>

    </li>
    <p></p>


    <p></p>
    <li>Using the recurrence relation
      <ul>

        <li><i>m over n</i> =
(<i>m-1 over n</i>) + (<i>m-1 over n-1</i>),
for <i>m</i> &gt;= <i>n</i> &gt; 0</li>

        <li><i>m over m</i> = 1, for <i>m</i> &gt;= 0</li>

      </ul>

    </li>
    <p></p>


  </ol>

Comment on the different algoritms used. Can the fact that
  <i>m over n</i> = <i>m-n over n</i> be of any use?

  <p></p>


  <p></p>
  <li>(Davie 3.15) Write a function that converts an integer to a string
of digits representing it in an arbitrary number base.</li>
  <p></p>


  <p></p>
  <li>(Davie 2.4) Define a function to calculate the square root of a
number, to some given accuracy, using Newton-Raphson's method. For the
square root function, this method replaces a guess <i>x</i> of the square
root of <i>a</i> with 0.5*(<i>x</i> + <i>a</i>/<i>x</i>). Break the
iteration when the difference between two successive iterates is less than
the specified accuracy. </li>
  <p></p>


  <p></p>
  <li>Now write a higher order function, which given a function <i>f</i>,
its derivative <i>f'</i>, initial guess, and accuracy, computes a numerical
solution to the equation <i>f</i>(<i>x</i>) = 0 by the general version of
Newton-Raphson's method, which computes a new guess
    <i>x</i>(<i>n</i>+1) from old guess <i>x</i>(<i>n</i>) according to
    <i>x</i>(<i>n</i>+1) = 
    <i>x</i>(<i>n</i>) -
    <i>f</i>(<i>x</i>(<i>n</i>))/<i>f'</i>(<i>x</i>(<i>n</i>)).</li>
  <p></p>


  <p></p>
  <li>Now abstract out the underlying computing structure even more: write
a general, higher-order function for iterative algorithms that iterates a
solution by applying a function until a convergence criterion is
fulfilled. The convergence criterion should also be a parameter. Reimplement
Newton-Raphson's method by calling this function with appropriate
parameters.</li>
  <p></p>


  <p></p>
  <li>(Thompson 5.13) Following the example in Thompson Ch. 5.6, define the
functions <tt>borrowers</tt>, <tt>borrowed</tt>, and
    <tt>numBorrowed</tt>. Define each in the three following ways:

    <ol>


      <p></p>
      <li>by direct recursion,</li>
      <p></p>


      <p></p>
      <li>using list comprehensions (not <tt>numBorrowed</tt>), and</li>
      <p></p>


      <p></p>
      <li>using higher-order functions on lists.</li>
      <p></p>


    </ol>

  </li>
  <p></p>


  <p>
  </p>
  <li>Give closed Haskell expressions <tt>e1</tt>, <tt>e2</tt>, <tt>e3</tt>
with the following most general types:
    <p></p>


    <p>
    </p>
    <ol>

      <p></p>
      <li> <tt>e1 :: a</tt>
        <p></p>


        <p></p>
      </li>
      <li>  <tt>e2 :: a -&gt; b</tt>
        <p></p>


        <p></p>
      </li>
      <li>  <tt>e3 :: a -&gt; a</tt>
        <p></p>

      </li>
    </ol>
    <p></p>

  </li>
  <p></p>


  <p></p>
  <li>
    <p>Write a <tt>bignum</tt> package for arithmetics on arbitrary-sized
integers by representing them as lists of fixed-size integers. (Do not use
the built-in <tt>Integer</tt> data type!) Define a data type for your
    <tt>bignum</tt>'s and make it an instance of the <tt>Num</tt> class. For the
conversion function <tt>fromInteger</tt>, you can assume that your
fixed-size integers are 32 bits long.</p>


    <p>When you have done the above, write a new version of the <tt>fact</tt>
function (p. 138 in Thompson's book) that uses your <tt>bignum</tt>'s. How
much new code do you have to write?</p>

  </li>
  <p></p>


  <p></p>
  <li>(Thompson 7.26) Design a function <tt>subst :: String -&gt; String -&gt;
String -&gt; String</tt> so that <tt>subst oldSub newSub st</tt> is the result
of replacing the first occurrence in <tt>st</tt> of <tt>oldSub</tt> by the
string <tt>newSub</tt>. If the substring <tt>oldSub</tt> does not occur in
    <tt>st</tt>, the result should be <tt>st</tt>.</li>
  <p></p>


  <p></p>
  <li>(Thompson 8.2) Give a definition of a multiplication function
    <tt>mult :: Int -&gt; Int -&gt; Int</tt> such that <tt>mult 0 (fact (-2))</tt>
evaluates to <tt>0</tt> (where <tt>fact</tt> is the factorial function, with
its "usual" recursive definition as on p. 138 in Thompson's book). What is
    <tt>mult (fact (-2)) 0</tt>? Explain why it is so.</li>
  <p></p>


  <p></p>
  <li>Haskell is a <em>lazy</em> (or "call-by-need") language. There are
other functional languages, such as ML and Scheme, which are <em>eager</em>
(or "call-by-value"): in these languages, function arguments are always
evaluated before the function is called. What would the result of a call to
the equivalent of <tt>mult 0 (fact (-2))</tt>, but in an eager language, be?
  </li>
  <p></p>


  <p></p>
  <li>(Davie 9.1, Thompson 8.4) Prove the associativity of the
    <em>append</em> operation <tt>++</tt> on lists (as defined on p. 122 in
Thompson's book):
    <pre>x ++ (y ++ z) = (x ++ y) ++ z<br></pre>

Hint: do not forget the case when some of the arguments are nonterminating!
 </li>
  <p></p>


  <p></p>
  <li>Are the following two expressions equivalent? Motivate your answer!

    <ol>


      <p></p>
      <li><tt>foldr (\ x y -&gt; f x + y) 0 xs</tt></li>
      <p></p>


      <p></p>
      <li><tt>foldr ((+) . f) 0 xs</tt></li>
      <p></p>


    </ol>


  </li>
  <p></p>


  <p></p>
  <li>(Thompson 13.2) Do the following pairs of types unify? If so, give a
most general unifier for them; if not, explain why they fail to unify.

    <ol>


      <p></p>
      <li><tt>Int -&gt; b</tt> and <tt>a -&gt; Bool</tt></li>
      <p></p>


      <p></p>
      <li><tt>(Int,a,a)</tt> and <tt>(a,a,Bool)</tt></li>
      <p></p>


    </ol>


  </li>
  <p></p>


  <p></p>
  <li>
    <p>(Davie 4.1) Infer the polymorphic types, disregarding class
constaints, of the following functions:</p>


    <p>
    </p>
    <pre>last [x]         = x<br>last (x:y:ys)    = last (y:zs)<br><br>length []        = 0<br>length (x:xs)    = length xs + 1<br><br>foldl f z []     = z<br>foldl f z (x:xs) = foldl f (f z x) xs<br><br>sum              = foldl (+) 0<br></pre>

    <p></p>

  </li>
  <p></p>


  <p></p>
  <li>
    <p>Infer the polymorphic type, with class constraints, of the
function <tt>foo</tt> defined below:</p>


    <p>
    </p>
    <pre>foo x:xs y:ys z:zs | y &lt; z     = x + foo xs ys zs<br>                   | y == z    = x + foo xs ys zs<br>                   | otherwise = foo xs ys zs<br>foo _ _ _ = 0<br></pre>

    <p></p>


  </li>
  <p></p>


  <p></p>
  <li>
    <p>To further your understanding of types, explain why</p>


    <p>
    </p>
    <pre>let f g x = (g x, g [x])<br>    g y   = [y]<br>in f g 'a'<br></pre>

    <p></p>


    <p>does not type check whereas</p>


    <p>
    </p>
    <pre>let f x = (g x, g [x])<br>    g y = [y]<br>in f 'a'<br></pre>

    <p></p>


    <p>does.</p>


  </li>
  <p></p>


  <p></p>
  <li>
    <p>Define a polymorphic algebraic data type for <em>binary trees</em> of
some type <tt>a</tt>, where a binary tree either is an element of type
    <tt>a</tt>, or a root with two subtrees that are binary trees.</p>


    <p>Now define functions over your data type that compute the following:</p>


    <ol>


      <p></p>
      <li>The number of leaves in a binary tree.</li>
      <p></p>


      <p></p>
      <li>The depth of a binary tree.</li>
      <p></p>


      <p></p>
      <li>A <tt>foldtree</tt> function that folds a binary tree with respect to
a binary function of type <tt>a -&gt; a -&gt; a</tt> (e.g., sums all elements in a
numerical binary tree).</li>
      <p></p>


      <p></p>
      <li>Finds whether a given element appears in a binary tree.</li>
      <p></p>


    </ol>


  </li>
  <p></p>


  <p></p>
  <li>
    <p>Using the Haskell modules, define an ADT for <em>multisets</em>.
Multisets are like sets, except that each element has a
    <em>multiplicity</em>, that is: the number of times (possibly zero) it
occurs in the multiset. Multisets are often called "bags" which should give
some additional intuition. The ADT should support the following
operations:</p>
 

    <p></p>
    <ol>


      <p></p>
      <li>test for empty multiset,</li>
      <p></p>


      <p></p>
      <li>creation of singleton multiset,</li>
      <p></p>


      <p></p>
      <li>multiplicity of given element,</li>
      <p></p>


      <p></p>
      <li>removal of element (some number of it), and</li>
      <p></p>


      <p></p>
      <li>sub-multiset relation (you should come up with some reasonable
definition, and then implement it).</li>
      <p></p>


    </ol>
    <p></p>
 

    <p>Provide at least two different implementations of your ADT!</p>


  </li>
  <p></p>


  <p></p>
  <li>
    <p>(Davie 7.1) Write programs to generate the following infinite
objects (in at least some case(s), use list comprehensions):</p>


    <p></p>
    <ol>


      <p></p>
      <li>the negative integers,</li>
      <p></p>


      <p></p>
      <li>the infinite list of powers of two,</li>
      <p></p>


      <p></p>
      <li>the terms of the series which sums to <i>e</i>**<i>x</i>, viz:
1 + (<i>x</i>/1!) +  (<i>x</i>**2/2!) + ...,</li>
      <p></p>


      <p></p>
      <li>the terms of the partial sums of the previous series, so that the
        <i>n</i>th term in this new list is the sum of the first <i>n</i> terms of
the first list,</li>
      <p></p>


    </ol>
    <p></p>
 

  </li>
  <p></p>


  <p></p>
  <li>(Davie 7.8) Write a function that takes a set (implemented as a
list) and produces its power set -- the set of all its subsets. It should
operate fairly on infinite lists, producing every finite subset in finite
time.</li>
  <p></p>


  <p></p>
  <li>
    <p><em>Synchronous stream programming</em> is an interesting
application of lazy programming, where the synchronous, potentially infinite
streams are modelled by lazy lists. Synchronous streams can be used to model
hardware on a "functional box" level, where functional units are connected
by synchronous channels. Define the following stream operations on lazy
lists representing streams:</p>


    <p></p>
    <ol>


      <p></p>
      <li>A <em>delay operation</em>, which shifts a stream backwards one step
in time. In the resulting stream, the first element is then
undefined.</li>
      <p></p>


      <p></p>
      <li>A <em>slowdown</em> operation, which "stretches out" a stream by a
factor <i>n</i> such that element <i>i</i> (starting with zero) in the input
stream goes to element <i>n</i>*<i>i</i> in the output stream. The other
elements in the output stream are undefined.</li>
      <p></p>


      <p></p>
      <li>A "fixed function" operation, which applies a given "scalar" function
to each element in a synchronous stream. (This one is easy!)</li>
      <p></p>


    </ol>
    <p></p>
 

  </li>
  <p></p>


  <p></p>
  <li>
    <p><em>Systolic arrays</em> are hardware structures which define (and
can be defined by) systems of synchronous streams. An example of an
algorithm which has a systolic hardware implementation is <i>n</i>-tap
    <em>FIR filtering</em> of a time sequence <i>x</i> with coefficients
    <i>a(1)</i>,...,<i>a</i>(<i>n</i>), where an output sequence
    <i>s</i> is defined by</p>


    <p>
    <i>s</i>(<i>k</i>) =
sum(<i>i</i>=1,...,<i>n</i>) a(<i>i</i>)*<i>x</i>(<i>k</i>-<i>i</i>),
    <i>k</i> &gt; <i>n</i>.
    </p>


    <p>A classical systolic array for FIR filtering is shown below:</p>


    <p>
    <img src="net.gif" align="middle">
    </p>


    <p>Here, the coefficients are stored one per cell. On each time cycle, data
is shifted into the cells, a multiply and add is performed in each cell, and
results are shifted out. The function of each cell is shown below:</p>


    <p>
    <img src="cell.gif" align="middle">
    </p>


    <p>If this array is fed with an input stream from the right, with a slowdown
of two and a timing as in the figure above, and if a sequence of
("two-slowdowned") zeroes is fed from the left, then each successive value
of the filtered sequence will successively computed by accumulating the
terms in the respective sums on its way to the right. (Use a pen and paper
to trace a few steps of the computation to convince yourself that this is
indeed true.)  </p>


    <p>Now, the assignment: write a function <tt>fir</tt> that models a systolic
array with the given architecture, which computes the FIR sequence from an
input sequence! As arguments it should take a list of <i>n</i> coefficients
and an input sequence. Also provide a straightforward Haskell implementation
of the FIR function, and validate your systolic solution vs. this
"specification" by a number of test runs.</p>


  </li>
  <p></p>


  <p></p>
  <li>Write a function that converts a function of type <tt>String -&gt;
String</tt> to a "unix filter" that reads a file (sequence of characters),
applies the string transformation function, and outputs the result!
Then use this function to convert your to-upper-case converter from
assignment 1 into a "filter", which does the same on files.</li>
  <p></p>


  <p></p>
  <li>
    <p>The "<tt>do</tt>"-notation for monads is really syntactic sugar for
the monadic operations <tt>&gt;&gt;=</tt> and <tt>&gt;&gt;</tt>. This sugar is
(essentially) resolved as follows:</p>


    <p>
    </p>
    <pre>do e1 ; e2      = e1 &gt;&gt; e2<br>do p &lt;- e1 ; e2 = e1 &gt;&gt;= \p -&gt; e2<br></pre>

    <p></p>


    <p>Apply this transformation to the example function on p. 393 in Thompson's
book (the "important example"). Now explain why the "assignment" of
identifiers in the <tt>do</tt>-notation is <em>not</em> the same as a
destructive assignment of a program variable in an imperative language!</p>


  </li>
  <p></p>


  <p></p>
  <li> Create a version of the state monad in Chapter 18.9 (pp. 409-411) in
Thompson's book, where the state is a store that holds a single integer.
Write new versions of <tt>return</tt>, <tt>&gt;&gt;=</tt>, and <tt>extract</tt> if
necessary. Write functions <tt>update</tt> and <tt>readstate</tt> that
overwrite the stored integer and read it, respectively (what types should
they have?). Then write a version of the factorial function that is purely
functional from the outside but implemented with state, imperatively,
internally!  </li>
  <p></p>


  <p></p>
  <li>
    <p>(Davie 10.1) Carry out the transformations that reduce the
comprehension</p>


    <p>
    </p>
    <pre>[ (n*n-n*m, 2*n*m, n*n+m*m) | n &lt;- [2..100],<br>                              m &lt;- [1..n-1],<br>                              gcd n m = 1,<br>                              odd (m+n)<br>]<br></pre>

    <p></p>


    <p>
to <tt>case</tt>-<tt>map</tt>-<tt>filter</tt>-form.
    </p>


  </li>
  <p></p>


  <p></p>
  <li>
    <p>(Davie 10.5) Use Burstall-Darlington techniques to transform the
following program into a more efficient form:</p>


    <p>
    </p>
    <pre>average x = sum x /length x<br><br>sum []    = 0<br>sum (h:t) = h + sum t<br><br>length []    = 0<br>length (_:t) = 1 + length t<br></pre>

    <p></p>


    <p>
Give an estimate of how much your transformation should improve the running
time!
    </p>

  </li>
  <p></p>


</ol>

<p></p>


<address>
<i>
<a href="http://www.idt.mdh.se/personal/blr/">Bj&ouml;rn Lisper</a><br>

<a href="mailto:bjorn.lisper#mdh.se"><i>bjorn.lisper#mdh.se</i></a><br>

</i>
</address>


</body>
</html>
