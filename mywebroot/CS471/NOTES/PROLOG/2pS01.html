<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html><head>



                     
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
                     
  <meta name="Author" content="Eileen Head">
                     
  <meta name="GENERATOR" content="Mozilla/4.76 [en] (Windows NT 5.0; U) [Netscape]"><title>Implementation of Prolog</title></head><body>
      
<center>   
<h2> &nbsp; PROgramming LOGic</h2>
  </center>
      
<center>  
<table bgcolor="#fffff0" border="1" cellpadding="3" cellspacing="3">
   <tbody>
      <tr>
   <td><small><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/4Spr00.html">&nbsp;</a><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/PROLOG/LOGIC.ppt">The
 Logical Model</a></small></td>
    <td><small>&nbsp;<a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/PROLOG/1pS01.html">Introduction</a></small></td>
    <td><small><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/PROLOG/3pS01.html">Unification</a></small></td>
    <td><small>&nbsp;<a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/PROLOG/2pS01.html">Backtracking</a></small></td>
    <td><small><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/PROLOG/PROLOG.ppt">Programming</a></small></td>
   </tr>
                  
  </tbody>  
</table>
  </center>
      
<h3> What will be covered ?</h3>
      
<ul>
   <li> Queries</li>
    <li> Backtracking: The Searching Mechanism</li>
     
</ul>
      
<hr width="100%">   
<p><b>Example: </b><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/CODE/PL/ghezzi">From
 Ghezzi p 385</a> <br>
  The transitive closure of <i>rel.</i> </p>
   
<blockquote>                
  <ol>
   <li> <b><tt><font color="#990000">relation(a,b).</font></tt></b></li>
    <li> <b><tt><font color="#990000">relation(a,c).</font></tt></b></li>
    <li> <b><tt><font color="#990000">relation(b,f).</font></tt></b></li>
    <li> <b><tt><font color="#990000">relation(f,g).</font></tt></b></li>
    <li> <b><tt><font color="#990000">closure(A,B) :- relation(A,B).</font></tt></b></li>
    <li> <b><tt><font color="#990000">closure(A,B) :- relation(A,Z), closure(Z,B).</font></tt></b></li>
                  
  </ol>
   <i>Try&nbsp; <tt>-&gt;<b> trace.</b></tt>&nbsp; in prolog to view the
execution  steps.</i> <br>
    <i>See Brassard&amp;Bratley problem 8.18</i> <br>
  The&nbsp; code below will abreviate <i>relation</i> to <i>rel</i> and <i>closure
   </i>to <i>clos.</i> <br>
  This is very similar to code presented page 631, Scott.</blockquote>
      
<h4>    
<hr width="100%">Queries</h4>
      
<ul>
   <li> A functional program is defined by a set of functions.&nbsp; Its
execution  is driven by evaluation of expressions.&nbsp;&nbsp;</li>
    <li>A <i>logic</i> <i>program</i> is <i>as a set of </i><b><font color="#000099">rules</font></b><i>; its executions answer a given </i><b><font color="#000099">query</font>.</b></li>
    <li> A query has the following form: <i>t</i><sub>1</sub>, <i>t</i><sub>2</sub>,
 ... <i>t<sub>k</sub></i><br>
    </li>
  Formal semantics :&nbsp; <i>t</i><sub>1</sub> AND <i>t</i><sub>2 </sub>AND
 ... <i>t<sub>k</sub></i> <br>
  Informally: Can we prove that&nbsp;&nbsp; <i>t</i><sub>1</sub> <b>and</b><i>
t</i><sub>2    </sub><b>and </b>... <i>t<sub>k&nbsp;</sub></i> are true from
the database  of facts?<li> Queries are also called <b><font color="#000099">goals</font></b>  and individual terms <b><font color="#000099">subgoals.</font></b></li>
    <li> The prolog runtime system will use the database of facts to deduce
 a goal.&nbsp; If it is successful, it will return <b><font color="#000099">yes</font>,</b> otherwise <b><font color="#000099">no</font>.</b></li>
                   
  <ul>
  Yes =&gt; Prolog can deduce some fact. <br>
  No =&gt; a failure to deduce some fact. <br>
  Rules cannot be used to deduce a negative facts.               
  </ul>
     
</ul>
      
<hr align="left" noshade="noshade" size="1" width="99%"> <tt><font color="#000000"><b>Consider the following prolog "</b>code"</font></tt>
 <br>
  <b><tt><font color="#990000">rel(a,b).</font></tt></b> <br>
  <b><tt><font color="#990000">rel(a,c).</font></tt></b> <br>
  <b><tt><font color="#990000">rel(b,f).</font></tt></b> <br>
  <b><tt><font color="#990000">rel(f,g).</font></tt></b> <br>
  &nbsp;   
<ul>
   <li> Queries with variables:</li>
                   
  <ul>
      <tt>?- rel(X,f).</tt> <br>
      <tt>X = b;</tt> <br>
      <tt>false.</tt>                          
    <ul>
  means, set of all X such that &lt;X,f&gt; is in <i>rel</i></ul>
                             
    <p>
      <tt>?- rel(a,X).</tt> <br>
      <tt>X = b;</tt> <br>
      <tt>X = c;</tt> <br>
      <span style="font-family: monospace;">false.</span><br>
 </p>
                          
    <ul>
  means, set of all X such that &lt;a,X&gt; is in <i>rel</i></ul>
                             
    <p>
      <tt>?- rel(a,X), rel(X,f)</tt>. <br>
      <tt>X = b;</tt> <br>
      <span style="font-family: monospace;">false.</span><br>
 </p>
                          
    <ul>
  means, set of all X such that &lt;a,X&gt; is in <i>rel </i><b>AND</b> &lt;X,f&gt;
 is in <i>rel</i>                        
    </ul>
                             
    <hr align="left" noshade="noshade" size="1" width="70%">              
  </ul>
    <li> Adding more complicated rules:</li>
                   
  <ul>
  &nbsp; <br>
      <b><tt><font color="#cc6600">rel(a,b).</font></tt></b> <br>
      <b><tt><font color="#cc6600">rel(a,c).</font></tt></b> <br>
      <b><tt><font color="#cc6600">rel(b,f).</font></tt></b> <br>
      <b><tt><font color="#cc6600">rel(f,g).</font></tt></b> <br>
      <b><tt><font color="#990000">clos(A,B) :- rel(A,B).</font></tt></b> 
    <br>
      <b><tt><font color="#990000">clos(A,B) :- rel(A,Z), clos(Z,B).</font></tt></b>
                         
    <ul>
                                      
      <ul>
  &nbsp;                                   
      </ul>
                            
    </ul>
                  
  </ul>
   <font color="#000000">1) for all A,B, &nbsp;&lt;A,B&gt; is in <i>clos</i>
 if &lt;A,B&gt; is in <i>rel</i></font> <br>
    <font color="#000000"><i>&nbsp;&nbsp;&nbsp; i.e.</i><i><b> </b></i>&lt;A,B&gt;
 is in the closure if &lt;A,B&gt; a relation</font> <br>
    <font color="#000000">2)OR <br>
  &nbsp; &nbsp; for all A,B in <i>clos&nbsp; </i>if there exists an Z such 
that &lt;A,Z&gt; is in <i>rel</i> AND &lt;Z,B&gt; is in <i>clos</i></font> 
    <br>
    <font color="#000000">&nbsp;&nbsp;&nbsp; i.e. &lt;A,B&gt; is in the closure
 if the is a </font><font color="#993300">relation</font><font color="#000000"> from A to some atom Z and then a </font><font color="#993300">closure</font><font color="#000000"> from Z to B.</font>
               
  <p><tt><font color="#000000">?- clos(b,X).</font></tt> <br>
    <tt><font color="#000000">X = f ;</font></tt> <br>
    <tt><font color="#000000">X = g ;</font></tt> <br>
    <span style="font-family: monospace;">false.</span><br>
 </p>
                
  <p><tt><font color="#000000">?- clos(a,f).</font></tt> <br>
    <span style="font-family: monospace;">true .</span>&nbsp;</p>
   
</ul>
      
<hr width="100%"><b><br>
Implementation Consideration</b>   
<dl>
  <dl>
    <li> Logical processors like Prolog are implemented in a procedure way.</li>
    <li> Finding the variables which make the logic program true is an NP
 problem.</li>
    <li> There are a number of different techniques to search/discover the
 variables</li>
    <li> Prolog uses <b>Backtracking</b></li>
    <dl>
      <li> Depth first search of the solution space</li>
      <li> Searching only feasible nodes</li>
      <dl>
        <li> sound proof procedure</li>
        <li> not complete</li>
        <dl>
          <li> i.e. completeness = if there is a finite proof of the goal
 it will be found.</li>
        </dl>
      </dl>
    </dl>
  </dl>
  <h4>                 
  <hr align="left" noshade="noshade" size="1" width="99%">Control in Prolog</h4>
  <dl>
    <li> A prolog program contains</li>
    <dl>
      <li> A sequence of clauses (forming the data base), and</li>
      <li> a query of the form&nbsp; <tt>A:- B<sub>1</sub>,B<sub>2</sub>,
 ... B<i><sub>n</sub></i></tt></li>
    </dl>
    <li> Program evaluation strategy: characterized by two decisions:</li>
    <dl>
      <li> <b>Goal order: </b>Subgoals are processed left <tt>--&gt;</tt>
 right</li>
      <li> <b>Rule order: </b>Rules are applied top <tt>--&gt;</tt> bottom</li>
    </dl>
  </dl>
</dl>
      
<hr width="100%"> &nbsp;<b>The Search Space for <tt>clos(a,f)<br>
  </tt></b>  
<div align="left">      
<p><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/PROLOG/Fig87.gif"><img style="width: 333px; height: 318px;" src="Fig87.gif" alt="Figure 8.7 from Ghezzi &amp; Jazayeri" border="0">
    </a></p>
    </div>
   
<ul>
    <li>Prolog will not let you continue the search after success. (i.e.
";")  Why?</li>
   
</ul>
   
<center>  </center>
   
<blockquote>  </blockquote>
        
<hr width="100%"></body></html>