<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html><head>



<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="Author" content="Eileen Head">
<meta name="GENERATOR" content="Mozilla/4.73 [en] (Win98; U) [Netscape]"><title>Introduction To Programming Languages- CS471</title></head><body>
&nbsp;
<center><span style="font-weight: bold;"><h3>Introduction</h3>
</span>
</center>
<center>
</center>
<center>Instructor: <a href="mailto:head@binghamton.edu">E.
Head</a></center>
<h3> Why Study Programming Languages?</h3>
<ul>
<li> Learn new ways to think and express solutions to problems.</li>
<li> To improve your use of existing languages.</li>
<li> Increase you ability to learn new languages.</li>
<li> Learn methods to evaluate languages.</li>
<li> Gives criteria for designing your own language.</li>
</ul>
<h3>
<hr width="100%"></h3>
<h3>What is Computer Science? <br>
</h3>
<ul>
<li>"<a href="https://en.wikipedia.org/wiki/Computer_science">Computer science is the study of automating algorithmic processes that scale. A </a><a href="https://en.wikipedia.org/wiki/Computer_science" title="Computer scientist">computer scientist</a><a href="https://en.wikipedia.org/wiki/Computer_science"> specializes in the theory of computation and the design of computational systems.</a><a href="https://en.wikipedia.org/wiki/Computer_science"> "</a>&nbsp;
</li>
</ul>
<h3> What is a <i>programming language?</i></h3>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Computer_science#Programming_language_theory">"Programming language theory is a branch of computer science that deals 
with the design, implementation, analysis, characterization, and 
classification of </a><a href="https://en.wikipedia.org/wiki/Computer_science#Programming_language_theory" title="Programming language">programming languages</a><a href="https://en.wikipedia.org/wiki/Computer_science#Programming_language_theory"> and their individual </a><a href="https://en.wikipedia.org/wiki/Computer_science#Programming_language_theory" title="Programming language">features</a><a href="https://en.wikipedia.org/wiki/Computer_science#Programming_language_theory">. It falls within the discipline of computer science, both depending on and affecting </a><a href="https://en.wikipedia.org/wiki/Computer_science#Programming_language_theory" title="Mathematics">mathematics</a><a href="https://en.wikipedia.org/wiki/Computer_science#Programming_language_theory">, </a><a href="https://en.wikipedia.org/wiki/Computer_science#Programming_language_theory" title="Software engineering">software engineering</a><a href="https://en.wikipedia.org/wiki/Computer_science#Programming_language_theory"> and </a><a href="https://en.wikipedia.org/wiki/Computer_science#Programming_language_theory" title="Linguistics">linguistics</a>".<br>
    <br>
</li>
  <li> A <b><i>programming language</i></b>
is a formal notational
system for describing <span style="font-style: italic;">computation</span>
in <span style="font-style: italic;">machine-readable</span>
and <span style="font-style: italic;">human-readable</span>
form.<br>
    <br>
  </li>
  <li>Programming language theory considers various approaches to the <span style="font-style: italic;">description of computation</span>.<br>
  </li>

<ul></ul>
<ul>
<dl>
<dd><span style="font-style: italic;"><br>
</span></dd>
</dl>
</ul>
<li>A successful programming language has the facilities for <span style="font-weight: bold;">data abstraction</span> and
<span style="font-weight: bold;">control abstraction.</span></li>
</ul>
<div style="margin-left: 40px;">
Abelson and Sussman (<span style="font-style: italic;">Structure
and
Interpretation of Computer Programs </span>1996)<br>

"<a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-7.html">
We control complexity by building abstractions that hide
details when appropriate. We control complexity by establishing
conventional interfaces that enable us to construct systems by
combining standard, well-understood pieces in a ``mix and match'' way.
We control complexity by establishing new languages for describing a
design, each of which emphasizes particular aspects of the design and
deemphasizes others."</a></div>

<ul>
<ul>
</ul>
</ul>
<h4>What are programs used <i>for</i>:</h4>
<ul>
<li>Original view: Programs are used to <b><i>control
computers</i></b></li>
<li>Modern view:&nbsp;</li>
<ul>
<li>Programs are used to<i><b> specify
computations</b></i>. &nbsp;</li>
</ul>
<ul>
<li>Computers are used to perform the specified
computations.&nbsp;</li>
<li>A programs most important audience<b> are people NOT</b>
machines.<br>
</li>
</ul>
</ul>
<h4>Why are there so many languages?</h4>
<ul>
<li>Different hardware (old view)</li>
<li>Different domains (applications)</li>
<li>Need for better tools that yield software that is more
trustworthy, faster and less expensive.</li>
</ul>
<ul>
<ul>
</ul>
</ul>
<h3>
<hr width="100%"></h3>
<h3> What will be cover ?</h3>
<ul>
<li> <font color="#990000">Judging the design of
a languages</font></li>
<li> <font color="#990000">History of programming
languages</font></li>
<li> Different Language Paradigms</li>
<li> Implemention and Run Time Environment</li>
</ul>
<hr align="left" noshade="noshade" width="99%">
<h3> </h3>
<ul>
</ul>
<h3> How do we judge a programming language?</h3>
<ol>
<li>What is the extent of support for program correctness?</li>
<li>What is the cost of program development and modification?</li>
<li>What is the cost of using the program (execution time and
space)?</li>
</ol>
<i>Total cost</i> is a combination of 2 and 3. &nbsp;<br>
There are trade-offs <br>
<ul>
</ul>
<h3>
<hr align="left" noshade="noshade" size="1" width="99%"></h3>
<h3><a name="History"></a> Brief History of
Programming Languages</h3>
<ul>
<li> 1944, <a href="http://ei.cs.vt.edu/%7Ehistory/VonNeumann.html">Von
Neumann </a>described a <i>stored</i> <i>program
computer</i></li>
<ul>
<li> Each program for the first computers had to be hard
wired by
hand.</li>
<li> Later switches were put on a console</li>
</ul>
<li> The original view of a program was to <b>control a
computer</b></li>
<br>
<hr width="100%"> <li>1951, <a href="http://www.acm.org/awards/turing_citations/wilkes.html">Wilkes</a>,
Wheeler and Gill published <a href="http://www-mitpress.mit.edu/catalog/item/default.asp?sid=73FCDE9A-BC68-40D7-9D25-EDE24ADB7CFF&amp;ttype=2&amp;tid=6497">The
Preparation of Programs for an Electronic Digital Computer</a>
which
described an <i>assembler.</i></li>
<ul>
<li>It presents an elegant symbolic notation and coding for
the
large subroutine library that provided the building blocks for an array
of programs.<br>
</li>
<li> Subroutines were written in machine code</li>
<ul>
<ul>
00001011 <br>
10100101 <br>
...
</ul>
</ul>
</ul>
<li> 1949, assembly language introduced mnemonics to represent
machine instructions with a <i>program</i> to translate it
into
machine
code.</li>
<ul>
<ul>
<ul>
&nbsp; <br>
<tt>LDA&nbsp;&nbsp;&nbsp; STOR1</tt> <br>
<tt>ADD&nbsp;&nbsp;&nbsp; STOR2</tt> <br>
<tt>STA&nbsp;&nbsp;&nbsp; STOR3</tt> <br>
<tt>JNZ&nbsp;&nbsp;&nbsp; LOC17</tt>
</ul>
</ul>
<li> Assemblers are programs that convert assembly programs
to
machine code.</li>
<li> Is an abstraction of machine instructions and memory
addresses.</li>
</ul>
<hr width="100%"> <li>1949, <a href="http://www.cs.yale.edu/homes/tap/Files/hopper-story.html">Grace
Hopper</a> developes the first computer compiler and publishes
the
first paper on compilers in 1952</li>
<ul>
<li><a href="http://www.waterholes.com/%7Edennette/1996/hopper/bug.htm">First
computer BUG</a></li>
</ul>
<li> 1954-57, <a href="http://www-gap.dcs.st-and.ac.uk/%7Ehistory/Mathematicians/Backus.html">John
Backus</a> developed FORmula TRANslation the first widely
accepted
compiled language.</li>
<ul>
<ul>
<ul>
&nbsp; <br>
SUM = 0.0 <br>
SUM = SUM + ARR(I) <br>
IF (SUM .GT. 20.5) STOP
</ul>
</ul>
<li> Fortran is first high-level language</li>
<li> A <i>high-level </i>language is simply a
programming
language
whose instruction format is</li>
<ul>
<li> More closely related to the problem domain of the
problem
than to the instructions of the computer that will run the program.</li>
</ul>
<li> Fortran influenced Algol 60 and its decendents, PL/I,
BASIC</li>
</ul>
<hr width="100%"><li>Mid 50s, interest developed
in solving
non-numerical problems.</li>
<li> 1956, Allen Newell, J.C. Shaw and Herbert Simon published
a
paper that described the first AI program and a language that could
implement
it.</li>
<ul>
<li> It was too low level to be widely accepted.</li>
</ul>
<li> 1956-62, <a href="http://www-formal.stanford.edu/jmc/frames.html">J.
McCarthy</a> developed <b>LIS</b>t <b>P</b>
rocessing the first
highly
successful symbol processing language for AI</li>
<ul>
<ul>
<ul>
&nbsp; <br>
(DEFUN SUM_LIST(L) <br>
(+(CAR L)(SUM_LIST(CDR L)))<br>
</ul>
</ul>
<li> First accepted language not based on controlling a
machine but
based on the (mathematic) computational model, <b><i>Lambda
Calculus. <br>
</i></b></li>
<li>Second oldest language in use.</li>
<li>Computes by substitution and reduction.<br>
</li>
<li> Recursive functions is the<b> key programming
technique</b></li>
<li> In addition to introducing recursion, Lisp introduced:</li>
<ul>
<li> garbage collection</li>
<li> conditional expressions</li>
<ul>
<li> Algol's conditional expression was suggested by
McCarthy
who was a member of the Algol committee.</li>
</ul>
<li> interactive program execution</li>
</ul>
<li> ML (Milner 1978), Miranda(1986) and <b><font color="#3333ff">Haskell</font></b>
(1988) are pure functional languages that are influenced by Lisp.</li>
</ul>
<hr width="100%"> <li> 1958-60, Committee
developed ALGOL 60 to
provide a general, expressive language for describing algorithms.</li>
<ul>
<li> The most important milestone in developing modern
languages.</li>
<ul>
<li> Algol 60 led to Algol 68 which led directly to <font color="#990000"> C</font> and then <font color="#990000">C++</font> .</li>
<li> Algol 60 led to Algol W which led to Pascal and Ada</li>
<li> Algol 60 led to Simula and then Simula 67 and then
Smalltalk</li>
</ul>
<li> Many reason Algol 60 was not widely accepted language</li>
<ul>
<li> Too flexible which made it hard to difficult to
understand
and to implement efficiently.</li>
</ul>
<li> Introduced:</li>
<ul>
<li> block structures</li>
<li> recursive function calls to procedural languages</li>
<li> first language whose syntax was formally described
(using
BNF)</li>
<ul>
<li> Backus was a principle member of the design team</li>
<li> Interesting in the 60s BNF seemed too complicated
and was
one of the reason Algol 60 was not accepted.</li>
</ul>
<li> Affected the design of some Burroughs machines to
include
stack which enable an efficient implementation of block structures and
recursive procedures.</li>
<br>
<hr width="100%">
</ul>
</ul>
</ul>
<ul>
<li> 1963-68, Committee developed Algol 68 was designed to be a
general purpose language as opposed to having the scientific
orientation
of Algol 60.</li>
&nbsp; <br>
<ul>
<li> Design goal was to make the various features of the
language
as <i>
orthogonal </i>as possible.</li>
<ul>
<li> <b><i>Orthogonality</i>&nbsp; </b>means
that:</li>
<ul>
language features can be used in any combination, <br>
the combinations all make sense <br>
meaning of a given feature is consistent.
</ul>
<li> Did not distinguish between <i>expressions and
statements</i></li>
</ul>
<li> Introduced:</li>
<ul>
<li> User-defined data types</li>
<li> dynamic arrays</li>
</ul>
<li> The use of an unknown metalanguage to describe the
language
was
one of the reason the language was not accepted and the difficulty of
implementing the language.</li>
</ul>
<hr width="100%"> <li> 1965-67 Nygaard &amp;
Dahl created Simula 67
the first object oriented language</li>
<ul>
<li> It was invented for writing simulation programs</li>
</ul>
<ul>
<li> Programs in Simula is a model of some process in the
real
world
as opposed to a set of actions that we want a computer to carry out.</li>
</ul>
<ul>
<li> Introduced "classes"</li>
</ul>
<ul>
<li> Smalltalk80 follows from Simula67.</li>
<ul>
<li>Developed as part of the ALTO project at Xerox Parc<br>
</li>
<li>Adele Goldberg and Alan Kay presented the goals for the
Smalltalk research efforts in a paper entitled "Personal Dynamic Media"<i>
</i>(<i>IEEE
Computer,</i> March 1977).</li>
<li>Adele Goldberg and Dan Ingalls were original members of
the
Smalltalk development team.<br>
</li>
<li>First object oriented language<br>
</li>
<li>squeak is a direct decendent of Smalltalk</li>
<li>First version of Smalltalk developed in 1972.<br>
</li>
<li><a href="http://www.parc.com/about/milestones.html">Xerox
Parc's Milestones</a><br>
</li>
</ul>
<li><a href="http://archive.eiffel.com/general/people/meyer/">Eiffel</a>
(Bertand Meyer)&nbsp; follows also from Simula67.</li>
</ul>
<ul>
<li> <font color="#990000">Java</font>&#8217;s
semantics follows from
Smalltalk but the syntax follows from C.</li>
</ul>
</ul>
<hr size="2" width="100%">
<ul>
<li> 1974-1983, international committee created Ada which was
to be
"one" for use by the Dept. Of Defense (DoD).</li>
<ul>
<li> In 1974, the US Government studied the languages in use
by the
Department of Defense (DoD):</li>
there were more than 450 in use in the DoD alone!
<ul>
<li> several thousand programming languages have been
developed</li>
</ul>
<li> The lead designer of Ada (Jean Ichbiah) claims that only
Ada
can be used safely for programs over 1,000,000 lines of code</li>
<li> Any large piece of software (at least 100,000 lines of
code)
WILL have errors</li>
<li> Ichbiah&#8217;s claim is that programs of that size in C or
C++ are
simply unfixable</li>
<li> A sophisticated word processor could be around 300,000
lines</li>
<li> The new air-traffic control system is supposed to be
getting
close 10 million lines of code</li>
&nbsp;
</ul>
<hr width="100%"> <li> Early 70s, Alain and
Colmerauer, Phillippe
Roussel (France) and Robert
Kowalski (Edinburgh) developed the fundamental design of
Prolog.</li>
<ul>
<li> <b><font color="#000099">Prolog</font></b>
is
logic-programming
languages (called fifth-generation languages in the 80&#8217;s)</li>
<li> Programs consist of a data base and rules that are
queried.</li>
<li> ISO standard became available late in 1995.</li>
<li> Principle mechanism</li>
<ul>
<dl>
<li> Unification, relations, Horn clauses</li>
</dl>
</ul>
</ul>
<hr width="100%"> <li> There are many
applications-generator
languages</li>
<ul>
<li> they started with COBOL-generators in the 70&#8217;s and 80&#8217;s.</li>
<ul>
<li><a href="http://www.jamesshuggins.com/h/tek1/grace_hopper.htm">Grace
Hopper</a><br>
</li>
</ul>
<li> now we have Visual Basic, Javascript, etc.</li>
</ul>
<li> There are scripting
languages (immediately executable)</li>
<ul>
<li>JCL - first used to control the flow of batch jobs<br>
</li>
<li>Unix (Linux) sh, csh, tcsh, bash<br>
</li>
<ul>
<li>Used to "glue" together utilities (programs) to create
new
applications</li>
<li>made Unix popular</li>
</ul>
<li>DOS, REXX, ORexx</li><li>Common Features of scripting languages:</li>
<ul><li>Usually dynamically typed <br>
</li></ul>
<ul><li>Excellent string faculties (regular expressions)<br>
</li></ul>
</ul>
<ul>
<li><a href="http://www.cs.uu.nl/docs/vakken/st/nawk/nawk_toc.html">AWK</a>
- 1977/1985&nbsp; <a href="http://www1.cs.columbia.edu/%7Eaho/">Alfred
V. Aho</a>, Peter J. Weinberger, and <a href="https://www.cs.princeton.edu/%7Ebwk/">Brian
W.
Kernighan</a> designers</li><li><a href="http://www.tcl.tk/#shells" target="_blank">Tcl/Tk</a></li><ul><li>1980s by John Ousterhout&nbsp;</li><li>Tcl - Tool Command Language</li><li>Tk- began as a component GUI&nbsp; extension to Tcl. </li></ul><li>Perl</li><ul><li>1987, Larry Wall began work on Perl</li><li>Perl was originally named "Pearl," after the <a href="http://en.wikipedia.org/wiki/Parable_of_the_Pearl" title="Parable of the Pearl">Parable of the Pearl</a> from the <a href="http://en.wikipedia.org/wiki/Gospel_of_Matthew" title="Gospel of Matthew">Gospel of Matthew</a>.</li><li>Slashdot, bioinformatics, financial data processing, cgi</li></ul>
<li>Python</li><ul>

<li>was <a href="http://www.artima.com/intv/pythonP.html">conceived in
the late 1980s</a> by&nbsp;<strong style="font-weight: normal;">Guido van Rossum</strong></li><li>System administration at Google</li><li>BitTorrent file sharing system</li>

</ul><li>Ruby was designed and developed by Yukihiro Matsumoto
in 1993-95</li><ul><li>various blogs, data processing applications,&nbsp;</li><li>Ruby On Rails is a web-application framework for the MVC pattern that includes
both a template engine, controller framework, and object-relational
mapping package. Everything needed to develop web-apps that can run on
CGI, FastCGI, and mod_ruby (Apache module).</li></ul><li>PHP</li><ul><li>PHP/FI was
    created by Rasmus Lerdorf in 1995 (Personal Home Page / Forms Interpreter)</li><li>Yahoo web site</li></ul><li>JavaScript (early names Mocha then LiveScript)</li><ul><li>Written by Brendan
Eich in 1996 to enable non-programmers to process numbers and modify
contents of forms. &nbsp;Easier than Java applets -- syntax resembled
Java.</li><li>Google Maps<br></li></ul>

</ul>
<li> There are macro-languages, especially for spreadsheets,
e.g. for
Lotus, Excel, Quattro</li>
<li> There are languages to display documents, HTML, XML, SGML</li>
<li> There are languages compiled into an intermediate language</li>
<ul>
<li> PERL, Java, Pascal <br>
</li>
</ul>
</ul>
<hr width="99%"><br>
<br>
</body></html>