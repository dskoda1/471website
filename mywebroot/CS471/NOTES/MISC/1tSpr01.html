<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="Author" content="Head/ Lander">
   <meta name="GENERATOR" content="Mozilla/4.73 [en] (Win98; U) [Netscape]">
   <meta name="Description" content="CS471 spr 00">
   <title>Multi-Threading and Java</title>
</head>
<body text="#000000" bgcolor="#F5F5F5" link="#00FF00" vlink="#666666" alink="#FF0000">
&nbsp;
<center><table BORDER CELLSPACING=0 CELLPADDING=0 BGCOLOR="#FFFFF0" >
<tr>
<td><a href="http://bingweb.binghamton.edu/~head/CS471/471notesIndex.html">Index</a></td>
</tr>
</table></center>

<center>
<h3>
Threads 1</h3></center>

<center>
<h3>
&copy; Eileen Head, Leslie C. Lander, 2000</h3></center>

<h2>
Purpose: The expose the student to how multi-threading can be supported
in a language.&nbsp;
<hr WIDTH="100%">Java Threads</h2>

<h3>
Threads (from the Java Tutorial)</h3>

<ul>
<li>
A thread is a single sequential flow of control within a program</li>
</ul>

<center><img SRC="threads.gif" height=165 width=301></center>

<h3>
Processes</h3>

<ul>
<li>
A process refers to a single sequential flow of control with its own resources</li>

<li>
Thread s shares the same data segment (also referred to as execution context
or a lightweight process)</li>
</ul>

<center><img SRC="threads2.gif" height=103 width=292></center>

<h3>
Applications that use multiple threads</h3>

<ul>
<li>
A server providing services to others</li>

<ul>
<li>
One thread for each client. (network server)</li>
</ul>

<li>
A real-time control computer controlling a factory</li>

<ul>
<li>
One thread for each device that needs monitoring</li>
</ul>

<li>
Graphical interfaces.</li>

<ul>
<li>
Create a more responsive GUI.</li>

<li>
A separate thread to react to user events.</li>

<li>
A separate thread to do intense computation.</li>
</ul>
</ul>

<h3>
Producing Java MultiThreaded Code</h3>

<ul>
<li>
Subclassing Thread class and overriding run:</li>

<pre><b><tt>public class SimpleThread extends Thread {&nbsp;
&nbsp;&nbsp;&nbsp; public SimpleThread(String str) {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super(str);&nbsp;
&nbsp;&nbsp;&nbsp; }&nbsp;

&nbsp;&nbsp;&nbsp; public void run() {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 9; i++) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(i+" "+getName( ));&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sleep((int)(Math.random( )*1000));&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch (InterruptedException e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("done! "+getName( ));
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // From the Online Tutorial
&nbsp;&nbsp;&nbsp; }
}</tt></b></pre>
</ul>

<h3>
Running it</h3>

<blockquote>
<pre><b><tt>public static void main (String [] a) {&nbsp;
&nbsp;&nbsp;&nbsp; new SimpleThread("Jamaica").start();&nbsp;
&nbsp;&nbsp;&nbsp; new SimpleThread("Fiji").start();
}</tt></b></pre>
</blockquote>

<center><table BORDER >
<tr>
<td><tt>0 Jamaica</tt>
<br><tt>0 Fiji</tt>
<br><tt>1 Jamaica</tt>
<br><tt>1 Fiji</tt>
<br><tt>2 Jamaica</tt>
<br><tt>3 Jamaica</tt>
<br><tt>2 Fiji</tt></td>

<td><tt>4 Jamaica</tt>
<br><tt>3 Fiji</tt>
<br><tt>5 Jamaica</tt>
<br><tt>4 Fiji</tt>
<br><tt>5 Fiji</tt>
<br><tt>6 Jamaica</tt>
<br><tt>6 Fiji</tt></td>

<td VALIGN=TOP><tt>7 Jamaica</tt>
<br><tt>7 Fiji</tt>
<br><tt>8 Fiji</tt>
<br><tt>done! Fiji</tt>
<br><tt>8 Jamaica</tt>
<br><tt>done! Jamaica</tt></td>
</tr>
</table></center>

<h3>
Implementing Runnable</h3>

<ul>
<li>
Most times you need to subclass a class other than thread.</li>

<ul>
<li>
e.g. applet</li>
</ul>

<li>
Implement runnable</li>

<ul>
<li>
implement run method</li>

<li>
create object</li>

<li>
create a new Thread using the constructor that expects a runnable object</li>

<li>
start the thread</li>
</ul>
</ul>

<h3>
Producing Java MultiThreaded Code</h3>

<ul>
<li>
Implementing runnable</li>

<pre><b><tt>public class SimpleRun implements Runnable {&nbsp;
&nbsp;&nbsp;&nbsp; public void run() {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; 9; i++) {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println(i + " " + Thread.currentThread().getName( ));&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread.sleep((int)(Math.random( )*1000));&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch (InterruptedException e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System.out.println("DONE! " + Thread.currentThread().getName( ));&nbsp;
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp; public static void main (String [] a) {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Thread(new SimpleRun(), "Jamaica")).start();&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Thread(new SimpleRun(), "Fiji")).start();&nbsp;
&nbsp;&nbsp;&nbsp; }
} // Modified from the Online Tutorial</tt></b></pre>
</ul>

<h3>
Running it</h3>
&nbsp;
<center><table BORDER >
<tr VALIGN=TOP>
<td><tt>0 Jamaica&nbsp;</tt>
<br><tt>0 Fiji&nbsp;</tt>
<br><tt>1 Jamaica&nbsp;</tt>
<br><tt>1 Fiji&nbsp;</tt>
<br><tt>2 Jamaica&nbsp;</tt>
<br><tt>3 Jamaica&nbsp;</tt>
<br><tt>2 Fiji</tt>
<br><tt>4 Jamaica</tt></td>

<td><tt>3 Fiji&nbsp;</tt>
<br><tt>5 Jamaica&nbsp;</tt>
<br><tt>4 Fiji</tt>
<br><tt>5 Fiji&nbsp;</tt>
<br><tt>6 Jamaica&nbsp;</tt>
<br><tt>7 Jamaica&nbsp;</tt>
<br><tt>6 Fiji&nbsp;</tt></td>

<td><tt>7 Fiji&nbsp;</tt>
<br><tt>8 Fiji&nbsp;</tt>
<br><tt>9 Fiji&nbsp;</tt>
<br><tt>8 Jamaica&nbsp;</tt>
<br><tt>9 Jamaica&nbsp;</tt>
<br><tt>DONE! Jamaica&nbsp;</tt>
<br><tt>DONE! Fiji</tt></td>
</tr>
</table></center>

<br>&nbsp;
<br>&nbsp;
<h3>
Animation: Outline</h3>

<ul>
<li>
See Online Tutorial:</li>

<li>
User Interfaces</li>

<li>
http://java.sun.com/docs/books/ tutorial/ui/drawing/animation.html</li>
</ul>

<h3>
Animation</h3>

<ul>
<li>
AnimatorApplication.java</li>

<li>
convert frames per seconds to milliseconds delay = (fps > 0) ? (1000 /fps)
: 100</li>

<li>
Animation Loop … in the run method of animation thread</li>
</ul>

<h3>
Animation loop</h3>

<blockquote>
<pre>while ( running thread ) {&nbsp;

&nbsp;&nbsp;&nbsp; // advance the frame&nbsp;

&nbsp;&nbsp;&nbsp; ...&nbsp;

&nbsp;&nbsp;&nbsp; frameNumber ++;&nbsp;

&nbsp;&nbsp;&nbsp; // Display it repaint ();

&nbsp;&nbsp;&nbsp; ...

}</pre>
</blockquote>

<h3>
Animation: Constant Frame Rate</h3>

<blockquote>
<pre>constant frame rate:&nbsp;

&nbsp;&nbsp;&nbsp; // in the run method's while&nbsp;

&nbsp;&nbsp;&nbsp; try {&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; startTime += delay;&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Thread.sleep(Math.max(0, startTime - System.currentTimeMillis( )));&nbsp;

&nbsp;&nbsp;&nbsp; } catch (InterruptedException e) {&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;

&nbsp;&nbsp;&nbsp; }</pre>
</blockquote>

<h3>
Animation- Behaving Politely</h3>

<ul>
<li>
Allowing the user to suspend the animation - add a mouse listener:</li>

<pre>addMouseListener(&nbsp;
&nbsp;&nbsp;&nbsp; new MouseAdapter() {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void mouseClicked (MouseEvent e) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (frozen) {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frozen = false;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; startAnimation();&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; frozen = true;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stopAnimation();&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;
&nbsp;&nbsp;&nbsp; }
);</pre>
</ul>

<h3>
Synchronization</h3>

<ul>
<li>
Now, the sleep( ) method has some problems and we have not shown how to
arrange for synchronization between different threads</li>

<li>
Every object in Java has a lock to manage synchronization</li>

<li>
In fact, each class also has a lock</li>

<li>
We concentrate on the object lock</li>
</ul>

<h3>
Synchronized Methods</h3>

<ul>
<li>
We can imagine code for a bank account class Account, with the methods
"withdraw," "deposit" and "balance"</li>

<li>
They should be:</li>

<ul>
<li>
synchronized void withdraw(…)</li>

<li>
synchronized void deposit(…)</li>

<li>
synchronized void balance(…)</li>
</ul>
</ul>

<h3>
Coordination</h3>

<ul>
<li>
Why synchronized?</li>

<li>
Two programs should not try to deposit at the same time because the balance
will be corrupted (the same goes for deposit)</li>

<pre>synchronized void deposit(long L) {&nbsp;

&nbsp;&nbsp;&nbsp; balance += L;

}</pre>
</ul>

<h3>
Execution possibilities</h3>

<ul>
<li>
Suppose Thread t1 and Thread t2 may both call acctObj.deposit(L) at the
same time</li>

<li>
We explain in a moment the best way to let t1 and t2 to share the acctObj</li>

<li>
If deposit is called twice on the same object, we could be doing either
of the following:</li>
</ul>

<h3>
The order can interleave in any way</h3>

<center><table BORDER >
<tr>
<td><b>In t1</b>
<br>1.1 load balance&nbsp;
<br>1.2 add L1 to register&nbsp;
<br>1.3 store balance</td>

<td><b>In t2</b>
<br>2.1 load balance&nbsp;
<br>2.2 add L2 to register&nbsp;
<br>2.3 store balance</td>
</tr>
</table></center>

<h3>
Singleton pattern</h3>

<ul>
<li>
There is a "correct" way for various objects to share the same object</li>

<li>
We frequently compose an object into some larger object</li>

<pre><b>class C {&nbsp;
&nbsp;&nbsp;&nbsp; X x = ...;
&nbsp;&nbsp;&nbsp; ...
}</b></pre>

<li>
Suppose multiple instances of C (c1, c2, c3, …) need the same instance
x</li>
</ul>

<h3>
The singleton</h3>

<ul>
<pre><b><tt>class X {&nbsp;
&nbsp;&nbsp;&nbsp; private static final X s = new X();
&nbsp;&nbsp;&nbsp; //created when class is loaded&nbsp;
&nbsp;&nbsp;&nbsp; private X ( ) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp; } -- no code is necessary&nbsp;
&nbsp;&nbsp;&nbsp; public static final X getHandle() {&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return s;&nbsp;
&nbsp;&nbsp;&nbsp; }
}</tt></b></pre>

<li>
The constructor of C includes</li>

<pre>x = X.getHandle();</pre>

<li>
so <tt>c1.x, c2.x, c3.x</tt> are all the same "s"</li>
</ul>

<h3>
Need lock to execute</h3>

<ul>
<li>
Synchronized methods prevent multiple access to the same data</li>

<li>
You can only execute a synchronized method when you have the lock on the
object whose method is being called</li>
</ul>

<h3>
Obtaining the lock</h3>

<ul>
<li>
When a synchronized method is called, the caller has to obtain the object’s
lock before the method is executed:</li>
</ul>

<center><img SRC="lock1.gif" height=99 width=227></center>

<h3>
Lock is closed</h3>

<ul>
<li>
If the lock is not free, the calling thread waits.</li>
</ul>

<center><img SRC="lock2.gif" height=109 width=241></center>

<h3>
Lock is free</h3>

<ul>
<li>
If the lock is free the thread continues and executes the code in the method:</li>
</ul>

<center><img SRC="lock3.gif" height=94 width=231></center>

<h3>
Lock was free</h3>

<ul>
<li>
As soon as the call starts the lock is closed:</li>
</ul>

<center><img SRC="lock4.gif" height=119 width=226></center>

<h3>
when you have the lock…you really have it</h3>

<ul>
<li>
When you have obtained the lock and are executing one synchronized method,
you are able to call other synchronized methods from that one, without
deadlock… because you have the lock !</li>
</ul>

<h3>
Lock is closed</h3>

<ul>
<li>
Any other threads that call a synchronized method of the "account object"
HAVE TO WAIT</li>

<li>
When the thread that has the lock completes execution of "deposit," the
lock becomes free</li>
</ul>

<h3>
End of method call</h3>

<center><img SRC="lock5.gif" height=152 width=229></center>

<h3>
Lock is closed and becomes free</h3>

<ul>
<li>
If the lock was closed, the calling thread has to wait</li>

<li>
When the lock opens one of the waiting threads will begin</li>
</ul>

<center><img SRC="lock6.gif" height=114 width=231></center>

<h3>
mutual exclusion</h3>

<ul>
<li>
The main purpose of synchronized methods is that the methods must be executed
in "mutual exclusion"</li>

<li>
"Mutual exclusion" means that if one method is executing, it "excludes"
the execution of any other synchronized method or other invocations of
the same method</li>
</ul>

<h3>
purpose of mutual exclusion</h3>

<ul>
<li>
Mutual exclusion is necessary if methods access the same data and at least
one of them writes new data</li>

<li>
In that case, the changes to the data must be complete before another method
accesses the data</li>
</ul>

<h3>
excessive mutual exclusion</h3>

<ul>
<li>
If the code in the method is really too long to have the data monopolized
for the whole of the execution of the method, "synchronized blocks" may
be used</li>
</ul>

<h3>
critical sections</h3>

<ul>
<li>
A "critical section" is the part of the code of a method where shared data
is accessed in mutual exclusion</li>

<li>
The "critical section" of a method may only be a small part of the code
in the method</li>
</ul>

<h3>
synchronized blocks</h3>

<ul>
<li>
Small parts of a method may be synchronized on the object’s lock</li>

<pre>void longMethod {

&nbsp;&nbsp;&nbsp; ... // many lines&nbsp;

&nbsp;&nbsp;&nbsp; synchronized(this){&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...//get lock for critical section&nbsp;

&nbsp;&nbsp;&nbsp; }&nbsp;

&nbsp;&nbsp;&nbsp; ... //more lines&nbsp;

}</pre>
</ul>

<h3>
example:</h3>

<blockquote>
<pre>class onLineTicketing {&nbsp;

&nbsp;&nbsp;&nbsp; void reserveTicket {&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... //fill date/price info&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronized(this){&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...//reserve the seat&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ... //sell ticket, get money&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; synchronized(this){&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...//confirm reservation&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; }

}</pre>
</blockquote>

<h3>
synchronized blocks</h3>

<ul>
<li>
There is somewhat more flexibility available in synchronized blocks:</li>

<li>
You can synchronize on other objects</li>
</ul>

<h3>
synchronizing on other objects</h3>

<ul>
<li>
There is no limitation on which objects can be used for synchronization</li>

<pre>void aMethod {

&nbsp;&nbsp;&nbsp; synchronized(barrier){//use lock of "barrier"&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...

&nbsp;&nbsp;&nbsp; }

&nbsp;&nbsp;&nbsp; ...

}</pre>

<li>
See BarrierTesting.java</li>
</ul>

<h3>
wait and notify</h3>

<ul>
<li>
The BarrierTest code uses "wait" and "notify"</li>

<li>
These are "final" methods of class Object</li>

<li>
Hence all objects have the same methods "wait( )," "notify( )" and "notifyAll(
)"</li>
</ul>

<h3>
monitors</h3>

<ul>
<li>
To manage "wait" and "notify," every object has a "monitor"</li>

<li>
Unlike general monitors, discussed in operating systems courses/books,
there are no "conditions" in this monitor</li>
</ul>

<h3>
wait gives up the lock</h3>

<ul>
<li>
When a method executes "wait( )," it gives up the lock of this object,
i.e. the one executing the method</li>

<li>
In a block synchronized on "obj" the call "obj.wait( )" gives up the lock
of "obj"--see BarrierTest</li>
</ul>

<h3>
wait in a synchronized method</h3>

<ul>
<pre>synchronized &lt;type> methM (...) {

&nbsp;&nbsp;&nbsp; //we have the lock&nbsp;

&nbsp;&nbsp;&nbsp; try{&nbsp;

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wait(&lt;optional timeout>); //give up lock&nbsp;

&nbsp;&nbsp;&nbsp; } catch(InterruptedException e){ }&nbsp;

&nbsp;&nbsp;&nbsp; // "wait( )" means "this.wait( )"&nbsp;

&nbsp;&nbsp;&nbsp; ...</pre>

<li>
Where do we wait ?</li>
</ul>

<h3>
cold storage</h3>

<ul>
<li>
Monitors hava a kind of "cold storage" where they put the waiting threads:</li>
</ul>

<center><img SRC="monitor1.gif" height=117 width=261></center>

<h3>
you have to have the lock</h3>

<ul>
<li>
The compiler make sure you only call "wait" in code that has the lock by
inserting a run-time check</li>

<li>
You can only call "wait" in a synchronized method or a synchronized block</li>

<li>
The compiler may not enforce this but you will get a run-time error if
you forget to use "wait" this way</li>
</ul>

<h3>
wait until notified</h3>

<ul>
<li>
If you go into the storage using "wait," you stay there until someone else
calls "notify" or "notifyAll" for THAT lock</li>
</ul>

<h3>
lock becomes open</h3>

<ul>
<li>
"Store" gets a reference to the thread and lock is opened</li>
</ul>

<center><img SRC="monitor2.gif" height=118 width=259></center>

<h3>
who is notified?</h3>

<ul>
<li>
If several threads are waiting in the same storage, a single "notify" only
frees one of them</li>

<li>
You do not know which one is freed</li>

<li>
After being freed, the thread has to get the lock back to continue processing</li>
</ul>

<h3>
letting loose a herd of threads</h3>

<ul>
<li>
If it makes sense to do that, you can call "notifyAll( )" to free ALL the
threads currently waiting in storage</li>

<li>
In that case you cannot know the order in which the freed threads will
run</li>
</ul>

<hr WIDTH="100%">
<center><table BORDER CELLSPACING=0 CELLPADDING=0 BGCOLOR="#FFFFF0" >
<tr>
<td><a href="http://bingweb.binghamton.edu/~head/CS471/471notesIndex.html">Index</a></td>
</tr>
</table></center>

</body>
</html>
