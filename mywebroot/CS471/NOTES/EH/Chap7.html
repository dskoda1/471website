<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>








  
  
  
  
  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">







  
  
  
  
  
  
  
  <title>Type Systems - Chap 7</title>
</head>


<body>








<center>
<h3>Type Systems <br>



Spring 2007




</h3>








</center>








<p>The purpose is examine the effects of different language
design
decision on how the Types work.&nbsp; Topics covered are aggregate
types and type equivalence.</p>








<hr style="width: 100%; height: 2px;">
<h3>The Definition of Types: 3 POV</h3>








<ul>








  <li><span style="font-style: italic;">denotational</span>
pov:&nbsp;</li>








  
  
  
  
  
  
  
  <ul>








    <li>&nbsp;a type is set of values</li>








  
  
  
  
  
  
  
  </ul>








  <li><span style="font-style: italic;">constructive</span>
pov:&nbsp;</li>








  
  
  
  
  
  
  
  <ul>








    <li>a type is either <span style="font-style: italic;">primitive
      </span>(<span style="font-style: italic;">or
predefined</span>)&nbsp;</li>








    <li>or a <span style="font-style: italic;">composite</span>
type built by applying a <span style="font-style: italic;">type
constructor </span>to one or more simpler types</li>








    
    
    
    
    
    
    
    <dl>








      <dd>array, 'struct', set, etc</dd>








    
    
    
    
    
    
    
    </dl>








  
  
  
  
  
  
  
  </ul>








  <li><span style="font-style: italic;">interface </span>pov:</li>








  
  
  
  
  
  
  
  <ul>








    <li>set of operations with a well defined and mutually
consistent semantics</li>








  
  
  
  
  
  
  
  </ul>








  <li>programmer's pov: a mixture of these pov.</li>








</ul>








<ul>








</ul>








<h3>Classification of Types</h3>








<ul>








  <li>Simple types:
Predefined types used to construct all other types<br>








  </li>








  <li>keywords (int, etc) </li>








</ul>








Not predefined types: Enumerated and Subrange Types
<ul>








  
  
  
  
  
  
  
  <dl>








    <li>Enumerated types consist of a set of named elements.<br>








    </li>








    <li> Various languages (Pascal, Ada, Modula-2, C++) allow
users to
define enumerated types:</li>








    
    
    
    
    
    
    
    <dl>








      <b><tt>&nbsp; TYPE&nbsp;
Traffic_signal&nbsp; IS&nbsp; (Red,
Green);</tt></b><br>








      <b><tt>&nbsp; TYPE&nbsp; Rainbow&nbsp;
IS&nbsp; (Red, Orange,
Yellow, Green, Blue, Violet);</tt></b><li> This is
Ada, Pascal will not
allow Red and Green to appear in two enumerated types.</li>








      <b><tt>&nbsp; &nbsp;SUBTYPE&nbsp;
Brighter IS&nbsp; Rainbow&nbsp;
RANGE&nbsp; Red..Yellow;</tt></b><li> It is
obvious to the compiler
that
Red is of type Rainbow.</li>








      <li> Enumerated types have Predecessor and Successor
functions
provided in the language and, in some cases, other functions:</li>








      
      
      
      
      
      
      
      <dl>








&nbsp;
      
      
      
      
      
      
      
      </dl>








      <b><tt>Rainbow&rsquo;SUCC(Green) is Blue</tt></b><br>








      <b><tt>Rainbow&rsquo;PRED(Yellow) is Orange</tt></b><br>








      <b><tt>Rainbow&rsquo;LAST is Violet</tt></b><br>








      <b><tt>Rainbow&rsquo;FIRST is Red</tt></b><br>








&nbsp;<li> Maximum value for integers</li>








      
      
      
      
      
      
      
      <dl>








        <b><tt>ADA:&nbsp; Integer&rsquo;LAST</tt></b><br>








        <b><tt>Pascal: MAXINT</tt></b><br>








        <b><tt>Java: java.lang.Integer.MAX_VALUE</tt></b><br>








        <b><tt>C : &lt;Limits.h&gt;</tt></b>
      
      
      
      
      
      
      
      </dl>








    
    
    
    
    
    
    
    </dl>








    
    
    
    
    
    
    
    <dl>








    
    
    
    
    
    
    
    </dl>








  
  
  
  
  
  
  
  </dl>








</ul>








<ul>








  
  
  
  
  
  
  
  <ul>








    <li>C: <span style="font-style: italic;">enums</span>
are basically a way to alias names to integers</li>








    <li>C++: <span style="font-style: italic;">enums</span>
define an actual type </li>








    <li>Java 5 has "linguistic support" for <span style="font-style: italic;">enum</span>
types.&nbsp;</li>








    
    
    
    
    
    
    
    <ul style="list-style-type: disc;">








      <li><a href="http://java.sun.com/docs/books/jls/third_edition/html/classes.html#8.9"><span style="font-style: italic;">enum</span>
(</a> Language Specification 3rd ed)</li>








      
      
      
      
      
      
      
      <ul>








        <li><a href="http://java.sun.com/docs/books/tutorial/java/javaOO/enum.html"><span style="font-style: italic;">enums</span></a>
have methods and state</li>








      
      
      
      
      
      
      
      </ul>








      <li><a href="http://java.sun.com/developer/JDCTechTips/2005/tt0208.html#2">Tips
using enum</a></li>








    
    
    
    
    
    
    
    </ul>








  
  
  
  
  
  
  
  </ul>








</ul>








<b>Subsets/subranges</b>
<ul>








  
  
  
  
  
  
  
  <dl>








    <li> Languages can provide subranges of scalar types</li>








  
  
  
  
  
  
  
  </dl>








  
  
  
  
  
  
  
  <dl>








    <li> Pascal and Modula-2</li>








  
  
  
  
  
  
  
  </dl>








  
  
  
  
  
  
  
  <dl style="margin-left: 40px;">








&nbsp;<b><tt>TYPE&nbsp; Uppercase =
&lsquo;A&rsquo;..&lsquo;Z&rsquo; ;</tt></b><br>








  
  
  
  
  
  
  
  </dl>








  
  
  
  
  
  
  
  <dl>








    <li> Ada also allows subtypes or new&nbsp; types
&nbsp;</li>








    <dd><b><tt>SUBTYPE Myrange is Integer RANGE 10.
. 100</tt></b><br>








    </dd>








    
    
    
    
    
    
    
    <dl>








      <b><tt>TYPE Mytype is NEW Integer RANGE 10. .100</tt></b>
      
      
      
      
      
      
      
      <p><b><tt>X : Myrange;</tt></b> <br>








      <b><tt>Y : Mytype;</tt></b> <br>








      <b><tt>Z : Integer;</tt></b> <br>








      </p>








    
    
    
    
    
    
    
    </dl>








  
  
  
  
  
  
  
  </dl>








</ul>








<ul>








  <li><b><tt>legal: Z := X;&nbsp; X := Z; </tt></b><span style="font-family: monospace;">(if
Z in the
range of X)</span></li>








  <li><b><tt>not legal: Z := Y;</tt></b> <br>








  </li>








  <li>The range portion is called a <i>type constraint</i></li>








  <li>Myrange is a <i>constrained subtype</i><br>








  </li>








  <li>Mytype is called a <i>derived type.</i><br>








  </li>








</ul>








<h3>
Composite, or
constructed type&nbsp;</h3>








<ul>








  
  
  
  
  
  
  
  <dl>








    <li> Grouping of elementary data elements</li>








    
    
    
    
    
    
    
    <dl>








      <li> Aggregate of heterogeneous types</li>








      
      
      
      
      
      
      
      <dl>








        <li> Records</li>








      
      
      
      
      
      
      
      </dl>








      <li> Aggregate of homogeneous types</li>








      
      
      
      
      
      
      
      <dl>








        <li> Arrays</li>








      
      
      
      
      
      
      
      </dl>








      <li> Aggregate of aggregates</li>








      
      
      
      
      
      
      
      <dl>








        <li> <i>linked lists</i></li>








      
      
      
      
      
      
      
      </dl>








    
    
    
    
    
    
    
    </dl>








    <li> Constructors are provided by the language to facilitate
the
use
of data aggregates.</li>








    <li> Older languages:</li>








    
    
    
    
    
    
    
    <dl>








      <li> Early versions of Fortran had only arrays</li>








      <li> Cobol had only records</li>








    
    
    
    
    
    
    
    </dl>








    <li> Common type constructors:</li>








    
    
    
    
    
    
    
    <dl>








      <li> records or structs for Cartesian Products</li>








      <li> arrays with one or more dimensions</li>








      <li> union types for unions</li>








      
      
      
      
      
      
      
      <dl>








        <li> Also implemented using variant records known as
discriminated records in Ada</li>








      
      
      
      
      
      
      
      </dl>








    
    
    
    
    
    
    
    </dl>








    
    
    
    
    
    
    
    <hr size="1" width="100%">
  
  
  
  
  
  
  
  </dl>








  <li><b>C&nbsp; provides <i>structs </i>:</b></li>








  
  
  
  
  
  
  
  <dl>








    
    
    
    
    
    
    
    <dl>








      <b><tt>struct Rec {</tt></b>
      
      
      
      
      
      
      
      <ul>








        
        
        
        
        
        
        
        <dl>








          <b><tt>int x;</tt></b><br>








          <b><tt>int y;</tt></b><br>








          <b><tt>char a;</tt></b><br>








          <b><tt>float f;</tt></b>
        
        
        
        
        
        
        
        </dl>








        <b><tt>}</tt></b>
      
      
      
      
      
      
      
      </ul>








      <br>








Declaration and Initialization <br>








      <tt><b>struct Rec var = { 1; 1; 'a'; 1.2 };<br>








      </b></tt>
    
    
    
    
    
    
    
    </dl>








  
  
  
  
  
  
  
  </dl>








</ul>








<ul>








  
  
  
  
  
  
  
  <dl>








    <li> Java: does not have <span style="font-style: italic;">structs</span></li>








    
    
    
    
    
    
    
    <dl>








      <li> Classes without methods can be viewed as records.</li>








    
    
    
    
    
    
    
    </dl>








    <li> C++:&nbsp;<span style="font-style: italic;">
structs</span> may have methods</li>








    <li>C#:<span style="font-style: italic;"> structs</span>
may have methods</li>








    
    
    
    
    
    
    
    <dl>








      <li> <span style="font-style: italic;">structs
        </span>are value types vs <span style="font-style: italic;">classes</span> which are
reference types </li>








    
    
    
    
    
    
    
    </dl>








  
  
  
  
  
  
  
  </dl>








</ul>








<ul>








  
  
  
  
  
  
  
  <dl>








  
  
  
  
  
  
  
  </dl>








</ul>








<blockquote>
  
  
  
  
  
  
  
  <hr size="2" width="50%"></blockquote>








<ul>








  <li><b>Ada records:</b></li>








  
  
  
  
  
  
  
  <dl>








    
    
    
    
    
    
    
    <dl>








      <span style="font-family: monospace;">TYPE&nbsp;Emp_name_typ&nbsp;IS&nbsp;RECORD
      </span><br style="font-family: monospace;">








      <span style="font-family: monospace;">&nbsp;
&nbsp;First : String(1..20); </span><br style="font-family: monospace;">








      <span style="font-family: monospace;">&nbsp;
&nbsp;Middle : String(1..10); </span><br style="font-family: monospace;">








      <span style="font-family: monospace;">&nbsp;
&nbsp;Last : String(1..20); </span><br style="font-family: monospace;">








      <span style="font-family: monospace;">END RECORD; </span>
      
      
      
      
      
      
      
      <p style="font-family: monospace;">TYPE&nbsp;
Emp_rec_typ&nbsp; IS&nbsp; RECORD<span style="font-family: monospace;"><br>








&nbsp; &nbsp;Emp_name : Emp_name_typ; </span><span style="font-family: monospace;"><br>








&nbsp; &nbsp;Hourly_rate : Float; </span><br>








END&nbsp;RECORD; </p>








      <span style="font-family: monospace;"></span>
      
      
      
      
      
      
      
      <p style="font-family: monospace;">Employee_record :
Emp_rec_typ; </p>








    
    
    
    
    
    
    
    </dl>








  
  
  
  
  
  
  
  </dl>








</ul>








<dl>








  
  
  
  
  
  
  
  <hr noshade="noshade" size="1" width="50%">
</dl>








<ul>








  <li><b>Haskell example:<br>








    </b></li>








  
  
  
  
  
  
  
  <dl>








    
    
    
    
    
    
    
    <dl>








      <b><tt>data People = Person String Int</tt></b><br>








      <tt><br>








      </tt><li> People
is
the type name</li>








      <li> Person is the constructor</li>








    
    
    
    
    
    
    
    </dl>








  
  
  
  
  
  
  
  </dl>








</ul>








<ul>








  
  
  
  
  
  
  
  <dl>








    <li>Implementation issue: How are records stored in memory
and what are offsets?</li>








  
  
  
  
  
  
  
  </dl>








</ul>








<ul>








  
  
  
  
  
  
  
  <dl>








    
    
    
    
    
    
    
    <hr size="1" width="100%">
  
  
  
  
  
  
  
  </dl>








</ul>








<h3>Type Checking
</h3>








<ul>








  
  
  
  
  
  
  
  <dl>








    <li> Compiled languages usually do as much type checking as
possible before running the program.&nbsp; (Static type checking).</li>








  
  
  
  
  
  
  
  </dl>








  
  
  
  
  
  
  
  <dl>








  
  
  
  
  
  
  
  </dl>








  
  
  
  
  
  
  
  <dl>








    <li> Some languages must include tables in the run-time
environment for dynamic type checking.</li>








  
  
  
  
  
  
  
  </dl>








</ul>








<li style="margin-left: 40px;">Issue for statically typed languages</li>








<div>
<ul>








  
  
  
  
  
  
  
  <ul>








    <li>type equivalence</li>








    <li>type compatibility</li>








    <li>type inference</li>








  
  
  
  
  
  
  
  </ul>








</ul>








</div>








<h3>When are two types the
same? -- Type
Equivalence</h3>








<ul>








  
  
  
  
  
  
  
  <dl>








    <b>Structural Equivalence</b>
    
    
    
    
    
    
    
    <dl>








      <li> Based on the idea that data types that have identical
structures should be compatible.</li>








      <li> Exact definition of equivalence varies from one
language to
another.</li>








    
    
    
    
    
    
    
    </dl>








    <b>Name Equivalence </b>(Sometime called strict)
    
    
    
    
    
    
    
    <dl>








      <li> Data types are equivalent only if they have the same
name</li>








    
    
    
    
    
    
    
    </dl>








    
    
    
    
    
    
    
    <dl>








      
      
      
      
      
      
      
      <hr size="1" width="100%"><b>Arrays</b><li>
Is array [ 1 .. 10 ]
compatible with array [ 0
.. 9 ] ?</li>








      <li> C avoids the problem because all arrays start with 0.</li>








      <li> Algol 68 would make the array type compatible.</li>








      <br>








      
      
      
      
      
      
      
      <hr size="1" width="100%"><b>Records</b><li>
Are these two records
equivalent?</li>








      
      
      
      
      
      
      
      <dl>








        <b><tt>record</tt></b>
        
        
        
        
        
        
        
        <dl>








          <b><tt>x : integer;</tt></b><br>








          <b><tt>y : character;</tt></b>
        
        
        
        
        
        
        
        </dl>








        <b><tt>end</tt></b>
        
        
        
        
        
        
        
        <p><b><tt>record<br>








        </tt></b><b><tt>&nbsp; &nbsp;
&nbsp; a : integer;</tt></b><b><tt><br>








&nbsp; &nbsp; &nbsp; b : character;</tt></b></p>








        
        
        
        
        
        
        
        <dl>








        
        
        
        
        
        
        
        </dl>








        <b><tt>end<br>







        </tt></b>
      
      
      
      
      
      
      
      </dl>








      <li> Algol 68 requires field names to be the same with the
same
type. So it is not considered equivalent.</li>








      <br>








      <li> Ada uses name equivalence.</li>








      
      
      
      
      
      
      
      <dl>








        <b><tt>type T1 is range 1..10</tt></b><br>








        <b><tt>type T2 is range 1..10</tt></b>
      
      
      
      
      
      
      
      </dl>








      <b><i>Derived</i></b>&nbsp;types are
not the same type. <br>








    
    
    
    
    
    
    
    </dl>








  
  
  
  
  
  
  
  </dl>








</ul>








<ul>








  
  
  
  
  
  
  
  <dl>








    
    
    
    
    
    
    
    <dl>








      <li> To have compatibility we use <b><i>subtypes</i></b>,
e.g.</li>








    
    
    
    
    
    
    
    </dl>








  
  
  
  
  
  
  
  </dl>








</ul>








<dl>








  
</dl>






<dl style="margin-left: 120px;">






  <b><tt>subtype S is T1 range 2..5</tt></b><br>






  <b><tt>

  </tt></b>
</dl>






<dl>







</dl>








<ul>








  
  
  
  
  
  
  
  <dl>








    <b>Beware of anonymous types in Ada:</b>
    
    
    
    
    
    
    
    <dl>








      <li> Variable declarations of arrays and tasks (without
giving a
name to the corresponding type) may create anonymous type that are
different each time: (Ada)</li>








      <br>








      <b><tt>x, y: array(1..9) of integer;</tt></b>
      
      
      
      
      
      
      
      <dl>








is equivalent to:
      
      
      
      
      
      
      
      </dl>








      <b><tt>type internal_type1 is array (1..9) of integer;</tt></b><br>








      <b><tt>type internal_type2 is array (1..9) of integer;</tt></b>
      
      
      
      
      
      
      
      <dl>








        <b><tt>x: internal_type1;</tt></b><br>








        <b><tt>y: internal_type2;</tt></b>
      
      
      
      
      
      
      
      </dl>








      <li> x and y have different internal names.</li>








      
      
      
      
      
      
      
      <dl>








        <li> Therefore have different types. So x := y is illegal.</li>








      
      
      
      
      
      
      
      </dl>








      
      
      
      
      
      
      
      <h4>
      
      
      
      
      
      
      
      <hr size="1" width="100%"><b>C</b></h4>








    
    
    
    
    
    
    
    </dl>








    
    
    
    
    
    
    
    <dl>








      <li> In C, structural equivalence is used, <b>except
for
struct&rsquo;s,</b>
where name equivalence is used.</li>








      
      
      
      
      
      
      
      <dl>








        <li> Note: <span style="font-style: italic;">typedef</span> does not create a new type.</li>








      
      
      
      
      
      
      
      </dl>








      <li> Java uses name equivalence.</li>






      <br>








      
      
      
      
      
      
      
      <hr size="1" width="100%">Sometimes called Declaration Equivalence <li> The follow would be considered
equivalent
(as in some Pascal implementations):</li>








      
      
      
      
      
      
      
      <dl>








        <b><tt>x,y: array[1..10] of</tt></b>
        
        
        
        
        
        
        
        <dl>








          <b><tt>record a : integer;</tt></b><br>








          <b><tt>&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;b : char</tt></b>
        
        
        
        
        
        
        
        </dl>








        <b><tt>&nbsp; &nbsp; &nbsp; end;</tt></b>
      
      
      
      
      
      
      
      </dl>








      <li> The use of <b><tt>typedef</tt></b>
in C introduces a new
name
for the same type.</li>








      
      
      
      
      
      
      
      <dl>








        <b><tt>typedef char *str;</tt></b><br>








        <b><tt>str p;</tt></b><br>








        <b><tt>char *q;</tt></b>
      
      
      
      
      
      
      
      </dl>








      <i>p </i>and <i>q</i>&nbsp;have the
same type.
    
    
    
    
    
    
    
    </dl>








    
    
    
    
    
    
    
    <hr size="1" width="100%">
  
  
  
  
  
  
  
  </dl>








</ul>








<h3>
Type Checking &nbsp; </h3>








<ul>








  
  
  
  
  
  
  
  <dl>








    
    
    
    
    
    
    
    <dl>








      <li> Compiled languages usually do as much type checking as
possible before running the program.&nbsp; (Static type checking).</li>








      <li> Some languages must include tables in the run-time
environment for dynamic type checking.</li>







      <li>Are the types equivalent/compatible?</li>








      <li> Ada has to do run-time constraint checking.</li>








      
      
      
      
      
      
      
      <dl>








        <b><tt>type T1 is range 1..99;</tt></b><br>








        <b><tt>subtype S is T1 range 1..9;</tt></b>
        
        
        
        
        
        
        
        <dl>








          <b><tt>X : T1;</tt></b><br>








          <b><tt>Y : S;</tt></b>
        
        
        
        
        
        
        
        </dl>








        <b><tt>begin</tt></b>
        
        
        
        
        
        
        
        <dl>








          <b><tt>Y := 6;</tt></b><br>








          <b><tt>X := 2 * Y;</tt></b><br>








          <b><tt>Y := X;</tt></b>
        
        
        
        
        
        
        
        </dl>








      
      
      
      
      
      
      
      </dl>








this causes a run-time exception.
    
    
    
    
    
    
    
    </dl>








  
  
  
  
  
  
  
  </dl>








  
  
  
  
  
  
  
  <hr size="1" width="100%">
</ul>








<h3>Type Compatibility&nbsp;</h3>








<ul>








  <li>Not all languages require <span style="font-style: italic;">type equivalence </span>in
every context</li>








</ul>








<div style="margin-left: 40px;">
<ul>








</ul>








<h4> Coercion</h4>








<ul>








  <li>Automatic conversion<br>








  </li>








  
  
  
  
  
  
  
  <ul>








    <li> Ada require explicit conversion which is like casting in
C
(Java/ C++)</li>








    <li>Haskell has several overloaded functions that serve as
explicit
coercions:</li>








    
    
    
    
    
    
    
    <ul>








      <li>fromInteger, fromRational, toInteger, toRational,
fromIntegral, fromRealFrac, fromIntegral, fromRealFrac <br>








      </li>








      <li>fromInteger and fromRation are implicitly used to
provide
overloaded numeric literals:<tt> </tt></li>








    
    
    
    
    
    
    
    </ul>








  
  
  
  
  
  
  
  </ul>








  <li> 4.5 + 6 in most languages is probably 4.5 + 6.0</li>








  
  
  
  
  
  
  
  <ul>








    <li> + is usually an overloaded operator, adding integers or
reals
(floats)</li>








    <li> Usually addition of reals</li>








  
  
  
  
  
  
  
  </ul>








  <li> The Louden describes a PL/I&rsquo;s problem: (Rule:
fractional value&rsquo;s
precision must be maintained.)</li>








  <br>








  
  
  
  
  
  
  
  <ul>








    <tt>1/3 + 15 returns 5.33333333333333</tt><br>








  
  
  
  
  
  
  
  </ul>








&nbsp; <li> Type widening is more natural than type
narrowing in
general.</li>








  
  
  
  
  
  
  
  <ul>








    <li> type widening</li>








    
    
    
    
    
    
    
    <dl>








      
      
      
      
      
      
      
      <dl>








        <li> int to real</li>








        <li> 2-byte int to 4 byte int</li>








      
      
      
      
      
      
      
      </dl>








      <li> type narrowing</li>








      
      
      
      
      
      
      
      <dl>








        <li> real to int</li>








      
      
      
      
      
      
      
      </dl>








    
    
    
    
    
    
    
    </dl>








  
  
  
  
  
  
  
  </ul>








  
  
  
  
  
  
  
  <ul>








    <li>Java uses the terms <span style="font-style: italic;"><span style="font-style: italic;"><span style="font-weight: bold;">numerical
promotion </span></span></span><span style="font-weight: bold;">and<span style="font-style: italic;"> widening conversion</span></span></li>








    <li>APL uses&nbsp;&nbsp;<span style="font-weight: bold;"><span style="font-style: italic;"><span style="font-weight: bold;"></span>promotion&nbsp;</span></span>to
means coercion from a <span style="font-weight: bold;">scalar</span>
to
an <span style="font-weight: bold;">aggregate</span></li>








  
  
  
  
  
  
  
  </ul>








  
  
  
  
  
  
  
  <dl>








    <dd>What do you think this means?<br>








      <br>








    </dd>








  
  
  
  
  
  
  
  </dl>








  <li> The programmer should be aware:</li>








  
  
  
  
  
  
  
  <ul>








    <li>No standard definition for such terms<br>








    </li>








    <li> The same code is executed for different types</li>








    
    
    
    
    
    
    
    <ul>








      <li> The primitive type is changed and stored in a
temporary
location for use.</li>








    
    
    
    
    
    
    
    </ul>








  
  
  
  
  
  
  
  </ul>








</ul>








<dl>








  <dd><span style="font-weight: bold;">Casting</span><br>








    <span style="font-style: italic;"></span><span style="font-weight: bold;"></span></dd>








</dl>








<ul>








  <li>In C++ the term <span style="font-style: italic;">cast
    </span>refers
to four different kinds of explicit type conversion</li>








  
  
  
  
  
  
  
  <ul>








    <li><span style="font-family: monospace;"><span style="font-weight: bold;">static_cast:</span></span>produces
a new
value "equivalent" to the original.</li>








    
    
    
    
    
    
    
    <ul>








      <li><span style="font-family: monospace;">double
x = static_cast
3;</span></li>








      <li><span style="font-family: monospace;">same
a C cast<br>








        </span></li>








    
    
    
    
    
    
    
    </ul>








    <li><span style="font-family: monospace;"><span style="font-weight: bold;">dynamic_cast:</span></span>a
run-time
type-checked conversion of a pointer.</li>








    
    
    
    
    
    
    
    <dl style="font-family: monospace;">








      <dd>Parent *&nbsp; p = new Child;&nbsp; //up cast</dd>








    
    
    
    
    
    
    
    </dl>








    
    
    
    
    
    
    
    <dl style="font-family: monospace;">








      <dd>Child * c = dynamic_cast&lt;Child *&gt;
p;&nbsp; //downcast <br>








      </dd>








    
    
    
    
    
    
    
    </dl>








    
    
    
    
    
    
    
    <ul>








      <li>Value is 0 if the conversion is invalid</li>








    
    
    
    
    
    
    
    </ul>








    <li><span style="font-family: monospace;"><span style="font-weight: bold;">reinterpret_cast:</span></span>
produces no
new values; merely changes the set of functions that can be applied to
the original value</li>








    
    
    
    
    
    
    
    <ul>








      <li>few reinterpret_casts are portable</li>








      <li>completely unchecked</li>








    
    
    
    
    
    
    
    </ul>








    <li><span style="font-weight: bold; font-family: monospace;">const_cast:</span>
removes const protection from a parameter</li>








  
  
  
  
  
  
  
  </ul>








</ul>








</div>








<hr>
<hr style="width: 100%; height: 2px;">
<h3>Sequence data types:<br>








</h3>








<ul>








  <b>Arrays</b>
  
  
  
  
  
  
  
  <dl>








    
    
    
    
    
    
    
    <dl>








      <b>Legal subscripts types:</b>
      
      
      
      
      
      
      
      <dl>








        <li> C, C++, Java indexes are always integers starting at
0.</li>








        <li> FORTRAN 77, FORTRAN 90 uses integers.&nbsp; The
lower
bound
default if 1.</li>








        <li> Pascal allows any ordinal type to be an index.</li>








        
        
        
        
        
        
        
        <dl>








type WkE = (Sat, Sun); <br>








Costs = array[WkE] of real;
        
        
        
        
        
        
        
        </dl>








        <li> Ada allows any discrete type (page 153) to be an
index.</li>








        
        
        
        
        
        
        
        <dl>








          <li>Integers, Booleans and characters are examples of <i>discrete
types </i>( also called <i>ordinal types</i>)<i>.</i><br>








          </li>








          <li> Unconstrained 2-dimensional array</li>








          <br>








          <b><tt>TYPE&nbsp; Matrix_type&nbsp; IS</tt></b>
          
          
          
          
          
          
          
          <dl>








            <b><tt>ARRAY(Integer range &lt;&gt;,
Integer range
&lt;&gt;) OF Integer;<br>





            </tt></b><li> &nbsp;<a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/Chap3.html#elaboration">Elaboration</a></li>








&nbsp;
          
          
          
          
          
          
          
          </dl>








          <li> Constrained 2-dimensional array</li>








          <b><tt>TYPE&nbsp; Matrix_4x4_type&nbsp; IS</tt></b>
          
          
          
          
          
          
          
          <dl>








            <b><tt>ARRAY(1..4, 10..13) OF Integer;</tt></b>
          
          
          
          
          
          
          
          </dl>








        
        
        
        
        
        
        
        </dl>








      
      
      
      
      
      
      
      </dl>








      
      
      
      
      
      
      
      <hr size="1" width="100%">
      
      
      
      
      
      
      
      <dl>








        <li>If the arrays are allocated during compile time then
the
range is statically bound.</li>








        
        
        
        
        
        
        
        <dl>








          <li> Fortran 77</li>








          <li> Global or automatic array (value model) variable
in C:</li>








          <br>








          <b><tt>int arr [ 40 </tt></b>]; <br>








&nbsp;
          
          
          
          
          
          
          
          <dl>








            <li> Range bound static, storage ?</li>








            
            
            
            
            
            
            
            <dl>








&nbsp;
            
            
            
            
            
            
            
            </dl>








          
          
          
          
          
          
          
          </dl>








          <li> <a name="gccArray"></a>Automatic
Arrays (variable
length
arrays) declared in&nbsp; C functions:</li>








          
          
          
          
          
          
          
          <dl>








            <b><tt>void cFunction (int size ) {</tt></b><br>








            <b><tt>&nbsp;&nbsp;&nbsp;&nbsp;
int marbles [size][size/2];</tt></b><br>








            <b><tt>}</tt></b><br>








&nbsp;<li> Range bound dynamic, storage dynamic</li>








            <li> Prior to C99 this code would not compile.</li>








            <li>Prior to C99: When multidimensional arrays are
used, it
is necessary to specify the bounds of but the first dimension.<br>








            </li>








          
          
          
          
          
          
          
          </dl>








        
        
        
        
        
        
        
        </dl>








      
      
      
      
      
      
      
      </dl>








      
      
      
      
      
      
      
      <h4>
      
      
      
      
      
      
      
      <hr size="1" width="100%">When and where does
array allocation
take place?</h4>








      <li> If&nbsp; the arrays are allocated from the heap
then both
the
storage allocation and the subscript ranges can be dynamically bound.</li>








      <li> Java: reference model</li>








      
      
      
      
      
      
      
      <dl>








        <li> Storage only on the heap</li>








        <li> Arrays are objects</li>








        
        
        
        
        
        
        
        <dl>








          <b><tt>String [ ] sArray = new String[5];</tt></b><br>








          <b><tt>Object [ ] myArray = new Object
[sArray.length];</tt></b>
        
        
        
        
        
        
        
        </dl>








        <li> Java does do range checking.&nbsp; All arrays
have a field
length that never changes.</li>








      
      
      
      
      
      
      
      </dl>








      <li> C, C++ can also dynamically allocate storage from the
heap.</li>








      
      
      
      
      
      
      
      <dl>








        <li> C, C++ does not do range checking.</li>








      
      
      
      
      
      
      
      </dl>








      <li> Perl:</li>








      
      
      
      
      
      
      
      <dl>








        <li> variables names for arrays begin with "@"</li>








        <li> storage is dynamically allocated</li>








        <li> example:</li>








        <br>








        <tt>@myPerlarr = ("one","two","three");</tt><br>








        <tt>$myPerlarr[0]&nbsp;&nbsp; </tt>is the
scalar with value <tt>"one"</tt><br>








        <tt>@myPerlarr[26] = "wow";</tt>
        
        
        
        
        
        
        
        <dl>








          <li> <tt>Extends the array to length 26.</tt></li>








        
        
        
        
        
        
        
        </dl>








      
      
      
      
      
      
      
      </dl>








      
      
      
      
      
      
      
      <h4>
      
      
      
      
      
      
      
      <hr size="1" width="100%">How is the array
stored in
memory?&nbsp; Runtime calculation of array element.</h4>








      
      
      
      
      
      
      
      <dl>








        
        
        
        
        
        
        
        <h4> <a name="effectiveAddress"></a>Computing
effective
address:</h4>








        <li>Arrays in most language implementation are stored in
contiguous location in memory. &nbsp;</li>








        <li> Some languages arrays of arrays.</li>








        
        
        
        
        
        
        
        <dl>








          
          
          
          
          
          
          
          <dl>








&nbsp;
          
          
          
          
          
          
          
          </dl>








        
        
        
        
        
        
        
        </dl>








      
      
      
      
      
      
      
      </dl>








      <a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/2cArrays.gif"><img alt="Arrays" title="" src="2cArrays.gif" border="0" height="298" width="629"> </a>
      
      
      
      
      
      
      
      <dl>








        
        
        
        
        
        
        
        <dl>








          <li> Left declaration is a true two-dimensional array.</li>








          <li> Right declarations is an array of pointers to
array of
chars.</li>








          <li>What are the trade offs?<br>








          </li>








          
          
          
          
          
          
          
          <dl>








&nbsp;
          
          
          
          
          
          
          
          </dl>








        
        
        
        
        
        
        
        </dl>








        <li>The key feature of arrays is <b><i>O</i>
(1)</b> access
time
to any array element.<br>








        </li>








        <li> Formula for computing the effective address of a one
dimensional array:</li>








        
        
        
        
        
        
        
        <dl>








          <li> <tt>A: array [LowerBound .. UpperBound]</tt></li>








          <li> Let <i>ba</i> be the base address of
array A, and</li>








          <li> Let <i>size</i> be the number of
addressable
units(bytes)
required to store a value of base type of A.</li>








          <li> &nbsp;Then the effective address of <i>A</i>[<i>k</i>]
is:</li>








          
          
          
          
          
          
          
          <dl>








            <li> <i>ba</i> + <i>size </i>*
(<i>k</i> - LowerBound of <i>A</i>)</li>








            <li>As you can see the cost of computing <i>A</i>[<i>k</i>]
is independent of <i>k.</i><br>








            </li>








          
          
          
          
          
          
          
          </dl>








        
        
        
        
        
        
        
        </dl>








        <li> Multidimensional arrays:&nbsp; Where does the
second
element of the array go?&nbsp;</li>








        
        
        
        
        
        
        
        <dl>








          <li> <tt>A: array [LowerBound .. UpperBound ] of
array
[1..4]
of char</tt></li>








        
        
        
        
        
        
        
        </dl>








        <a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/2majorOrderArr.gif">
        </a><li>Row-major
-- Rows are contiguous in memory A[2,4] is followed by A[2,5]</li>








        <li>Column-major major columns are contiguous, A[2,4] is
followed by A[3,4]</li>








        <li>Scott 2nd (p359)</li>








        <a href="2majorOrderArr.gif"><img alt="Major Order" title="" src="2majorOrderArr.gif" border="0" height="261" width="436"></a><a href="2majorOrderArr.gif"> </a>
      
      
      
      
      
      
      
      </dl>








    
    
    
    
    
    
    
    </dl>








  
  
  
  
  
  
  
  </dl>








</ul>








<ul>








  
  
  
  
  
  
  
  <ul>








    
    
    
    
    
    
    
    <ul>








      <li>The second cache line of each array is shown, on the
assumption that each element is an 8-byte floating point number, that
cache lines is 32&nbsp; bytes long (common size), and that the
array
begins at a cache line boundary.<br>








      </li>








    
    
    
    
    
    
    
    </ul>








  
  
  
  
  
  
  
  </ul>








</ul>








<ul>








  
  
  
  
  
  
  
  <dl>








    
    
    
    
    
    
    
    <dl>








      
      
      
      
      
      
      
      <h4>
      
      
      
      
      
      
      
      <hr size="1" width="100%"> </h4>








      
      
      
      
      
      
      
      <h4>Can arrays be initialized when they have their storage
allocated?</h4>








      
      
      
      
      
      
      
      <dl>








        <li> Initialization: In FORTRAN, Java, C and Ada, arrays
can be
initialized in their declaration.</li>








        <li> Forcing a &ldquo;2 dimensional&rdquo; array
representation with
initialization in Java:</li>








        
        
        
        
        
        
        
        <dl>








          
          
          
          
          
          
          
          <dl>








            <b><tt>double[ ] [ ] identity = {</tt></b>
            
            
            
            
            
            
            
            <dl>








              <b><tt>{ 1.0, 0.0, 0.0 },</tt></b><br>








              <b><tt>{ 0.0, 1.0, 0.0 },</tt></b><br>








              <b><tt>{ 0.0, 0.0, 1.0 }</tt></b>
            
            
            
            
            
            
            
            </dl>








            <b><tt>};</tt></b>
          
          
          
          
          
          
          
          </dl>








          <li> Note: "global" variables in Java are initialized
(0,nil)
but NOT local variables.</li>








        
        
        
        
        
        
        
        </dl>








      
      
      
      
      
      
      
      </dl>








      
      
      
      
      
      
      
      <hr size="1" width="100%">
    
    
    
    
    
    
    
    </dl>








  
  
  
  
  
  
  
  </dl>








</ul>








<blockquote>
  
  
  
  
  
  
  
  <blockquote>
    
    
    
    
    
    
    
    <h4>Haskell, Prolog</h4>








    
    
    
    
    
    
    
    <ul>








      <li>Do not have arrays.</li>








      <li><b><i>list</i></b>s are the way
to sequence data.</li>








      <li>How are lists different from arrays?</li>








    
    
    
    
    
    
    
    </ul>








    <br>








  </blockquote>








</blockquote>








<ul>








  <li>Programming in C++, C# and Java you should use collection
frameworks provided in the languages.</li>








</ul>








<hr size="1" width="100%">
<h3>Pointers:</h3>








<ul>








  <li>C, C++ pointer types</li>








  
  
  
  
  
  
  
  <ul>








    <li>polymorphic data types</li>








  
  
  
  
  
  
  
  </ul>








  
  
  
  
  
  
  
  <dl style="font-family: monospace;">








    <dd>int * x;</dd>








  
  
  
  
  
  
  
  </dl>








  
  
  
  
  
  
  
  <dl style="font-family: monospace;">








    <dd>float * y;</dd>








  
  
  
  
  
  
  
  </dl>








  
  
  
  
  
  
  
  <ul>








    <li>the R-value is an address<br>








    </li>








  
  
  
  
  
  
  
  </ul>








  <br>








  <li>C pointers' "units" are adjusted according to the size of
the
type
they point to. <br>








  </li>








</ul>








<div style="margin-left: 80px;"><span style="font-family: monospace;">main(){</span><br style="font-family: monospace;">








<span style="font-family: monospace;">&nbsp; char*
ptChr =0; </span><br>








<span style="font-family: monospace;">&nbsp; short*
ptShort =0;</span><br>








<span style="font-family: monospace;">&nbsp; long*
ptLong =0;</span><br style="font-family: monospace;">








<span style="font-family: monospace;">&nbsp; int i;</span><br style="font-family: monospace;">








<span style="font-family: monospace;">&nbsp;</span><br style="font-family: monospace;">








<span style="font-family: monospace;">&nbsp;
printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Index Char Short&nbsp; Long\n");</span><br style="font-family: monospace;">








<span style="font-family: monospace;">&nbsp; for ( i
=0; i &lt; 6; i++) {</span><br style="font-family: monospace;">








<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
printf("Offset of Pointers %d&nbsp;&nbsp;&nbsp;
%d&nbsp;&nbsp;&nbsp; %2d&nbsp;&nbsp;&nbsp;
%2d\n",</span><br style="font-family: monospace;">








<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; i, ptChr+i, ptShort+i, ptLong+i);</span><br style="font-family: monospace;">








<span style="font-family: monospace;">&nbsp; }</span><br style="font-family: monospace;">








<span style="font-family: monospace;">}</span><br style="font-family: monospace;">








</div>








<div style="margin-left: 40px;">~&gt;<br>








<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; &nbsp;Index Char Short Long</tt><br>








<tt>Offset of Pointers &nbsp;0&nbsp; &nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp; &nbsp; 0</tt><br>








<tt>Offset of Pointers &nbsp;1&nbsp; &nbsp;
1&nbsp;&nbsp;&nbsp;
&nbsp;2&nbsp;&nbsp;&nbsp; 4</tt><br>








<tt>Offset of Pointers &nbsp;2&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp;&nbsp;
4&nbsp;&nbsp;&nbsp; 8</tt><br>








<tt>Offset of Pointers &nbsp;3&nbsp; &nbsp;
3&nbsp;&nbsp; &nbsp;
6&nbsp;&nbsp; 12</tt><br>








<tt>Offset of Pointers &nbsp;4&nbsp; &nbsp;
4&nbsp;&nbsp;&nbsp;&nbsp;
8&nbsp;&nbsp; 16</tt><br>








<tt>Offset of Pointers &nbsp;5&nbsp; &nbsp;
5&nbsp;&nbsp;&nbsp;
10&nbsp;&nbsp; 20</tt></div>








<ul>








  <li> C++ allows functions to return l-values</li>








  
  
  
  
  
  
  
  <ul>








    <tt>int a[10];</tt><br>








    <tt>int&amp; f(int I) { return (a[I]); }</tt><br>








    <tt>f(5) = 17;</tt><br>








    <tt>// This assigns 17 to a[5]</tt>
  
  
  
  
  
  
  
  </ul>








</ul>








<ul>








  
  
  
  
  
  
  
  <dl>








    <li> Pointer (access) types provide a way of manipulating
memory
addresses.</li>








    <li> Pointers may be used to create recursive types, e.g.
linked
list and trees.</li>








  
  
  
  
  
  
  
  </dl>








</ul>








<ul>








  
  
  
  
  
  
  
  <dl>








    <li> C example:</li>








    <br>








    
    
    
    
    
    
    
    <ul>








      <b><tt>typedef struct tree {</tt></b>
      
      
      
      
      
      
      
      <dl>








        
        
        
        
        
        
        
        <dl>








          <b><tt>int val;</tt></b><br>








          <b><tt>struct tree* right;</tt></b><br>








          <b><tt>struct tree* left;</tt></b>
        
        
        
        
        
        
        
        </dl>








      
      
      
      
      
      
      
      </dl>








      <b><tt>} tree;</tt></b>
      
      
      
      
      
      
      
      <p><b><tt>tree* root;</tt></b></p>








    
    
    
    
    
    
    
    </ul>








  
  
  
  
  
  
  
  </dl>








  
  
  
  
  
  
  
  <ul>








    <li>Pointers allows the record size to be finite since the
record
size is independent of the size of the right and left <i>tree</i>.</li>








    <li>Allowing the pointer to be <b><i>null</i></b>
enables the <i>tree</i>&nbsp;to
be finite data structure.<br>








    </li>








  
  
  
  
  
  
  
  </ul>








  
  
  
  
  
  
  
  <dl>








    <li> Reference type which do not allow manipulation of memory
also
may be used to create recursive types.</li>








    
    
    
    
    
    
    
    <dl>








      <li> Java does not have pointers but does have reference
types.</li>








      
      
      
      
      
      
      
      <dl>








        
        
        
        
        
        
        
        <dl>








          
          
          
          
          
          
          
          <dl>








            
            
            
            
            
            
            
            <dl>








&nbsp;
            
            
            
            
            
            
            
            </dl>








          
          
          
          
          
          
          
          </dl>








        
        
        
        
        
        
        
        </dl>








      
      
      
      
      
      
      
      </dl>








    
    
    
    
    
    
    
    </dl>








    <li> Haskell uses constructors to define recursive data types:</li>








    
    
    
    
    
    
    
    <dl>








      <b><tt>data Tree v = Nil | Node v (Tree v) (Tree v)</tt></b>
    
    
    
    
    
    
    
    </dl>








    <li> Some languages provide a non-type:</li>








    
    
    
    
    
    
    
    <dl>








      
      
      
      
      
      
      
      <dl>








        <li> void in C</li>








      
      
      
      
      
      
      
      </dl>








    
    
    
    
    
    
    
    </dl>








  
  
  
  
  
  
  
  </dl>








</ul>










<h3> Functions and Other Type Constructors</h3>








<ul>








  
  
  
  
  
  
  
  <dl>








    <li> Functions may be a type in a language.</li>








    
    
    
    
    
    
    
    <dl>








      <li> Haskell, ML, Lisp</li>








      <li> Arrays are a special form of function, a table of
values A[
j
] can be thought of as the value of function A at point j.</li>








    
    
    
    
    
    
    
    </dl>








  
  
  
  
  
  
  
  </dl>








</ul>








<h3>Pointers and Arrays in C</h3>








<ul>








  <li> There is a close correspondence between types "<i>array
of Ttype"</i>
and <i>"pointer to Ttype"</i>.</li>








  <br>








  <tt>int a[10], *ip;</tt><br>








  <tt>ip = a;</tt><br>








  <tt>ip = &amp;a[0];</tt><br>








&nbsp;
  
  
  
  
  
  
  
  <ul>








    <li><span style="font-family: monospace;"> a[i] </span>can
be defined as <span style="font-family: monospace;">*(( a
)+( i ))</span></li>








    <li> In fact <b><tt>a[i]</tt></b> is
the same as <b><tt>i[a]</tt></b>!</li>








  
  
  
  
  
  
  
  </ul>








</ul>








<h3>
<hr size="1" width="100%"></h3>








<span style="font-weight: bold;">Records and Arrays</span><br>








<br>








C Example &nbsp;
<ul>








  
  
  
  
  
  
  
  <table width="75%">








    <tbody>








      <tr>








        <td><b><tt>typedef struct {</tt></b>
        <br>








        <b><tt>&nbsp;&nbsp; char field;</tt></b>
        <br>








&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-family: monospace; font-weight: bold;">float num</span>;<br>








        <b><tt>&nbsp;&nbsp;&nbsp;&nbsp;
&hellip;.</tt></b> <br>








        <b><tt>} RecType;</tt></b>
        
        
        
        
        
        
        
        <p><b><tt>typedef RecType ArrType[4];</tt></b>
        </p>








        
        
        
        
        
        
        
        <p><b><tt>ArrType *pt;</tt></b></p>








        </td>








        <td><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/4Cpt.gif"><img title="" alt="C: Example of Array of structs and Pointers" src="4Cpt.gif" border="0" height="175" width="290">
        </a></td>








      </tr>








    
    
    
    
    
    
    
    </tbody>
  
  
  
  
  
  
  
  </table>








  
  
  
  
  
  
  
  <hr size="1" width="100%">
</ul>








<ul>








  <li>Issue involving layout of array of structs in C</li>








</ul>








<div style="margin-left: 40px;">Ada Example<br>








<div style="margin-left: 40px;"><b><tt>type
RecType is</tt></b><br>








<div style="margin-left: 40px;"><b><tt>record</tt></b><br>








<b><tt>&nbsp;&nbsp; Field: Character;</tt></b><br>








<b><tt>&nbsp;&nbsp; Num: Float;</tt></b><br>








<b><tt> </tt></b><b><tt>&nbsp;
..</tt></b><br>








<b><tt>end record;</tt></b><br>








</div>








<b><tt>type ArrType is array(1..4) of RecType;</tt></b><br>








<b><tt>type PtType is access ArrType;</tt></b><br>








<b><tt>pt: PtType;</tt></b><br>








</div>








<b><tt><br>








</tt></b>pt&nbsp;&nbsp;&nbsp; -- pointer to
array of records <br>








pt.all -- array of records <br>








pt.all[ 3 ] --&nbsp; record <br>








pt.all[ 3 ].Field -- integer<br>








<br>








</div>








<h4>Pointer vs Reference</h4>







<ul>








  <li>A reference type (usually) is like
pointer type with
automatic dereferencing, and only assignment and equality operators.</li>








  
  
  
  
  
  
  
  <ul>








    
    
    
    
    
    
    
    <dl>








      <li> It can be alias for an object</li>








      <li> All non-primitive types in Java are reference types</li>








      <li> C++ has reference type that is usually used for
parameter
passing</li>








    
    
    
    
    
    
    
    </dl>








  
  
  
  
  
  
  
  </ul>








  <li> R-value of the Reference can not be separated from the
l-value of the object.</li>








  <li> R-value of a Pointer can be separated from the l-value of
the
object pointed to</li>








  
  
  
  
  
  
  
  <ul>








    <li>pt and (*pt) are different!</li>








    <br>








  
  
  
  
  
  
  
  </ul>








  
  
  
  
  
  
  
  <dl>








    <li> Dereferencing</li>








    
    
    
    
    
    
    
    <dl>








      <li> Java, not needed</li>








      <li> Ada (access type)&nbsp; <b><tt><i>pt</i>.all</tt></b></li>








      <li> Pascal <b><i>pt^</i></b></li>








      <li> C, C++, <b><i>pt </i>-&gt;, *<i>pt</i></b></li>








    
    
    
    
    
    
    
    </dl>








    <li> Dangling pointer problem</li>








    
    
    
    
    
    
    
    <dl>








      <li> Deallocation leaves a pointer's value binding invalid</li>








    
    
    
    
    
    
    
    </dl>








    <li> Garbage -</li>








    
    
    
    
    
    
    
    <dl>








      <li> No current reference to allocated memory (memory leaks)</li>








    
    
    
    
    
    
    
    </dl>








    <li> Dereferencing a nil pointer</li>








  
  
  
  
  
  
  
  </dl>








  
  
  
  
  
  
  
  <hr style="width: 100%; height: 2px;"><b>Handling
Pointer Problems</b>
  
  
  
  
  
  
  
  <ul>








    <li> Require Pointers to be typed</li>








    <li> Do not allow pointer arithmetic</li>








    
    
    
    
    
    
    
    <ul>








&nbsp;
    
    
    
    
    
    
    
    </ul>








    <li> Make memory management the job of the language, NOT the
job
of the programmer</li>








    
    
    
    
    
    
    
    <dl>








      <br>








      
      
      
      
      
      
      
      <hr size="1" width="100%"><b>Dangling
Pointer Problem</b>
    
    
    
    
    
    
    
    </dl>








    <li> Remember dangling pointers
point to deallocated storage.</li>








    
    
    
    
    
    
    
    <ul>








      
      
      
      
      
      
      
      <dl>








        <br>








        <a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/4danglingPt.gif"><img alt="Dangling Pointers" src="4danglingPt.gif" style="border: 0px solid ; width: 145px; height: 109px;"> </a><br>








        
        
        
        
        
        
        
        <hr size="1" width="100%">
      
      
      
      
      
      
      </dl>








    
    
    
    
    
    
    
    </ul>








  
  
  
  
  
  
  
  </ul>








  
  
  
  
  
  
  
  <h4 style="margin-left: 40px;">What&nbsp;can a language's runtime support provide to help you do to avoid
Dangling
Pointers ?<br>






  </h4>








  
  
  
  
  
  
  
  <ul>








    <li> Never allow deallocation of memory.</li>








  
  
  
  
  
  
  
  </ul>








  
  
  
  
  
  
  
  <ul>








    
    
    
    
    
    
    
    <dl>








      
      
      
      
      
      
      
      <dl>








        <li> Creates lots of garbage</li>








        <li> Internally correct.</li>








      
      
      
      
      
      
      
      </dl>








    
    
    
    
    
    
    
    </dl>








  
  
  
  
  
  
  
  </ul>








  
  
  
  
  
  
  
  <ul>








    <li> Tombstone by Lomet (1975)</li>








  
  
  
  
  
  
  
  </ul>








  
  
  
  
  
  
  
  <ul>








    
    
    
    
    
    
    
    <ul>








      
      
      
      
      
      
      
      <dl>








        <a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/4tomb.gif"><img alt="Tombstones" src="4tomb.gif" style="border: 0px solid ; width: 118px; height: 151px;"> </a><li>Expensive
in time
and space</li>








        <li> Good side effect- easy to implement <i>storage
compaction</i></li>








        
        
        
        
        
        
        
        <dl>








          <li> Used by Macintosh OS for references to system
objects
such as files and window descriptors.</li>








        
        
        
        
        
        
        
        </dl>








      
      
      
      
      
      
      
      </dl>








    
    
    
    
    
    
    
    </ul>








  
  
  
  
  
  
  
  </ul>








  
  
  
  
  
  
  
  <ul>








    <li> Lock and Key by Fischer and LeBlanc 1977, 1980</li>








  
  
  
  
  
  
  
  </ul>








  
  
  
  
  
  
  
  <ul>








    
    
    
    
    
    
    
    <ul>








      <a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/4LockKey.gif"><img alt="Lock and Key" src="4LockKey.gif" style="border: 0px solid ; width: 129px; height: 171px;"></a><br>








    
    
    
    
    
    
    
    </ul>








    <br>








    <a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/4LockKey.gif">
    </a>
    
    
    
    
    
    
    
    <hr size="1" width="100%">
    
    
    
    
    
    
    
    <h4> What can you do to reduce memory leaks?</h4>








Garbage Collecting<br>








    <li> Lisp pioneered garbage
collecting.&nbsp;
Haskell, Ml, Lisp, and scheme&nbsp; (functional programming
language)
rely on garbage collectors.</li>








    <li> Object oriented language like Java, SmallTalk,
Simula 67
and
Eiffel also rely on garbage collectors for the reclamation of memory
during execution.</li>








    <li> C++ is the notable exception.&nbsp; C++ retains
the
allocation and deallocation rules of C.</li>








    
    
    
    
    
    
    
    <h4> Garbage Collecting Techniques</h4>








    
    
    
    
    
    
    
    <dl>








      
    
    
    
    
    </dl>




  
  
  
  
  </ul>




</ul>




<ul>




  <li> Fundamental techniques</li>




</ul>




<ul>




  
  
  
  
  <ul>








      
      
      
    
    
    
    
    <dl>








        <li> Reference counters</li>








        
        
        
      
      
      
      
      <dl>








          <li> eager approach<br>




        </li>








        
        
        
      
      
      
      
      </dl>




      <li>Tracing collections</li>




    
    
    
    
    </dl>




  
  
  
  
  </ul>




</ul>




<ul>




  
  
  
  
  <ul>




    
    
    
    
    <ul style="list-style-type: disc;">




      <li>Mark and sweep</li>




      
      
      
      
      <ul style="list-style-type: circle;">




        <li> lazy approach</li>




      
      
      
      
      </ul>








          
      
      
      
      
      <ul style="list-style-type: circle;">




        <li>first proposed by Lisp inventor John McCarthy in
1960<br>




        </li>




      
      
      
      
      </ul>








        
        
        
    
    
    
    
    </ul>




  
  
  
  
  </ul>




  
  
  
  
  <ul>




    
    
    
    
    <dl>




      <dd><a href="MarkAndSweep.gif"><img alt="Mark and Sweep" src="MarkAndSweep.gif" style="border: 0px solid ; width: 295px; height: 175px;"></a></dd>




    
    
    
    
    </dl>




  
  
  
  
  </ul>




</ul>




<ul>




  
  
  
  
  <ul>




    
    
    
    
    <dl>








        
        
        



        



      
      
      



    
    
    
    
    
    
    
    </dl>








  
  
  
  
  
  
  
  </ul>








  
  
  
  
  
  
  
  
  
  
  <ul>








    
    
    
    
    
    
    
    <ul>








      
    
    
    
    
    </ul>




  
  
  
  
  </ul>




  
  
  
  
  <div style="margin-left: 40px;">
  
  
  
  
  <ul style="list-style-type: disc;">




    <li>Stop and Copy<br>








      </li>




  
  
  
  
  </ul>




  </div>




  
  
  
  
  <ul>




    
    
    
    
    <ul>








      
      
      
      
      
      
      
      <ul>








        
      
      
      
      
      </ul>




    
    
    
    
    </ul>




  
  
  
  
  </ul>




  
  
  
  
  <div style="margin-left: 40px;">
  
  
  
  
  <ul>




    
    
    
    
    <ul style="list-style-type: circle;">




      <li>Cousin to Mark and Sweep</li>




      <li>reduces external fragmentation</li>








    
    
    
    
    
    
    
    </ul>








  
  
  
  
  
  
  
  </ul>








  </div>








</ul>








<hr style="width: 100%; height: 2px;">
<hr style="width: 100%; height: 2px;">
<h3>Polymorphism:</h3>








<ul>








  <li> Ways the Language allows you to code routines with the
same
identifier but the actual parameters can be of different types.</li>








</ul>








<a href="16poly.gif"><img style="border: 0px solid ; width: 371px; height: 188px;" alt="Polymorphic Diagram" src="16poly.gif"></a>
<br>








<br>








<ul>








  <li> Polymorphism is a bad term to use.</li>








  <li>Helpful definitions:</li>








</ul>








<dl>








  <dd>"A function or operator is <span style="font-style: italic;">polymorphic</span>
is it has at least two possible types."<sup>1</sup><br>








"A function or operator exhibits <span style="font-style: italic;">ad
hoc</span> <span style="font-style: italic;">polymorphism</span>
if it
has at least two but only <span style="font-weight: bold;">finitely
    </span>many
possible types."<sup>1</sup><span style="font-style: italic;"><span style="font-style: italic;"><span style="font-style: italic;"></span></span></span><br>








"A function or operator exhibits <span style="font-style: italic;">universal
polymorphism</span> if it has infinitely many possible types"<br>








  </dd>








</dl>








<h3> Overloading</h3>








<ul>








  <li> When the same symbol translates to different code based on
the
(static) actual parameter types:<br>








  </li>








We say that the operator/function is overloaded.
</ul>








<ul>








  <li>Which code is usually bound statically (before runtime)<br>








  </li>








  <li> In most languages &lsquo;+&rsquo; corresponds to
different code i.e.:</li>








  
  
  
  
  
  
  
  <ul>








    <tt>3 + 4</tt>
  
  
  
  
  
  
  
  </ul>








  <tt>Vs</tt>
  
  
  
  
  
  
  
  <ul>








    <tt>3.6&nbsp; +&nbsp; 4.1<br>








    <br>








    </tt>
  
  
  
  
  
  
  
  </ul>








  <li> Java adds another meaning to &lsquo;+&rsquo;</li>








  
  
  
  
  
  
  
  <ul>








    <tt>&ldquo;one&rdquo; + &ldquo;two&rdquo;</tt>
  
  
  
  
  
  
  
  </ul>








  <li> Ada and C++ allow users to overload operators.</li>








  
  
  
  
  
  
  
  <ul>








    <li>The interaction between overloading and coercion can be
very
tricky.<br>








    </li>








  
  
  
  
  
  
  
  </ul>








  <li> C has no USER overloading -- operators or functions</li>








  <li>Java does not allow users to overload operators.</li>








  <li> &nbsp;<a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/5rAdaOverload.html">Overload
Example from Ada</a></li>








</ul>








<h4>Dangerous Overloading of Operators</h4>








<ul>








  <li> C</li>








  <tt>z = &amp;y&nbsp; /* assign the address of y to x */</tt><br>








  <tt>z = x &amp; y /*assign the bit-wise AND of x and y */</tt><li>
Fortran:</li>








  
  
  
  
  
  
  
  <ul>








    <tt>AVG = SUM/COUNT</tt>
  
  
  
  
  
  
  
  </ul>








( If SUM=20 and COUNT=30 are integers and AVG is a real variable. Then
AVG will be 0.0) <li> Pascal uses a different symbols for
integer
division and real division.&nbsp; div vs &lsquo;/&rsquo;</li>








  <li> Ada makes the above statement illegal since the types do
not
match!</li>








</ul>








<hr noshade="noshade" size="2" width="60%">
<h3>Inclusion Polymorphism&nbsp; Also called subtype
Polymorphism--- <br>








</h3>








<ul>








  <li>A function or operator exhibits <span style="font-style: italic;">inclusion</span>(<span style="font-style: italic;">subtype) polymorphism</span>
if one or
more
of its parameter type have subtypes.</li>








  <li>Ada, Pascal, Haskell, small talk, C++ and Java allow
subtyping.</li>








</ul>








<hr noshade="noshade" size="2" width="60%">
<h3>Object Oriented Programming Languages <br>








</h3>








are characterized by their support of 4 facilities
<ul>








  <li>Encapsulation<br>








  </li>








  <li>Inheritance</li>








  <li>Inclusion polymorphism</li>








  <li>Dynamic binding of function calls to function bodies
(dynamic
dispatching)</li>








</ul>








<h4>Object Oriented languages without CLASSES</h4>








<ul>








  <li>Prototype-based languages<br>








  </li>








  
  
  
  
  
  
  
  <ul>








    <li>Self, JavaScript</li>








    <li>No constructors -- new objects are created from scratch
by
listing all methods</li>








    <li>Usually dynamically typed. <br>








    </li>








    <li>Usually very small amount of encapsulation<br>








    </li>








    <li>No static inheritance --&nbsp; uses a
dynamic&nbsp; mechanism
called <i>delegation</i> <br>








    </li>








    
    
    
    
    
    
    
    <ul>








      <li>What is a Computer? <br>








        
        
        
        
        
        
        
        <table style="text-align: left;" border="0" cellpadding="2" cellspacing="2" width="85%">








          <tbody>








            <tr>








              <td align="left" valign="top">Class
Based - lists<br>








              </td>








              <td align="left" valign="top">Prototyped
Base</td>








            </tr>








            <tr>








              <td valign="top">
              
              
              
              
              
              
              
              <ul>








                <li>CPU</li>








                <li>keyboard</li>








                <li>Monitor <br>








                </li>








              
              
              
              
              
              
              
              </ul>








              </td>








              <td valign="top">
              
              
              
              
              
              
              
              <ul>








                <li>like an Apple Computer<br>








                </li>








              
              
              
              
              
              
              
              </ul>








              </td>








            </tr>








          
          
          
          
          
          
          
          </tbody>
        
        
        
        
        
        
        
        </table>








      </li>








    
    
    
    
    
    
    
    </ul>








  
  
  
  
  
  
  
  </ul>








</ul>








<h4 style="margin-left: 80px;"><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/3hJF03.html">Inclusion
Polymorphism&nbsp; --- Run-time
dispatching</a></h4>








<h4>Parametric Polymorphism</h4>








to be discussed later.
<hr style="width: 100%; height: 2px;">
<h4>C++ -- Memory Leaks and an interesting way to handle it.</h4>








<ul>








  <li>What is the life and scope of the variables in the
following
code?</li>








</ul>








<div style="margin-left: 40px;">
<dl style="font-family: monospace; font-weight: bold;">








  <dd>{ int i = 7;<br>








&nbsp; int *p = new int; /* also new int(); */<br>








&nbsp; *p = 4;<br>








}<br>








  </dd>








</dl>








</div>








<ul>








  
  
  
  
  
  
  
  <ul>








    <li>How do we correct the memory leak?</li>








  
  
  
  
  
  
  
  </ul>








</ul>








<ul>








  <li>&nbsp;A class that handles the delocation
responsibility (good
for stack variables)<br>








  </li>








</ul>








<div style="margin-left: 40px;">
<dl>








  <dd><span style="font-family: monospace;"><span style="font-weight: bold;">class SuperPtr {<br>








&nbsp;superPtr(){<br>








&nbsp; &nbsp;prt = new int;<br>








&nbsp;}<br>








&nbsp;~superPtr() {<br>








&nbsp; &nbsp;delete ptr;<br>








&nbsp;}<br>








&nbsp;int* ptr;<br>








}<br>








    </span></span></dd>








</dl>








<ul>








  
  
  
  
  
  
  
  <ul>








    <li>What happens when you try to use it? i.e.</li>








  
  
  
  
  
  
  
  </ul>








</ul>








<dl>








  <dd><span style="font-family: monospace;"><span style="font-weight: bold;">{ &nbsp;...<br>








&nbsp; superPtr sp;<br>








&nbsp; &nbsp;...<br>








}<br>








    </span></span></dd>








</dl>








</div>








<ul>








  <dd><span style="font-family: monospace;"><span style="font-weight: bold;"> </span></span><br>








    <span style="font-family: monospace;"><span style="font-weight: bold;"> </span></span></dd>








  
  
  
  
  
  
  
  <ul>








    <li>To make useful we want SuperPtr objects to behave link
pointers
overload the pointer operator ("*"). So include the method:</li>








  
  
  
  
  
  
  
  </ul>








  
  
  
  
  
  
  
  <div style="margin-left: 40px;">
  
  
  
  
  
  
  
  <dl>








    <dd><span style="font-family: monospace;"><span style="font-weight: bold;">SuperPrt:: operator * () {<br>








&nbsp; return *prt; &nbsp;// <small>returns the
reference of the
location prt was pointing to</small> <br>








}</span></span><br>








      <br>








    </dd>








  
  
  
  
  
  
  
  </dl>








  
  
  
  
  
  
  
  <ul>








    
    
    
    
    
    
    
    <ul>








      <li>Now we can write:&nbsp;</li>








    
    
    
    
    
    
    
    </ul>








    
    
    
    
    
    
    
    <dl>








      <dt><span style="font-family: monospace;"><span style="font-weight: bold;">{ SuperPrt sp;<br>








&nbsp; &nbsp;...<br>








&nbsp; &nbsp;*sp = 7;<br>








&nbsp; &nbsp;...<br>








}<br>








        </span></span></dt>








    
    
    
    
    
    
    
    </dl>








    
    
    
    
    
    
    
    <ul>








      <li>What happens during execution?</li>








    
    
    
    
    
    
    
    </ul>








    
    
    
    
    
    
    
    <dl>








      <dd><br>








        <br>








      </dd>








    
    
    
    
    
    
    
    </dl>








  
  
  
  
  
  
  
  </ul>








  </div>








  
  
  
  
  
  
  
  <ul>








    <li>Extending SuperPtr class to the <i><a href="file:///mnt/extra/homes/head/Courses/471/NOTES/RunTime/2rS04.html#pair">pair&lt;int,
int&gt;</a>, &nbsp;</i>we need to overload both the
"*" and "-&gt;"</li>








  
  
  
  
  
  
  
  </ul>








  
  
  
  
  
  
  
  <div style="margin-left: 40px;">
  
  
  
  
  
  
  
  <dl>








    <dd><tt><b>class SuperPtr {<br>








      <br>








&nbsp; public : <br>








&nbsp; &nbsp;SuperPtr() { prt = new pair&lt;int,
int&gt; (); }<br>








&nbsp; &nbsp;~SuperPtr() { delete prt; }<br>








&nbsp; &nbsp;pair&lt;int,int&gt; * prt;<br>








&nbsp; &nbsp;pair&lt;int,int&gt; &amp; operator* ();<br>








&nbsp; &nbsp;pair&lt;int,int&gt; * operator -&gt;();<br>








&nbsp; &nbsp;<br>








}<br>








pair&lt;int,int&gt;&amp; SuperPrt::operator*() { return
*prt; }<br>








pair&lt;int,int&gt;* SuperPrt::operator-&gt;() { return
prt; }<br>








... SuperPrt::f(...) {...}<br>








      <br>








//<i>Using it<br>








      <br>








      </i>void fun(void){ <br>








&nbsp; &nbsp;SuperPtr Sp; &nbsp;//<small> Where is
SuperPtr ? where is
prt?</small><br>








&nbsp; &nbsp;Sp-&gt; first=7; //<small>Returns a
reference to member <i>prt.</i>So
executes like prt-&gt;first</small><br>








&nbsp; &nbsp;SuperPtr* S = new SuperPtr;<br>








&nbsp; &nbsp;(*S); &nbsp;// <small>dereference
operator,&nbsp;</small> <br>








&nbsp;&nbsp; S-&gt; f(); // <small>component
selection operator</small><br>








&nbsp; &nbsp;(*S)-&gt;first; // <small>Overloaded
"-."</small><br>








      </b></tt></dd>








  
  
  
  
  
  
  
  </dl>








  
  
  
  
  
  
  
  <dl>








    <dd>}<br>








    </dd>








  
  
  
  
  
  
  
  </dl>








  <span style="font-family: monospace;"></span></div>








  <a href="http://ootips.org/yonat/4dev/smart-pointers.html">More
tips
on
smart-pointers</a>
</ul>










<p></p>








</body>
</html>
