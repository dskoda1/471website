<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

  <meta name="Author" content="Eileen Head">

  <meta name="GENERATOR" content="Mozilla/4.77 [en] (Windows NT 5.0; U) [Netscape]">
  <title>Routines - Parameter Passing</title>


</head>


<body>

<center>
<h3>Parameter Passing Semantics: Spring 2007</h3>

</center>

<h3> Goal: Explore various different parameter passing schemes
and
typing of functions.</h3>

<h3> What will be covered ?</h3>

<ul>

  <li> The semantics of different parameter passing mechanisms</li>

  <li> Named parameters</li>

</ul>

<hr width="100%"> <span style="font-weight: bold;">Subprograms
and Parameters</span>
<ul>

  <li> Most languages distinguish between</li>

  <ul>

    <li> Procedures</li>

    <li> Functions.</li>

    <li> Object oriented languages call them methods.</li>

  </ul>

  <li> Subprograms</li>

  <ul>

    <li> Have a name,</li>

    <li> Formal parameter types (and formal parameter names in
several
languages)</li>

    <ul>

      <li> Arity is the number of parameters</li>

    </ul>

    <li> Return type, in the case of a function.</li>

  </ul>

  <li> &nbsp;Algol 68 and C, C++, Java do not distinguish
between
functions and procedures</li>

  <ul>

    <li> Using the return type <i>void</i> simulates
a procedure</li>

  </ul>

  <hr width="100%">Ada Example:
  <p><b><tt>PROCEDURE max (x,y : in INTEGER; maximum
: out INTEGER) is</tt></b> </p>

  <ul>

    <b><tt>BEGIN</tt></b> <br>

    <b><tt>&nbsp; IF x &gt; y THEN</tt></b>
    <ul>

      <b><tt>maximum := x;</tt></b>
    </ul>

    <b><tt>&nbsp; ELSE</tt></b>
    <ul>

      <b><tt>maximum := y;</tt></b>
    </ul>

    <b><tt>&nbsp; END IF;</tt></b> <br>

    <b><tt>END max;</tt></b>
  </ul>

  <b><tt>FUNCTION max1 (x,y : in INTEGER) return INTEGER is</tt></b>
  <ul>

    <b><tt>BEGIN</tt></b> <br>

    <b><tt>&nbsp; IF x &gt; y THEN</tt></b>
    <ul>

      <b><tt>return x;</tt></b>
    </ul>

    <b><tt>&nbsp; ELSE</tt></b>
    <ul>

      <b><tt>return y;</tt></b>
    </ul>

    <b><tt>&nbsp; END IF;</tt></b> <br>

    <b><tt>END max1;</tt></b>
  </ul>

</ul>

<hr width="100%"> <span style="font-weight: bold;">Parameter
Passing Mechanisms</span>
<dl>

  <li> One of the most important design decisions is which
parameter
passing methods are implemented</li>

  <dl>

    <li> Pass by Value (Pass by&nbsp;<span style="font-style: italic;">assignment</span>, Pass by
      <span style="font-style: italic;">sharing</span>)</li>

    <li> Pass by Result</li>

    <li> Pass by Value Result (also called Copy in, Copy out)</li>

    <li> Pass by Reference</li>

    <li> Pass by Name</li>

    <br>

    <hr width="100%">
    <h4> Pass by Value (Pass by "assignment", "sharing")
&nbsp;</h4>

  </dl>

</dl>

<ul>

  <li>Default mechanism in Pascal, Modula-2, Ada and C#</li>

  <li>Main mechanism in C and Algol 68</li>

  <li>Behavior depends on whether the language uses a&nbsp;<span style="font-style: italic;">value</span> model
or&nbsp;<span style="font-style: italic;">reference&nbsp;</span>model.</li>

  <ul>

    <li><b>Only</b> mechanism in Java and Python</li>

    <li>immutable vs mutable objects</li>

  </ul>

</ul>

<dl>

  <dl>

    <li> Arguments are</li>

    <dl>

      <li> Evaluated at time of call</li>

      <li> Becomes the values of the parameters during the
execution of
the subprogram</li>

      <dl>

        <li> Some language may not evaluation of the arguments</li>

        <dl>

          <dl>

&nbsp;
          </dl>

        </dl>

      </dl>

      <b><tt>int upOnly(int i, int j){</tt></b>
      <dl>

        <b><tt>if (j &gt; 0) return (i+j);</tt></b><br>

        <b><tt>else return i;</tt></b>
      </dl>

      <b><tt>}</tt></b><br>

      <b><tt>&nbsp;&nbsp; ...</tt></b><br>

      <b><tt>upOnly(x+y, 2+3);</tt></b><br>

      <hr size="1" width="100%">
    </dl>

Pascal, Java and Modula-2 parameters are treated like initialized local
variables
    <dl>

      <li> Assignments to the parameters do not cause changes
outside
the subprogram</li>

      <li> Ada: The <i>in</i> parameter may not be
assigned to</li>

      <li> Java: The keyword <i>final</i> prevents
assigning to the
parameter at all.</li>

      <dl>

        <li> However, objects may receive messages that change
the
objects internal state</li>

        <dl>

&nbsp;
        </dl>

        <b><tt>void methodJ (final Obj obj) {</tt></b><br>

        <b><tt>&nbsp;&nbsp;&nbsp;
obj.changeStateTo(300);</tt></b><br>

        <b><tt>&nbsp;&nbsp;&nbsp; obj = new
Obj(); // will not compile</tt></b><br>

        <b><tt>}</tt></b><li> This C++
code has the same effect as the
Java code</li>

        <br>

        <b><tt>void methodC (const Obj &amp;obj){</tt></b>
        <dl>

          <b><tt>obj.changeStateTo(300);</tt></b><br>

          <b><tt>&nbsp;&nbsp;&nbsp; obj = *(new
Obj()); // will not
compile</tt></b>
        </dl>

        <b><tt>}</tt></b><br>

      </dl>

    </dl>

    <hr size="1" width="75%"> <br>

What kinds of methods can not be easily coded?<br>

  </dl>

</dl>

<div style="margin-left: 40px;">
<ul>

  <li>Swap</li>

</ul>

</div>

<hr size="1" width="75%">
<div style="margin-left: 40px;">Evaluation of parameters </div>

<dl>

  <dl>

    <dl>

      <li> Order of evaluation of parameters with side effects
can be
resolved by insisting on an order in evaluating (right to left or left
to right).</li>

      <dl>

        <li> Java enforces the above</li>

      </dl>

      <li> Most languages the evaluation order is implementation
dependent.</li>

      <hr size="1" width="100%">Parameter
Evaluation and Side Effects <li> Try on a variety of C and
C++
compilers:</li>

      <dl>

        <dl>

          <b><tt>y = -1;</tt></b><br>

          <b><tt>upOnly(++y, ++y);</tt></b>
        </dl>

        <li> Some implementations evaluate the first parameter
(and
modify it) before the second, others evaluate the last parameter first.</li>

      </dl>

      <li> Some language definitions make this dependency an
error.</li>

    </dl>

  </dl>

  <dl>

    <hr size="3" width="100%">
    <h4> Pass by Reference (or by Sharing)</h4>

    <ul>

      <b><tt>program Test();</tt></b> <br>

      <b><tt>var innocent :integer;</tt></b>
      <p><b><tt>procedure modify(var Share: integer);</tt></b>
      </p>

      <dl>

        <dl>

          <b><tt>begin</tt></b>
          <dl>

            <b><tt>Share := Share + 3;</tt></b>
          </dl>

          <b><tt>end;</tt></b>
        </dl>

        <b><tt>begin</tt></b>
        <dl>

          <b><tt>innocent := 100;</tt></b><br>

          <b><tt>modify(innocent) {upon return innocent is
103}</tt></b>
        </dl>

        <b><tt>end.</tt></b>
        <dl>

          <dl>

&nbsp;
          </dl>

        </dl>

        <li> The argument's allocated location is bound to the
parameter
during the call.</li>

        <dl>

          <li> The parameter becomes an <b>alias</b>
for the argument<b>.</b></li>

        </dl>

        <li> Therefore any changes to the parameter will have
affects
outside the called subprogram.</li>

        <li> Arguments must have l-values.</li>

        <li> This is the only mechanism in Fortran 77 and earlier.</li>

        <li> Pascal, Modula 2 use the keyword <i>VAR</i>
to signal
pass by reference</li>

        <li>C# use the keyword <span style="font-style: italic;">ref </span>to signal
pass by reference</li>

        <dl>

          <hr noshade="noshade" size="1" width="100%">
        </dl>

      </dl>

      <span style="font-style: italic;"></span>
    </ul>

    <li><span style="font-style: italic;"></span>Simulation
of pass by reference</li>

  </dl>

</dl>

<span style="font-style: italic;"></span>
<dl>

  <dl>

    <ul>

      <dl>

        <li> C &amp; Algol68: A pointer is used to pass a
location
explicitly.<br>

        </li>

        <li> In C:&nbsp; pass by value (<span style="font-style: italic;">assignment</span>) a
pointer type.<br>

          <br>

        </li>

        <dl>

          <b><tt>void refer (int *x) {</tt></b>
          <dl>

            <b><tt>*x += 1;</tt></b>
          </dl>

          <b><tt>}</tt></b><br>

          <b><tt>int main() {</tt></b>
          <dl>

            <b><tt>int a;</tt></b><br>

            <b><tt>&hellip;</tt></b><br>

            <b><tt>refer(&amp;a);</tt></b>
          </dl>

          <b><tt>}</tt></b>
        </dl>

      </dl>

    </ul>

  </dl>

</dl>

<dl>

  <dl>

    <ul>

      <li> C: Arrays are passed with the same semantics as <span style="font-style: italic;">final </span>reference
"types" are passed
in Java.</li>

      <dl>

        <dd style="font-family: monospace; font-weight: bold;">int
passArr( int [] a) {</dd>

        <dt style="font-family: monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
...</dt>

        <dd><span style="font-family: monospace; font-weight: bold;">}</span><br>

        </dd>

      </dl>

      <li>C++ has introduced explicit "pass-by-reference" by
introducing a&nbsp;<span style="font-style: italic;">reference</span>
type -- alias type</li>

      <dl>

        <dl>

          <b><tt>void refer(int&amp; x){</tt></b>
          <dl>

            <b><tt>x += 1;</tt></b>
          </dl>

          <b><tt>}</tt></b><br>

          <b><tt>void fun() {</tt></b>
          <dl>

            <b><tt>int&nbsp; a;</tt></b><br>

            <b><tt>...</tt></b><br>

            <b><tt>refer(a);</tt></b>
          </dl>

          <b><tt>}</tt></b><br>

          <hr noshade="noshade" size="1" width="100%">
        </dl>

        <li> C++: The ref type can be used other locations in the
code:<br>

        </li>

        <dl>

          <b><tt>void f() {</tt></b>
          <dl>

            <b><tt>int i;</tt></b><br>

            <b><tt>int &amp;r = i;&nbsp;</tt></b>//
r refers to i <br>

            <b><tt>r = 9;&nbsp;</tt></b>//
the value i becomes is 9 <br>

i<b><tt>nt * p = &amp;i;&nbsp;</tt></b>//
p points to i <br>

            <b><tt>int &amp; rr = r ;</tt></b>&nbsp;//
rr&nbsp;refers
to
i
          </dl>

}
          <h6> (Ellis &amp; Stroustup,<i>Annotated C++,
          </i>page 153)</h6>

          <hr noshade="noshade" size="1" width="100%">
        </dl>

&nbsp;
        <dl>

          <b><tt>procedure swap (var x: integer,</tt></b><br>

          <b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
var y: integer);</tt></b>
          <dl>

            <b><tt>var z:integer</tt></b><br>

            <b><tt>begin</tt></b>
            <dl>

              <b><tt>z:=x;</tt></b><br>

              <b><tt>x:=y;</tt></b><br>

              <b><tt>y:=z;</tt></b>
            </dl>

            <b><tt>end</tt></b>
          </dl>

        </dl>

        <li> Early versions of Fortran did not check if the
actual
parameter was assignable.</li>

        <dl>

          <li> Calling swap(1,2) would result in the constants
being
interchanged.&nbsp; Later the code would calculate 1+1 = 4.</li>

        </dl>

      </dl>

    </ul>

  </dl>

</dl>

<dl>

  <dl>

    <ul>

    </ul>

    <hr size="3" width="100%">
    <h4> <b>Pass by Value-Result</b></h4>

    <ul>

      <dl>

        <li> Also called <b>COPY-IN, COPY-OUT.</b></li>

        <li> In Ada, this is the mechanism of the IN OUT
parameter for
scalar types</li>

        <li> Aliasing distinguishes pass by value-result from
pass by
reference</li>

        <br>

        <b><tt>a : INTEGER;</tt></b><br>

        <b><tt>PROCEDURE p(x,y: IN OUT INTEGER) is</tt></b><br>

        <b><tt>&nbsp; BEGIN</tt></b>
        <dl>

          <b><tt>x := x + x ;</tt></b><br>

          <b><tt>y := y + y;</tt></b>
        </dl>

        <b><tt>&nbsp; END;</tt></b>
        <p><b><tt>&nbsp; BEGIN</tt></b>
        </p>

        <dl>

          <b><tt>a := 1;</tt></b><br>

          <b><tt>p(a,a);</tt></b>
        </dl>

        <b><tt>&nbsp; END;</tt></b><br>

&nbsp;<li> Assuming pass by reference what is the last value
of "a"?</li>

        <li> Assuming pass by Copy-in Copy-out what is the last
value
of
"a"?<br>

        </li>

        <hr size="1" width="100%">
      </dl>

    </ul>

  </dl>

</dl>

<h4 style="margin-left: 80px;">Issues left unspecified </h4>

<dl>

  <dl>

    <ul>

      <dl>

        <li> Order the results are copied back</li>

        <li> Are the locations of arguments stored or
recalculated on
return?</li>

        <li> ADA Quirk:&nbsp; Ada's definition states that in
out
parameters may be implemented as pass by reference or pass by
value-result for non-scalar types.</li>

        <br>

        <hr size="1" width="100%">
      </dl>

    </ul>

  </dl>

</dl>

<h4 style="margin-left: 80px;">Another Swap&nbsp;: </h4>

<dl>

  <dl>

    <ul>

      <dl>

        <b><tt>ADA:</tt></b><br>

        <b><tt>PROCEDURE Main IS</tt></b><br>

        <b><tt>&nbsp;&nbsp;&nbsp; PROCEDURE
Swap(x,y: IN OUT integer) is</tt></b>
        <dl>

          <b><tt>&nbsp;&nbsp; BEGIN</tt></b>
          <dl>

            <b><tt>x := x + y;</tt></b><br>

            <b><tt>y := x - y;</tt></b><br>

            <b><tt>x := x - y;</tt></b>
          </dl>

          <b><tt>&nbsp;&nbsp; END;</tt></b>
        </dl>

        <b><tt>&nbsp;&nbsp;&nbsp; BEGIN</tt></b>
        <dl>

          <b><tt>a := 1;</tt></b><br>

          <b><tt>Swap(a,a);</tt></b>
        </dl>

        <b><tt>&nbsp;&nbsp;&nbsp; END;</tt></b><br>

&nbsp;
        <p><b><tt>Pascal:</tt></b> <br>

        <b><tt>PROCEDURE MAIN</tt></b> <br>

        <b><tt>&nbsp;&nbsp; PROCEDURE Swap(VAR x,y:
integer);</tt></b> </p>

        <dl>

          <b><tt>BEGIN</tt></b>
          <dl>

            <b><tt>x := x + y ;</tt></b><br>

            <b><tt>y := x - y ;</tt></b><br>

            <b><tt>x := x - y ;</tt></b>
          </dl>

          <b><tt>END;</tt></b>
        </dl>

        <b><tt>&nbsp;&nbsp; BEGIN</tt></b>
        <dl>

          <b><tt>a := 1;</tt></b><br>

          <b><tt>Swap(a,a)</tt></b>
        </dl>

        <b><tt>&nbsp;&nbsp; END;</tt></b><li>
What is the last value of
a after each is executed?</li>

        <dl>

          <hr size="1" width="100%">
        </dl>

        <li> What is the value of "a" after p is called? (Ada 1,
Pascal
0)</li>

        <li> Another difference:</li>

        <dl>

          <li> If the subprogram terminates abnormally (i.e.. via
an
exception handler) the actual parameter</li>

          <dl>

            <li> might have changed value using the call by
reference.</li>

            <li> but actual parameter will not change using call
by
value-result</li>

          </dl>

        </dl>

      </dl>

    </ul>

  </dl>

</dl>

<dl>

  <dl>

    <ul>

      <dl>

        <li> <a name="AdaMatrix"></a><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/4rAFall00.html">Swap
Problem 4 using Matrices in ADA</a></li>

      </dl>

    </ul>

    <hr size="3" width="100%">
    <h4> Pass by Name&nbsp;</h4>

    <ul>

      <dl>

        <li> Used in Algol 60&nbsp;</li>

        <li>Haskell implements a variation -- &nbsp;Lazy
evaluation</li>

        <li> Arguments are not evaluated until their actual use
in the
called program.</li>

        <li> Example:</li>

        <dl>

&nbsp;<br>

          <b><tt>int i;</tt></b><br>

          <b><tt>int a[ ] = new int[2];</tt></b><br>

          <b><tt>void p(x) {&nbsp; //pass by name</tt></b><br>

          <b><tt>&nbsp;&nbsp;&nbsp; i = i+1;</tt></b><br>

          <b><tt>&nbsp;&nbsp;&nbsp; x = x+1;</tt></b><br>

          <b><tt>}</tt></b><br>

          <b><tt>void main() {</tt></b>
          <dl>

            <b><tt>i = 0;</tt></b><br>

            <b><tt>a[0] = 0;</tt></b><br>

            <b><tt>a[1] = 1;</tt></b><br>

            <b><tt>p( a[i] );</tt></b>
          </dl>

          <b><tt>}</tt></b>
        </dl>

        <li> To &ldquo;hand execute&rdquo; pass by name,</li>

        <dl>

          <li> just substitute the actual parameters textually in
place
of the formal parameters.</li>

          <li>In fact, each reference to a call by name reference
is
implemented
by</li>

        </dl>

      </dl>

    </ul>

  </dl>

</dl>

<blockquote>
  <blockquote>
    <blockquote>
      <blockquote><b><i>jump out</i></b>
to the argument (called a <i>"thunk"</i>
)<br>

execute the argument expression <br>

        <b><i>jump back</i> </b>into the
routine </blockquote>

    </blockquote>

  </blockquote>

</blockquote>

<dl>

  <dl>

    <ul>

      <dl>

        <dl>

          <li> Thus the above would be</li>

          <br>

          <b><tt>in main: i = 0;</tt></b><br>

          <b>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
a[0] = 0;<br>

&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; a[1] = 1;</b><br>

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b><tt>in
p(x):
i = i + 1;</tt></b>
          <dl>

            <dl>

              <b><tt>a[i] = a[i]+1;</tt></b>
            </dl>

          </dl>

        </dl>

        <li> Unlike other languages, this code modifies a[1], not
a[0]!</li>

        <li> <a name="Jensen"></a><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/4rBFall00.html">Jensen's
Device</a> is an example showing the power of pass by name.</li>

      </dl>

    </ul>

  </dl>

</dl>

<hr noshade="noshade" size="2" width="50%">
<dl>

  <dl>

    <ul>

    </ul>

  </dl>

</dl>

<dl>

</dl>

<h4 style="margin-left: 40px;">
Functional Languages and Pass by Name </h4>

<dl>

  <dl>

  </dl>

</dl>

<ul>

  <li>Since functional languages do not have state changes a
variation
of
Pass by Name, Lazy evaluation, is an excellent mechanism for passing
variables.</li>

  <ul>

    <li>Lazy evaluation evaluates each argument at most once.</li>

  </ul>

  <li>This the main mechanism in Haskell
    <dl>

      <li>This mechanism enables new and interesting programming
abstraction.</li>

    </dl>

  </li>

</ul>

<ul>

  <li>In non pure functional languages call by name is hard to
implement</li>

  <li> If in evaluating&nbsp; the parameter, the parameter is
a
functions with side effects, you may effect in unexpected ways the
value of a variable in later use.</li>

  <li> The semantics of call by name is very difficult to very
messy to
implement.</li>

</ul>

<hr noshade="noshade" size="2" width="90%">
<h4 style="margin-left: 40px;">Macro expansion vs.
procedure "pass by name"</h4>

<ul>

  <li>Similarity: both "employ" textural substitution</li>

  <li>For procedural calls substitution is theoretical model how
the
parameter
bind.</li>

  <li>For macro expansion the textural substitution is the <b>actual
implementation</b></li>

  <li>The<b> #define</b>&nbsp; preprocessor
command (in <b>C</b> )
causes
an <i>identifier name</i> to become defined as macro to
preprocessor.</li>

  <li><i>function-like</i> macro definition:</li>

</ul>

<blockquote style="margin-left: 80px;"><b>#define <i>name</i>
( <i>name</i>1, <i>name</i>2<i>,
...)
body</i><i>&nbsp;</i></b></blockquote>

<ul>

  <li>invocation:</li>

</ul>

<blockquote style="margin-left: 80px;"><b><i>name</i>
( <i>arg</i>1, <i>arg</i>2 ...)</b><br>

</blockquote>

<ul>

  <li>example: If a macro sum with two arguments is defined by<br>

  </li>

</ul>

<blockquote style="margin-left: 80px;"><b><tt>#define
sum(x,y) &nbsp; x+y</tt></b><br>

</blockquote>

<ul>

  <li>then the preprocessor replaces the source line (before
compiling)</li>

</ul>

<blockquote>
  <div style="margin-left: 80px;"><b><tt>result
= sum (</tt><tt> a, 3*a +b )</tt></b>;<br>

  </div>

&nbsp; &nbsp; &nbsp; &nbsp;with<br>

  <div style="margin-left: 80px;"><b><tt>result
= a &nbsp;+ 3*a +b; </tt></b><br>

  </div>

</blockquote>

<ul>

  <li>The expansion steps:</li>

</ul>

<blockquote>
  <ol>

    <li>substitute text of macro call's argument for each
occurrence of <i>nameX</i>
in body</li>

    <li>substitute resulting body for the macro call</li>

  </ol>

</blockquote>

<ul>

  <li>Swap Problem 5 : macro / call by name</li>

</ul>

<blockquote><b><tt>&nbsp; &nbsp; #define</tt></b>
swap(a,b) { int t;
t=a;
a=b; b=t; }<br>

then<br>

&nbsp; &nbsp; &nbsp;<b><tt> swap( i, A[i] )</tt></b>
;<br>

becomes<br>

&nbsp; &nbsp; <b><tt>&nbsp;{ int t; t=i;
i=A[i]; A[i]=t; };</tt></b><br>

Both call by name and macro have a "side effect" problem -- changing <i>i</i>'s
r-value changes <i>A</i>[<i>i</i>] l-value.<br>

</blockquote>

<ul>

  <li>Difference between call by name and macros:</li>

</ul>

<blockquote><b><tt>float e =2.71828;<br>

#define p(x) (x/e)<br>

...<br>

int f (int e ) {<br>

&nbsp; &nbsp;...<br>

&nbsp; &nbsp;p(z);<br>

&nbsp; &nbsp;...</tt></b><br>

}<br>

</blockquote>

<ul>

  <li>This example creates a name conflict -- &nbsp;the
compiler sees:<br>

  </li>

</ul>

<blockquote><b><tt>float e =2.71828;<br>

  <br>

...<br>

int f (int e ) {<br>

&nbsp; &nbsp;...<br>

&nbsp; &nbsp;p(z/e); &nbsp;/* DIVIDES the WRONG "e" */<br>

&nbsp; &nbsp;...</tt></b><br>

}<br>

</blockquote>

<ul>

</ul>

<blockquote>
  <ul>

  </ul>

</blockquote>

<ul>

  <li>Macro expansion imports <i>e</i> into the
scope of a different
binding
of <i>e -- </i>a case of <i><b>dynamic
scoping</b></i>.</li>

  <li>Naming problems can be avoided by true call by name
parameter
binding.</li>

</ul>

<dl>

  <hr size="1" width="100%">
  <h4> Some additional variations : Default Parameter Values</h4>

</dl>

<dl>

  <li> Conformant Arrays</li>

  <li> Variable number of arguments </li>

  <li>C++</li>

  <dl>

    <b><tt>int get_word(char*, int &amp;, int start =
0);</tt></b>
    <dl>

      <li> <i>C: Parameter names are not needed in
function prototype</i></li>

    </dl>

    <li> Ada</li>

    <br>

TYPE intptr is ACCESS integer;
    <p>FUNCTION Get_word(C : String; X : intptr; Start : integer
:= 0 ) </p>

    <dl>

RETURN Integer;
    </dl>

  </dl>

  <li> Both languages parameters with default values can be
omitted</li>

  <li> C++ needs the default parameters places at the end of the
list
of
parameters</li>

  <dl>

    <li> Otherwise, function calls would be ambiguous</li>

  </dl>

  <li> Ada the order is normal.</li>

  <li> Ada allows <i>named</i> parameter passing</li>

</dl>

<dl style="margin-left: 80px;">

  <b><tt>V := Get_word( Start =&gt; 1,</tt></b><b><tt>C
=&gt; &ldquo;abc&rdquo;,</tt></b><b><tt><br>

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp;X =&gt; new integer&rsquo;(1)</tt></b><b><tt><br>

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; );</tt></b><br>

</dl>

<dl>

  <ul>

    <dl>

      <dl>

      </dl>

    </dl>

  </ul>

</dl>

<ul>

  <ul>

    <li>The existence of named parameter passing forces Ada to
require
that parameter names be provided in the subprogram declaration.<br>

    </li>

  </ul>

  <li>Python also allows default parameters and named parameters</li>

</ul>

<div style="margin-left: 80px;"><span style="font-family: monospace;">def func(spam, eggs,
toast=0, ham=0):<br>

&nbsp; &nbsp; &nbsp;print (spam,eggs,toast,ham)<br>

</span></div>

<div style="margin-left: 40px;">
<ul>

  <li>can be invoked by</li>

</ul>

<div style="margin-left: 40px;"><span style="font-family: monospace;"><span style="font-weight: bold;">func(1,2)</span><br>

<br>

OR<br>

<br>

<span style="font-weight: bold;">func(1,ham=1,eggs=0)</span><br>

<br>

Or<br>

<br>

</span></div>

</div>

<div style="margin-left: 80px;"><span style="font-family: monospace; font-weight: bold;">func(</span><span style="font-family: monospace;"><span style="font-weight: bold;">spam=1, eggs=0)</span><br>

<br>

Or<br>

<br>

<span style="font-weight: bold;">func(1,2,3,4)</span></span></div>

<ul>

</ul>

<dl>

</dl>

<hr width="100%"><br>

</body>
</html>
