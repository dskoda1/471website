<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>

    
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    
    
  <title>Notes</title>
  <link rel="stylesheet" type="text/css" href="../../../image/default.css" />
</head>














  <body>

  
<div>

<h1>Names</h1>


<h2>http://www.technocage.com/~ray/notespage.jsp?pageName=names<br />
</h2>
<h2>Why Study Naming?</h2>


<p>One of the most important influences on a programming language's
usability and readability is its use of names.</p>


<h3>What can be named?</h3>


Types, variables, constants, labels. blocks, subroutines,
fields, methods, packages, modules, classes, operators,
threads, tasks, parameters, ...

<h3>What can names look like?</h3>


<ul>

  <li>Usually they are alphanumeric strings</li>

  <li>Sometimes they are paths with '.' or '/' separators</li>

  <li>Some names are symbolic strings (you can even define your
  own symbolic identifiers in ML)</li>

</ul>


<h2>Terminology</h2>


<dl>

  <dt>Binding</dt>

  <dd>The attachment of a name to a entity</dd>

  <dt>Binding Time</dt>

  <dd>The instant a binding is applied</dd>

  <dt>Binding Lifetime</dt>

  <dd>The duration in which the binding is active (Note: <em>the
  lifetime of the binding can be different from the lifetime
  of the entity to which the name is bound</em>.)</dd>

  <dt>Scope</dt>

  <dd>The textual area of the code in which the binding is usable</dd>

  <dt>Referencing Environment</dt>

  <dd>The current set of bindings in effect at
  a given point</dd>

  <dt>Polymorphism</dt>

  <dd>The same name being bound to different entities at the same time</dd>

  <dt>Aliasing</dt>

  <dd>Multiple names being bound to the same entity at the same time</dd>

</dl>


<h2>Object Lifetime vs. Binding Lifetime</h2>


<h3>A Typical Scenario</h3>


<p>Typically we see:</p>

<ol>

  <li>Object is created</li>

  <li>Binding is created</li>

  <li>Over and over again...
    
    <ol>

      <li>The object is accessed through the binding</li>

      <li>Binding gets deactiviated</li>

      <li>Binding gets reactivated</li>

    
    </ol>

  </li>

  <li>Binding is destroyed</li>

  <li>Object is destroyed</li>

</ol>


<h4>Example</h4>


<pre class="code">int a;                 // 1. Object is created<br />                       // 2. Name 'a' is bound to it<br /><br />int main() {<br />    a = 2;             // 3. Object is accessed through bound name<br />    f();<br />    printf("%d\n", a);<br />    return 0;<br />}<br /><br />void f() {<br />    int a;             // 4. The binding of name 'a' to the global<br />                       //    object is deactivated.<br />    ...<br />}                      // 5. On exit, binding of 'a' to global object<br />                       //    is reactivated<br /><br />                       // 6. After main() exits, the binding is destroyed<br />                       // 7. Finally, the object is destroyed<br /></pre>


<h3>Objects Outliving Bindings</h3>


<p>This happens a lot, and is normal</p>


<pre class="code">void f(int&amp; x) {x = 5;}<br />.<br />.<br />.<br />int y;<br />f(y);<br />cout &lt;&lt; y;<br /></pre>


<h3>Bindings Outliving Objects</h3>


<p>This is usually a bug...</p>


<pre class="code">int* a = (int*)(malloc(sizeof(int)));<br />*a = 2;<br />free(a);<br />*a = 3;  // NOOOOOOO!!!<br /></pre>


<h2>Object Allocation</h2>


<p>There are three kinds of objects</p>


<table class="centered">

  <tbody>
    <tr>

  <th>Allocation Type</th>

  <th>Description</th>

  <th>Examples</th>

  <th>Notes</th>

    </tr>

  <tr>
      <td>Static</td>

  <td>Allocated at fixed location in memory</td>

  <td>Global variables<br />
String and floating point constants</td>

  <td>&nbsp;</td>

    </tr>
    <tr>

  <td>Stack (a.k.a. Auto)</td>

  <td>Allocated and deallocated with subroutine calls and returns</td>

  <td>Locals<br />
Temporaries</td>

  <td>"LIFO"</td>

    </tr>

    <tr>

  <td>Heap</td>

  <td>Dynamically allocated and deallocated</td>

  <td>Things made with 'new' or 'malloc'</td>

  <td>Allocation can be implicit or explicit<br />
Deallocation
  can be implicit or explicit<br />
Watch out for memory
  leaks and dangling references</td>

    </tr>

  </tbody>
</table>


<p>An example in C++:</p>


<pre class="code">int x = 5;                      // Static<br /><br />void f() {<br />    static float y = 0;         // Static<br />    int z;                      // Stack<br />    y++;<br />    print("abcdef");            // Literal probably static<br />}                               // z deallocated here<br /><br />void g() {<br />    int* p = new int;           // p on stack, *p on heap<br />    .<br />    .<br />    .<br />    delete p;                   // explicit deallocation of *p<br />    int* q = new int[10];       // q on stack, *q on heap<br />    .<br />    .<br />    .<br />    h(q);<br />    .<br />    .<br />    .<br />    delete[] q;<br />}<br /><br />void h(int* a) {                // a on stack, *a don't care!<br />    .<br />    .<br />    .<br />    *a = 5;<br />    a[6] = 3;<br />    a = new int;                // doesn't affect old object<br />}                               // a goes away here, but not *a<br /></pre>


<div class="exercise"><strong>Exercise</strong>:
Draw pictures that show what's going on in this example.</div>


<h2>Scope</h2>


<p>The <strong>scope of a binding</strong> is the region in
a program in which the binding is active.</p>


<ul>

  <li>Some languages (C, C++, Ada, Java, Fortran, ML) employ
  <em>static scoping</em> (also called lexical scoping), meaning
  all scopes can be determined at compile time.</li>

  <li>Some languages (APL, Snobol early LISP) employ
  <em>dynamic scoping</em>, meaning scopes depend
  on runtime execution.</li>

  <li>Perl lets you have both!</li>

</ul>


<h3>Static Scope</h3>


<p>Static scoping generally goes with block-structure</p>


<pre>                    +-----------------------------------------------+<br />       procedure P  |  (X: Integer) is                              |<br />     +--------------+                                               |<br />     |    A, B: Integer;                                            |<br />     |                +------------------------------------------+  |<br />     |    procedure Q | (Y: Integer) is                          |  |<br />     |  +-------------+  +------------------------------------+  |  |<br />     |  |    function R  |  (X, Y: Integer) return Integer is |  |  |<br />     |  |  +-------------+    +---------------+               |  |  |<br />     |  |  |    procedure T   |  is           |               |  |  |<br />     |  |  |  +---------------+               |               |  |  |<br />     |  |  |  |    T: Integer;                |               |  |  |<br />     |  |  |  | begin                         |               |  |  |<br />     |  |  |  |    ...                        |               |  |  |<br />     |  |  |  | end T;                        |               |  |  |<br />     |  |  |  +-------------------------------+               |  |  |<br />     |  |  |    W: Float;                                     |  |  |<br />     |  |  | begin                                            |  |  |<br />     |  |  |    ...                                           |  |  |<br />     |  |  | end R;                                           |  |  |<br />     |  |  +--------------------------------------------------+  |  |<br />     |  |                 +-----------------------------------+  |  |<br />     |  |    procedure S  |  (Y: Integer) is                  |  |  |<br />     |  |  +--------------+                                   |  |  |<br />     |  |  | begin                                            |  |  |<br />     |  |  |   ...                                            |  |  |<br />     |  |  | end S;                                           |  |  |<br />     |  |  +--------------------------------------------------+  |  |<br />     |  | begin                                                  |  |<br />     |  |    ...                                                 |  |<br />     |  |    declare X: Integer; begin ... end;                  |  |<br />     |  |    ...                                                 |  |<br />     |  | end Q;                                                 |  |<br />     |  +--------------------------------------------------------+  |<br />     |    M: Integer;                                               |<br />     | begin                                                        |<br />     |    ...                                                       |<br />     | end P;                                                       |<br />     +--------------------------------------------------------------+<br /></pre>


<p>The general rule is that bindings are determined by
finding the "innermost" declaration.</p>


<p>Interestingly, not everything is obvious:</p>


<ul>

  <li>Where there are <em>holes</em> in the scope,
  can the outer bindings be used anyway? (Yes in C++, Ada,
  and Java &mdash; how?)</li>

  <li>Does the scope consist of a whole block or just
  from the declaration onward?  Actually there are
  four possibilities:
    
    <ol>

      <li>Scope is whole block</li>

      <li>Scope starts at beginning of declaration (like C)</li>

      <li>Scope starts only after the whole declaration is finished</li>

      <li>Scope starts after declaration is finished, but using occurrences
      of name are prohibited during declaration (like Ada)</li>

    
    </ol>

  </li>

  <li>What about redeclarations within a scope?  Three ways to handle:
    
    <ol>

      <li>Rejected?</li>

      <li>Retain old bindings, as in ML (this is a static approach)</li>

      <li>The new binding overwrites <strong>all</strong>
      previous uses (a dynamic approach)</li>

    
    </ol>

  </li>

</ul>


<p>Static scoping is implemented with static chains or displays.
Details in the Compiler Construction course.</p>


<h4>Modules</h4>


<p>Modules affect static scoping in interesting ways. Wait &mdash; what
are modules?  Modules are structures that</p>


<ul>

  <li>Provide a means to group related entities together
  into a single unit (encapsulation)</li>

  <li>Provide a way to protect some of its entities from
  outside access or modification (information hiding)</li>

  <li>Can usually be separately compiled (to allow development
  to proceed in parallel)</li>

  <li>Allow for selective import and export of its entities</li>

  <li>Give you the advantage of reducing namespace pollution
  since modules provide their own scope</li>

  <li>Help you detect runtime bugs &mdash; if you've grouped
  related things together, you usually know where to look
  if a bug pops up.</li>

</ul>


<p>In practice, modules are often used to define data abstractions
using information hiding to safeguard its internal state.</p>


<p>Modules are more powerful than the static local variables
of C, since modules <em>spread state among several subroutines,
not just one</em>.</p>


<pre class="code">module Dictionary {<br />    import capacity, String;<br />    export put, get, getSize;<br />    struct Entry {String key; String value;}<br />    Entry[] entries = new Entry[capacity];<br />    int size = 0;<br />    void put(String key, String value) {...}<br />    String get(String key) {...}<br />    int getSize() {return size;}<br />}<br /><br />// Clients will say things like<br />//     Dictionary.put("mega", "either 1000000 or 1048576");<br />//     print(Dictionary.getSize());<br /></pre>


<p>In this module</p>

<ul>

  <li>We have defined one type (Entry), two variables (entries
  and size) and three functions (put and get).</li>

  <li>The types and variables are <em>private</em> to the module
  because they are not exported.</li>

  <li>By making certain variables private, no outside code can
  corrupt the dictionary by whacking the size.</li>

  <li>The variables entries and size are <strong>global in lifetime</strong>
  but <strong>not global in scope</strong>.</li>

  <li>The two functions are also global in lifetime.</li>

  <li>Because the variables and functions are global, a linker will
  allocate each of them just once in the executable.  Therefore, if you
  try to link two copies of this module you will get a "Duplicate
  Symbol" error.</li>

</ul>


<p>So this module gives us only one dictionary.  How can we get
more?  Answer: export a dictionary type.</p>


<pre class="code">module DictionaryModule {<br />    import String;<br />    export Dictionary, put, get, getSize;<br />    struct Entry {String key; String value;}<br />    struct Dictionary(int capacity) {<br />        Entry[] entries = new Entry[capacity];<br />        int size = 0;<br />    }<br />    void put(Dictionary d, String key, String value) {...}<br />    String get(Dictionary, String key) {...}<br />    int getSize(Dictionary d) {return d.size;}<br />}<br /><br />// Clients will say things like<br />//     DictionaryModule.Dictionary d1, d2, d3;<br />//     Dictionary.put(d2, "mega", "either 1000000 or 1048576");<br />//     print(getSize(d3));<br /></pre>


<p>This is the <strong>module-as-manager</strong> style: you compile the
module only once, but you can declare many variables of the exported
type.</p>


<p>The next techical advance is to make the module itself
a type, rather than just a plain encapsulation device.
This is the <strong>module-as-type</strong> style.</p>


<pre class="code">module Dictionary {<br />    import ...<br />    export ...<br />    ...<br />}<br /><br />// Clients will say things like<br />//     Dictionary d1, d2, d3;<br />//     d2.put("mega", "either 1000000 or 1048576");<br />//     print(d3.getSize());<br /></pre>


<p>Some people define a <em>class</em> as a module type
that can participate in inheritance relationships.</p>


<h4>Open and Closed Scopes</h4>


<p>Nested scopes introduce even more questions.  Consider</p>


<pre class="code">subroutine f {<br />    int x, y, z;<br /><br />    subroutine g {<br />        int a, b, c;<br />        ...<br />    }<br /><br />    module m {<br />        import x;<br />        export j;<br />        int i, j, k;<br />        subroutine h {print k;}<br />        ...<br />    }<br /><br />    ....<br />}<br /></pre>


<p>In g, are x, y, and z automatically imported or not?  Are
a, b, and c automatically exported or not?  What about in m?</p>


<p>The usual rule is that nothing is ever automatically exported
from an inner scope, but for imports the rule is different:</p>

<ul>

  <li><strong>Open Scope</strong> &mdash; imports from enclosing scope are automatic.</li>

  <li><strong>Closed Scope</strong> &mdash; explicit import required.</li>

</ul>


<p>How some languages do things:</p>


<table class="centered">

  <tbody>
    <tr>
      <th>Language</th>
      <th>Subroutines</th>
      <th>Modules</th>
    </tr>

  <tr>

    <td>Modula</td>

    <td>optionally closed</td>

    <td>closed</td>

  </tr>

  <tr>

    <td>Modula 2, 3</td>

    <td>open</td>

    <td>closed</td>

  </tr>

  <tr>

    <td>Ada</td>

    <td>open</td>

    <td>open</td>

  </tr>

  <tr>

    <td>Euclid</td>

    <td>closed</td>

    <td>closed</td>

  </tr>

  <tr>

    <td>Turing</td>

    <td>optionally closed</td>

    <td>?</td>

  </tr>

  <tr>

    <td>Clu</td>

    <td>closed</td>

    <td>closed</td>

  </tr>

  </tbody>
</table>


<div class="exercise"><strong>Exercise</strong>:
Investigate and write an article on the scoping issues
involved in:
<ul>

  <li>"Opaque" import and export, as in Modula 2</li>

  <li>Ada's private and limited private types</li>

  <li>Generic modules (a.k.a. templates)</li>

  <li>Modules split into separate specification and body parts (as in Ada)</li>

  <li>Private and public parts of a package specification</li>

</ul>

</div>


<h3>Dynamic Scope</h3>


<p>With dynamic scoping, the current binding for a name is the
one <strong>most recently encountered during execution</strong>.
The following script prints 2, not 1:

</p>
<pre class="code">our $x = 1;<br /><br />sub f{<br />    print "$x\n";<br />}<br /><br />sub g {<br />    local $x = 2;<br />    f();<br />}<br /><br />g();<br />print "$x\n";<br /></pre>


<p class="centered"><img src="../../../image/dynamicscope.png" /></p>


<p>Dynamic scopes tend to require <strong>lots of runtime work</strong>:
type checking, binding resolution, argument checking, etc.</p>


<p>They are also prone to redeclaration problems.</p>


<div class="exercise"><strong>Exercise</strong>:
Explain this.</div>


<p>The principal argument in favor of dynamic scoping is
the way they allow subroutines to be customized by using
an "envioronment variable" style that allows selective
overriding of a default (more or less).  Scott's example:</p>


<pre class="code">our $print_base = 10;<br /><br />sub print_integer {<br />    ...<br />    # some code using $print_base<br />    ...<br />}<br /><br /># So generally we want to use 10, but say at one point<br /># we were in a hex mood.  We wrap the call in a block like this:<br />{<br />    local $print_base = 16;<br />    print_integer($n);<br />}<br /># At the end of the block the old value is essentially restored<br /></pre>


<h3>Managing Names</h3>


<p>In a statically scoped language, bindings are kept in
a symbol table at compile time.  You a free to throw away the
names at runtime, unless you want to run the code under
a good debugger.</p>


<p>In a dynamically scoped language, you need to keep
bindings at run time.  The common approaches are to use
association lists or a central reference table.</p>


<p>Here's an example we'll use to illustrate each approach.</p>


<pre class="code">int i;<br />int j;<br />sub p(int i) { ... }<br />sub q(int j) {int x; ... p(j); ...}<br />q();<br /></pre>


<p>Let's say main calls q, then q calls p.</p>


<h4>Association Lists</h4>


<p>The A-list works like this:</p>

<ul>

  <li>When entering a scope: push its bindings on the list.</li>

  <li>When leaving a scope: pop its bindings off the list.</li>

  <li>When looking up a name: traverse the list.</li>

</ul>


<p class="centered"><img src="../../../image/alist.png" /></p>


<p>Generally speaking, scope entry and exit is fast, lookup is slow.</p>


<div class="exercise"><strong>Exercise</strong>:
Really?  What exactly is the entry/exit time proportional to?
What exactly is the lookup time proportional to?
</div>


<h4>Central Reference Table</h4>


<p>The central reference table works like this:</p>

<ul>

  <li>When entering a scope: push an entity descriptor onto each chain
    corresponding to each name defined in the scope.</li>

  <li>When leaving a scope: pop the relevant entity descriptors.</li>

  <li>When looking up a name: do a constant-time hashtable lookup. (It's
    guaranteed to be &Theta;(1) because the correct entry
    is first on the list!)</li>

</ul>


<p class="centered"><img src="../../../image/crtable.png" /></p>


<p>Generally speaking, scope entry and exit is slow, lookup is
blazingly fast (assuming your hash function is cheap).</p>


<div class="exercise"><strong>Exercise</strong>:
Really?  What exactly is the entry/exit time proportional to?
</div>


<h3>Finding the Referencing Environment</h3>


<p>The referencing environment is the set of bindings active
at a given point in time.  While this seems easy to figure out,
it's complicated by two things: masking and the passing
of subroutines.</p>


<h4>Masking Declarations</h4>


<p>Some languages let you mask earlier declarations in the
same scope:</p>


<pre class="code">    # Perl                          (* ML *)<br /><br />    my $x = 3;                      val x = 3;<br />    sub f {return $x + 5;}          fun f() = x + 5;<br />    my $x = 2;                      val x = 2;<br />    print f(), "\n";                f();<br /></pre>


<p>Both of these programs print 8:</p>


<p class="centered"><img src="../../../image/mask.png" /></p>


<div class="exercise"><strong>Exercise</strong>:
Find a language in which the direct translation of the
code about would cause 7 to be printed.  Write the program.
</div>


<h4>Subroutines as Arguments</h4>


<p>At first glance, passing subroutines as arguments doesn't
appear to raise any scoping problems:</p>


<pre class="code">fun twice f x = f(f(x));<br />fun square x = x * x;<br />fun addSix x = x + 6;<br />twice square 5;<br />twice addSix 8;<br />twice (fn x =&gt; x / 2.0) 1.0;<br />twice (fn x =&gt; x ^ "ee");<br /></pre>


<pre class="code">typedef int fun(int);<br />int square(int x) {return x * x;}<br />int addSix(int x) {return x + 6;}<br />int twice(fun f, int x) {return f(f(x));}<br />int main() {<br />    printf("%d\n", twice(square, 5));<br />    printf("%d\n", twice(addSix, 8));<br />    return 0;<br />}<br /></pre>


<pre class="code">sub twice {<br />    my ($f, $x) = @_;<br />    return &amp;$f(&amp;$f(x));   # or $f-&gt;$f-&gt;(x)<br />}<br />sub square {$_[0] * $_[0];}<br />sub addSix {$_[0] + 6;}<br />print twice(\&amp;square, 5), "\n";<br />print twice(\&amp;addSix, 8), "\n";<br /></pre>


<pre class="code">function twice (f, x) {return f(f(x));}<br />function square(x) {return x * x;}<br />function addSix(x) {return x + 6;}<br />twice(square, 5);<br />twice(addSix, 8);<br /></pre>


<pre class="code">with Ada.Text_IO, Ada.Integer_Text_IO;<br />use Ada.Text_IO, Ada.Integer_Text_IO;<br /><br />procedure Twice_Demo is<br />  type Fun is access function(X: Integer) return Integer;<br /><br />  function Twice(F: Fun; X: Integer) return Integer is<br />  begin<br />    return F.all(F.all(X));<br />  end Twice;<br /><br />  function Square(X: Integer) return Integer is<br />  begin<br />    return X * X;<br />  end Square;<br /><br />  function Add_Six(X: Integer) return Integer is<br />  begin<br />    return X + 6;<br />  end Add_Six;<br /><br />begin<br />  Put(Twice(Square'Access, 5));<br />  New_Line;<br />  Put(Twice(Add_Six'Access, 8));<br />  New_Line;<br />end Twice_Demo;<br /></pre>


<p>However, what happens when you pass a subroutine g, that is nested
within another subroutine f, in which g makes reference to entities
declared within f?</p>


<h4>Deep and Shallow Binding</h4>


<p>Consider</p>


<pre class="code">function a(i, p) {<br />    function b() {document.write(i);}<br />    if (i &gt; 1) p(); else a(2, b);<br />}<br />function c() {}<br />a(1, c);<br /></pre>


<p>Does this output 1 or 2?  In other words, when B is executed
do we use its environment at the time it was <strong>passed</strong>
or the new environment into which it was <strong>called?</strong>

</p>
<ul>

  <li>Deep Binding &mdash; use bindings at time of passign</li>

  <li>Shallow Binding &mdash; use bindings at time of call</li>

</ul>


<p>With deep binding, the example above would display 1, since
the first time b is passed we are passing in a subroutine whose
body sees i as 1.</p>


<p class="centered"><img src="images/deepshallow.png" /></p>


<p>Try the same example in different languages...</p>


<pre class="code">sub a {<br />    my ($i, $p) = @_;<br />    sub b {print "$i\n";}<br />    if ($i &gt; 1) {<br />        &amp;$p();<br />    } else {<br />        &amp;a(2, \&amp;b);<br />    }<br />}<br />sub c {}<br />&amp;a(1, \&amp;c);<br /></pre>


<pre class="code">fun a(i: int, p: unit-&gt;unit) =<br />    let<br />        fun b() = print(if i=1 then "Deep" else "Shallow")<br />    in<br />        if i &gt; 1 then p() else a(2, b)<br />    end;<br />fun c() = ();<br />a(1,c);<br /></pre>


<div class="exercise"><strong>Exercise</strong>:
Write this example in Lisp, Python, and Ada.</div>


<div class="exercise"><strong>Exercise</strong>:
Get the Perl example to work using "local" instead of "my"
for $i and $p.  Did you notice a change from deep to shallow?</div>


<h4>Dangling References</h4>


<p>In this crazy example, a reference to a subroutine outlives
the execution of the scope in which it was declared:</p>


<pre class="code">var x = 5;<br />function a(i) {<br />    var y = 3;<br />    function b() {document.write(i + y + x);}<br />    y = 10;<br />    i = 2;<br />    return b;<br />}<br />p = a(4);<br />p();<br /></pre>


<p>But it's okay, since JavaScript, like Perl and ML, retain
call frames (I guess we can't call them stack frames!)
that are still being hung onto by active subroutines.
The more static languages would never let you get away with this.
How do they prevent it?</p>


<ul>

  <li><strong>C, C++</strong> &mdash;
  This issue never even comes up, since these languages don't
  allow nested subroutines!</li>

  <li><strong>Modula-2</strong> &mdash;
  You can't even write the code above because you can't
  make a reference to any subroutine except a top-level one.</li>

  <li><strong>Modula-3</strong> &mdash;
  You can pass any subroutine, but you can't return, or store in
  a variable anything other than a reference to a top-level one.</li>

  <li><strong>Ada</strong> &mdash;
  The scope in which a subroutine is declared must be at least
  as wide as the declared return type.  So you can't declare a return
  type outside of the scope in which the subprogram is declared,
  stifling any attempt to send a subprogram out of its scope.</li>

</ul>


<div class="exercise"><strong>Exercise</strong>:
Rewrite the crazy example in Perl and ML and check the
output value against the value written by the JavaScript fragment.
Then write the equivalent code in Ada, and make a note of the
compile-time error.</div>





  </div>

  
</body>
</html>
