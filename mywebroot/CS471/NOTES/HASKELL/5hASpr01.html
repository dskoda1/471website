<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html><head>

            
  
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

            
  
  <meta name="Author" content="Eileen Head and Les Lander">

            
  
  <meta name="GENERATOR" content="Mozilla/4.73 [en] (Win98; U) [Netscape]">

  
  <title>Doing "Loops" Using Infinite Lists in Haskell</title></head>

<body>

   <h3> 
<center>   
<h4> Haskell 7</h4>

 </center>

 </h3><h4> 
<center> 
<div align="left">Purpose:</div>

 


 </center>

 </h4>

          
<ul>

   <li> To examine the encapsulation power of infinite data structure.</li>

    <li> HOF, iterate and it use in computing a sequence of approximations.</li>

    <li> How iterate and infinite data structures can play the role of loops.</li>

     
</ul>

   <a href="http://bingweb.binghamton.edu/%7Ehead/CS471/CODE/Scripts/Infinite.lhs">
 Infinite.lhs</a> has codes presented below.&nbsp;   
<hr width="100%">   
<h3> List comprehension and HOF, iterate</h3>

      
<ul>

   <li> Using list comprehension notation and "^" define</li>

          
  
  <ul>

      <b><tt>powersOfTwo :: [Integer]</tt></b> <br>

      <tt>?</tt>      
  
  </ul>

    <li> Generalize to a function that generates all the powers of any number.</li>

          
  
  <ul>

      <b><tt>powersOf :: Integer -&gt; [Integer]</tt></b> <br>

      <tt>?</tt>      
  
  </ul>

    <li> Assume "^" is performed by repeated multiplications, define a faster
 version that computes each element from the preceding one.&nbsp; (See&nbsp;
     <a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/4hF02.html#Fib">
 fast version of computing Fibonacci sequence</a> )</li>

          
  
  <ul>

      <b><tt>powersOfFast :: Integer -&gt; [Integer]</tt></b> <br>

      <tt>?</tt>      
  
  </ul>

    <li> This is a commonly occurring pattern, so we generalize it to make
 a higher-order-function:</li>

          
  
  <ul>

  &nbsp; <br>

      <b>&gt;<tt> iterate :: (a -&gt; a) -&gt; a -&gt; [a]</tt></b> <br>

      <b><tt>&gt; iterate f x = x : iterate f (f x)</tt></b>      
  
  </ul>

    <li> What is the result of</li>

    <br>

  &nbsp;       
  
  <ul>

      <b><tt>...&gt; iterate (\x -&gt; x + 1) 1</tt></b> <br>

      <tt>?</tt>      
  
  </ul>

    <li> Rewrite <tt>powerOf x</tt> using <tt>iterate.</tt></li>

    <br>

    <tt>?</tt>  
</ul>

      
<h3>    
<hr width="100%">Newton's Method for Computing the Square Roots</h3>

      
<ul>

   <li> A widely used algorithm for computing&nbsp; <b>sqrt</b> <i>N</i>
is  Newton's method, which computes a sequence of ever improving approximations:</li>

          
  
  <ul>

      <b><tt><font size="+1">a<sub><i>i</i>+1 </sub>= (a<sub><i>i</i> </sub>
 + (<i>N / </i>a<i><sub>i</sub></i>) )/ 2</font></tt></b>           
    
    <ul>

                 
      
      <ul>

                     
        
        <ul>

            <font size="+1">as <i>i</i> -&gt; infinity and <tt>a<i><sub>i</sub></i><sup>
 2</sup>-&gt;</tt><b><i>N</i></b></font>                  
        
        </ul>

                 
      
      </ul>

             
    
    </ul>

         
  
  </ul>

    <li> In Haskell, the sequence of approximations cn be represented by
an  infinite list.</li>

    <li> A Haskell function which computes an approximation from the preceding
 approximation:</li>

    <br>

  &nbsp;       
  
  <ul>

      <b><tt>&gt; next :: Double -&gt; Double -&gt; Double</tt></b> <br>

      <b><tt>&gt; next n a = (a + n/a) /2</tt></b>      
  
  </ul>

    <li> Call the initial approximation <i><tt>g</tt> </i>; then the sequence
 of approximations is the list:</li>

          
  
  <ul>

  &nbsp; <br>

      <b><tt>iterate (next n) g</tt></b>           
    
    <ul>

  &nbsp;          
    
    </ul>

         
  
  </ul>

    <li> Now we need a function that traverses the list with a parameter, 
eps, that determines closeness of the approximation:</li>

          
  
  <ul>

  &nbsp; <br>

      <b><tt>&gt; within ::&nbsp; Double -&gt; [Double] -&gt; Double</tt></b>
  <br>

      <b><tt>&gt; within eps (a:b:bs)</tt></b> <br>

      <b><tt>&gt;&nbsp;&nbsp;&nbsp;&nbsp; | abs(a-b) &lt;= eps = b</tt></b>
  <br>

      <b><tt>&gt;&nbsp;&nbsp;&nbsp;&nbsp; | otherwise&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
 = within eps (b:bs)</tt></b>           
    
    <ul>

  &nbsp;          
    
    </ul>

         
  
  </ul>

    <li> <b>Therefore</b></li>

          
  
  <ul>

  &nbsp; <br>

      <b><tt>&gt; sqrt eps n = within eps (iterate (next n) 1.0)</tt></b> 
          
    
    <p> </p>

           
    
    <hr align="left" width="70%">      
  
  </ul>

    <li> The problem with using<b> <tt>within </tt></b>to terminate the search
 of the list<tt>:</tt></li>

          
  
  <ul>

   <li> When N is very small, there may be a large error in the answer.</li>

    <li> When N is very large, the search may not terminate.</li>

         
  
  </ul>

    <li> When N is expected to cover a wide range, <tt>relative </tt>is a 
preferred  alternative to <tt>within:</tt></li>

          
  
  <ul>

  &nbsp; <br>

      <b><tt>&gt; relative :: Double -&gt; [Double] -&gt; Double</tt></b> 
    <br>

      <b><tt>&gt; relative eps (a:b:bs)</tt></b> <br>

      <b><tt>&gt;&nbsp;&nbsp;&nbsp;&nbsp; | abs(a/b - 1.0) &lt;= eps&nbsp;&nbsp;&nbsp;&nbsp; 
 = b</tt></b> <br>

      <b><tt>&gt;&nbsp;&nbsp;&nbsp;&nbsp; |
otherwise&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= relative eps (b:bs)</tt></b>      
  
  </ul>

          
  
  <p><br>

    <b><tt>Therefore</tt></b> </p>

       
  
  <ul>

  &nbsp; <br>

      <b><tt>&gt; sqrt eps n = relative eps (iterate (next n) 1.0)</tt></b>
      
  
  </ul>

    <li> Because relative uses ( / ), whereas within uses (-) relative is 
more expensive.</li>

    <li> Notices only the "termination" functions needed to be changed and
 not the list of approximations.</li>

    <li> Moveover, other approximation lists can apply either <b><tt>relative</tt></b>
  or <b><tt>within </tt></b>to terminate the traversal of the list!</li>

    <br>

         
  
  <hr align="left" width="70%"> <li> Conclusion:</li>

          
  
  <ul>

   <li> Infinite lists play a role like that of loops and&nbsp;</li>

       
  
  </ul>

   
</ul>

   
<blockquote>      
  
  <blockquote>          
    
    <ul>

        <li>functions applied to them serve as termination conditions.</li>

           
    
    </ul>

    </blockquote>

  </blockquote>

   
<ul>

       
  
  <ul>

      <li> This technique allows the "enabling loop" and its "termination 
condition"  to be defined separately.</li>

      <li>This illustrates that infinite lists provide a new way to modularize
 functional programs.</li>

         
  
  </ul>

     
</ul>

      
<hr noshade="noshade" width="100%">   
<center>  
<table bgcolor="#fffff0" border="1" cellpadding="0" cellspacing="0">

   <tbody>

      <tr>

   <td>&nbsp;<a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/5HOFhF02.html">
 previous</a></td>

    <td><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/6hSpr01.html">
 &nbsp;next&nbsp;</a></td>

   </tr>

         
  
  </tbody>  
</table>

  </center>

      
<hr align="left" noshade="noshade" width="100%">  <br>

 <br>

</body></html>