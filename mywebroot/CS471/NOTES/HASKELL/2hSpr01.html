<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>

  
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

  
  <meta name="Author" content="Eileen Head and Les Lander">

  
  <meta name="GENERATOR" content="Mozilla/4.78 [en] (Windows NT 5.0; U) [Netscape]">

  
  <title>Haskell: 1</title>
</head>


<body>

&nbsp;
<center>
<table bgcolor="#fffff0" border="1" cellpadding="0" cellspacing="0">

  <tbody>

    <tr>

      <td><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/1hSpr01.html">&nbsp;previous</a></td>

      <td><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/3hF02.html">&nbsp;next&nbsp;</a></td>

    </tr>

  
  </tbody>
</table>

</center>

<center>
<h3> Haskell 1</h3>

</center>

<center>
<h4> &copy; Eileen Head, Leslie C. Lander, 2000</h4>

</center>

<h4> Propose:&nbsp; To learn the functional style of programming.&nbsp;<br>

Records, lists, user types, function types and local definitions will
be discussed.</h4>

<a href="http://bingweb.binghamton.edu/%7Ehead/CS471/CODE/Scripts/Notes1.lhs">Notes1.lhs</a>
has codes presented in these notes as well as other examples.
<p> </p>

<hr width="100%">
<h3> Functional Programming and HUGS</h3>

<ul>

  <li> Slides in HTML format: <a href="http://bingweb.binghamton.edu/%7Ehead">http://bingweb.binghamton.edu/~head</a></li>

  <li> To a large extent the notes are based on the information in the
excellent text: Simon Thompson, <i>Haskell: The Craft of Functional
Programming</i>,  2nd edition Addison-Wesley Longman, 1999&hellip;</li>

  <li> &hellip;and A Gentle Introduction to Haskell, Version 98, available
on-line: <a href="http://haskell.org/tutorial/">http://haskell.org/tutorial/</a></li>

  <li> The slides were developed in collaboration with Prof. Les Lander.</li>

  <li> Haskell was the first name of H. Curry, a logician in the 30's
and  40's. He will be mentioned again.</li>

</ul>

<h3>
<hr size="1" width="100%">Mathematical functions</h3>

<ul>

  <li> A function <i>f</i> is a rule that takes an input value <i>x</i>
and returns a value <i>f</i> (<i>x</i>) or <i>f</i>&nbsp; <i>x</i></li>

  <li> The inputs <i>x</i> belong to a set <i>X</i> (called the domain
of <i>f</i> ).</li>

  <li> The values <i>y</i> = <i>f</i> (<i>x</i>) belong to a set <i>Y</i>
(called the range of <i>f</i> ).</li>

  <li> We write <i>f</i> : <i>X</i> -&gt; <i>Y</i>.</li>

  
  <h3>
  
  <hr size="1" width="100%"></h3>

</ul>

<h3> Examples</h3>

<ul>

  <li> Functional programming refers to writing a program as a set of
functions</li>

  <li> Functions are defined in the script</li>

  <li> "<b>=</b>" means defined as</li>

  
  <pre>&gt;&nbsp;&nbsp; sq x = x^2<br>&gt;&nbsp;&nbsp; cube x = x *(sq x)</pre>

  <li> Haskell determines the type of the functions:</li>

  <li> "<b><tt>::</tt></b>" means <b><i>has type</i></b></li>

  
  <pre>...&gt; :t sq<br>sq :: Num a =&gt; a -&gt; a</pre>

  
  <pre><hr size="1" width="100%"></pre>

</ul>

<h3> Specifying types</h3>

<ul>

  <li> You can direct Haskell to attach the types the way you want them</li>

  <li> If you want "py" to be a Float rather than the Double type
determined  by HUGS, insert the type in the script</li>

  
  <pre>&gt;&nbsp;&nbsp; py :: Float<br>&gt;&nbsp;&nbsp; py = 3.14159</pre>

  <li> Constraining the function "sq"</li>

  
  <pre>&gt;&nbsp;&nbsp; sq :: Int -&gt; Int<br>&gt;&nbsp;&nbsp; sq x = x^2</pre>

  
  <h3>
  
  <hr size="1" width="100%"></h3>

</ul>

<h3> Pattern Matching</h3>

<ul>

  <li> Function with alternatives: (using pattern matching)</li>

  
  <pre>&gt;&nbsp;&nbsp; factorialP :: Int -&gt; Int&nbsp;<br>&gt;&nbsp;&nbsp; factorialP 0 = 1&nbsp;<br>&gt;&nbsp;&nbsp; factorialP x = x * factorialP(x - 1)</pre>

  <li> Can not constraint type to only positive Int.</li>

  <li> What happens</li>

  
  <ul>

    <tt>...&gt; factorialP (-3)</tt> <br>

    
    <hr noshade="noshade" size="1" width="70%">
  
  </ul>

</ul>

<h3> Guards</h3>

<ul>

  <li> Functions with alternatives: (using guards)</li>

  
  <pre>&gt;&nbsp;&nbsp; factorial :: Int -&gt; Int&nbsp;<br>&gt;&nbsp;&nbsp; factorial x<br>&gt;&nbsp;&nbsp;&nbsp;&nbsp; | x &lt; 0&nbsp;&nbsp;&nbsp;&nbsp; = error "neg x"<br>&gt;&nbsp;&nbsp;&nbsp;&nbsp; | x == 0&nbsp;&nbsp;&nbsp; = 1<br>&gt;&nbsp;&nbsp;&nbsp;&nbsp; | otherwise = x * factorial(x - 1)</pre>

  <li> Use the type information to avoid defining a factorial function
for decimals</li>

  <br>

  
  <hr size="1" width="100%">
</ul>

<h3> Haskell picks the most general type</h3>

<ul>

  <li> If we only wrote:</li>

  
  <pre>&gt;&nbsp;&nbsp; fact1 x<br>&gt;&nbsp;&nbsp;&nbsp;&nbsp; | x &lt; 0&nbsp;&nbsp;&nbsp;&nbsp; = error "neg x"<br>&gt;&nbsp;&nbsp;&nbsp;&nbsp; | x == 0&nbsp;&nbsp;&nbsp; = 1<br>&gt;&nbsp;&nbsp;&nbsp;&nbsp; | otherwise = x*fact1(x-1)</pre>

  <li> We would find:</li>

  
  <pre>...&gt; :t fact1<br>fact1::(Ord a,Num a) =&gt; a-&gt;a</pre>

  <li> the input must be in the intersection of classes Ord and Num</li>

  <br>

  
  <hr size="1" width="100%">
</ul>

<h3> Problems with Int</h3>

<ul>

  <li> We get:</li>

  
  <pre>...&gt; fact1 3.7</pre>

  
  <pre>Program error: neg x</pre>

  
  <pre>...&gt; factorial 3.7<br>ERROR: Illegal Haskell 98 class constraint in inferred type<br>*** Expression : factorial 3.7<br>*** Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Fractional Int =&gt; Int</pre>

  <li> Next note:</li>

  
  <pre>...&gt; factorial 13<br>1932053504</pre>

  <li> When it should be 6227020800 (= 1932053504 + 2 * 2<sup>32</sup>)</li>

</ul>

<h3> Large numbers</h3>

<ul>

  <li> Functional languages like Lisp have traditionally been good
calculators:</li>

  
  <pre>&gt;&nbsp;&nbsp; factorial1 :: Integer -&gt; Integer<br>&gt;&nbsp;&nbsp; factorial1 n<br>&gt;&nbsp;&nbsp;&nbsp;&nbsp; | n &lt; 0&nbsp;&nbsp;&nbsp;&nbsp; = error "neg n"<br>&gt;&nbsp;&nbsp;&nbsp;&nbsp; | n == 0&nbsp;&nbsp;&nbsp; = 1<br>&gt;&nbsp;&nbsp;&nbsp;&nbsp; | otherwise = n * factorial1 (n - 1)</pre>

  <li> Integer expands with magnitude</li>

</ul>

<h3> Factorials of 50 and 500</h3>

<ul>

  <li> Load Haskell and load a script containing the definitions of
factorial.  Then try "<tt>factorial1 50</tt>" and "<tt>factorial1 500</tt>"</li>

</ul>

<h3> Part of factorial of 3500</h3>

<ul>

  <li> Continue by trying "<tt>factorial1 3500</tt>." You may have to
wait  quite a long time for the answer.</li>

</ul>

<h3>
<hr size="1" width="100%"></h3>

<h3> Simple syntax</h3>

<ul>

  <li> Notice how writing a Haskell function is like doing mathematics:</li>

  <li> Define the factorial function f as (N<sub>0</sub> denotes the
natural  numbers):</li>

  
  <pre>f : N<sub>0</sub> -&gt; N<sub>0<br></sub>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n = 0 or 1<br>f(n) = &lt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \&nbsp; n*f(n-1)&nbsp; otherwise</pre>

  <li> The biggest difference is that programmers use long names for
their  functions!</li>

</ul>

<h3> Limitation of expressively of types</h3>

<ul>

  <li> We have the difficulty that we cannot exclude negative numbers so
easily</li>

  
  <pre>&gt;&nbsp;&nbsp; factorial1::Integer -&gt; Integer<br>&gt;&nbsp;&nbsp; factorial1 n<br>&gt;&nbsp;&nbsp;&nbsp;&nbsp; | n &lt; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = error "neg n"<br>&gt;&nbsp;&nbsp;&nbsp;&nbsp; | (n==0) || (n==1) = 1<br>&gt;&nbsp;&nbsp;&nbsp;&nbsp; | otherwise&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = n * factorial1(n-1)</pre>

</ul>

<h3> Type system</h3>

<ul>

  <li> Haskell&rsquo;s type system has unusual features and is quite rich</li>

  <li> Haskell is statically typed</li>

  <li> Haskell is a purely functional language</li>

  <li> ALL computations are done via evaluation of expressions to yield
values</li>

</ul>

<h3> Types and values</h3>

<ul>

  <li> Every value has a type</li>

  <li> Functions are values</li>

  <li> Values are first class, that is,</li>

  
  <ul>

    <li> they can be passed as arguments to functions</li>

    <li> returned</li>

  
  </ul>

</ul>

<h3> Predefined types</h3>

<ul>

  <li> Some basic atomic values and types:</li>

  <li> Predefined data types</li>

  
  <pre>Int, Bool, Char, Float, ...<br>also Double, Integer</pre>

  
  <pre>read "::" as "has type"<br>5 :: Int<br>5.0 :: Float</pre>

  <li> Float &amp; Double need a decimal point or an exponent: 5.0</li>

  
  <pre>'a' :: Char</pre>

  <li> Char: the character type, <tt>'a'</tt>,<tt> 'P'</tt>, <tt>'&lt;'</tt>,
etc. ASCII codes can be used: <tt>'\65'</tt>.&nbsp; Version 1.4 has
started  to use Unicode.</li>

  
  <pre>"aba" :: String</pre>

  <li> Later we use keyword <b><i><font color="#cc0000">type</font></i></b>
to define <font color="#990000">synonyms</font>.</li>

  
  <ul>

    <li> A new type is not defined but a new name is given to an
existing type.  (Like typedef in C)</li>

  
  </ul>

</ul>

<h3> Structured types</h3>

<ul>

  <li> Structured values</li>

  
  <ul>

    <li> <u>Lis</u>t <u>P</u>rocessing is what gave LISP its name and
strength:  Lisp allows structures of nested lists and each element of
the list or nested  list can have a different type</li>

    <li> Non-homogeneous lists have proved to be very flexible
structures,  supporting artificial intelligence and other sophisticated
applications</li>

  
  </ul>

</ul>

<h3> Lists</h3>

<ul>

  <li> Haskell lists are NOT like Lisp lists, they have to be homogeneous</li>

  <li> They are dynamic (can change length during execution)</li>

  <li> homogeneous list of Ints</li>

  
  <pre>[1,2,3] :: [Int]<br>(actually ...&gt;:t [1,2,3] gives [1,2,3]::Num a =&gt; [a])</pre>

  <li> homogeneous list of Bool</li>

  
  <pre>[True,False,False]::[Bool]</pre>

</ul>

<h3> Strings</h3>

<ul>

  <li> The literal syntax of string&nbsp; is a list of chars.&nbsp;
Prelude  defines string</li>

  
  <pre>type String = [Char]</pre>

  <li> "aba" is shorthand for ['a','b','a']</li>

  <li> We will visit lists many times.</li>

  <li> By the way, this cursor indicates Haskell is garbage
collecting&nbsp;<img src="garbage.jpg" align="middle" border="2" height="38" width="31"> </li>

</ul>

<h3> List operations</h3>

<ul>

  <li> For now, the important operations:</li>

  
  <pre>1:[2,3,4] = [1,2,3,4]<br>4:[] = [4]<br>head [1,2,3,4] = 1<br>tail [1,2,3,4] = [2,3,4]<br>init [1,2,3,4] = [1,2,3]<br>last [1,2,3,4] = 4</pre>

  <li> What is the type of</li>

  <br>

  <tt>:t (:)</tt>
  
  <dl>

    
    <dl>

      <li> <tt>:t :</tt></li>

      <br>

will produce an error because ":" is an infix operator <br>

To convert it to a prefix operator use "( )"
    
    </dl>

  
  </dl>

  
  <p><br>

  <tt>:t head</tt> </p>

  
  <ul>

?
  
  </ul>

  <tt>:t init</tt>
  
  <ul>

    <tt>?</tt>
  
  </ul>

  <li> Concatenation (appending) two lists</li>

  <br>

  <tt>[1,2,3] ++ [10,11,12] = [1,2,3,10,11,12]</tt>
  
  <p>Definition: <br>

  <a name="(++)"></a><tt>(++) :: [a]-&gt;[a]-&gt;[a]</tt> <br>

  <tt>[] ++ ys = ys</tt> <br>

  <tt>(x:xs) ++ ys = x:(xs ++ ys)</tt> <br>

&nbsp; </p>

  
  <ul>

    
    <dl>

      <li> What if we recurs on ys instead of xs?</li>

      <li> Notice that (++) is associative operation.</li>

    
    </dl>

  
  </ul>

</ul>

<h3> Tuples</h3>

<ul>

  <li> There are non-homogeneous linear structures like the &ldquo;struct&rdquo; of
C or the &ldquo;record&rdquo; of Pascal and Ada:</li>

  <li> They are called &ldquo;tuples&rdquo;</li>

  
  <pre>('x', 99) :: (Char, Int)<br>type Person = (String,Int)</pre>

  <li> Compare</li>

  
  <pre>struct person {<br>&nbsp;&nbsp;&nbsp; char * name;<br>&nbsp;&nbsp;&nbsp; int i;<br>}</pre>

  <li> Another example:</li>

  
  <pre>type Zip_code = (String, Int)</pre>

  <li> First letter must be capital letter, you cannot use "zip_code" or
 "Zip-code"</li>

  
  <pre>vestal :: Zip_code<br>vestal = ("NY", 13850)<br>fst vestal <i>returns</i> NY<br>snd vestal <i>returns</i> 13850</pre>

  <li> <b><i><font color="#990000">type</font></i> </b>just creates a
synonym  and not another data type</li>

  <br>

  
  <hr size="1" width="100%">
</ul>

<h3> User-defined types</h3>

<ul>

  <li> User Defined Types:&nbsp; type constructors</li>

  <li> union type:</li>

  
  <pre><b><font color="#990000">data</font></b> Color = Red | Blue | Black</pre>

  <li> Red, Blue and Black are <b><i>data constructors</i></b> of the
type  Color</li>

  <li> Example of a predefined type</li>

  
  <pre>data Bool = True | False</pre>

</ul>

<h3> Product types</h3>

<ul>

  <li> Product type is an alternative to tuples</li>

  
  <pre>type Name = String<br>type Age = Int<br>data People = Person Name Age<br>x = Person "John" 25</pre>

  <li> A function to show x</li>

  
  <pre>showPerson :: People -&gt; String&nbsp;<br>showPerson (Person n a) = n ++ " aged " ++ show a</pre>

  <li> Keyword <i>type</i> creates a synonym</li>

  <li> Keyword <i>data</i> is a constructor for a NEW data type.</li>

</ul>

<h3> Polymorphic data types</h3>

Point
<ul>

  
  <pre>data Point a = Pt a a</pre>

  <li> This is a polymorphic data type: it works for any type &ldquo;a&rdquo;</li>

  
  <pre>Pt 2.0 3.0 :: Point Float<br>Pt 'a' 'b' :: Point Char<br>Pt True False :: Point Bool</pre>

  <li> A function to extract the individual values would be:</li>

  
  <pre>firstCoord :: Point a -&gt; a<br>firstCoord (Pt m n) = m</pre>

  
  <dl>

    <li> <b><i>Point </i></b>is a first order data type</li>

    <li> <b><i>Point</i></b> by itself is a type</li>

    <li> There are no values in Haskell that have this type.</li>

  
  </dl>

</ul>

<a name="Tree"></a>Tree
<ul>

  <tt>data Tree a = Leaf a | Branch (Tree a) (Tree a)</tt> <br>

&nbsp; <li> This is a recursive polymorphic data type:</li>

  
  <ul>

    <li> recursive because <tt>Tree</tt> is defined in terms of itself</li>

    <li> it works for any type &ldquo;a&rdquo;</li>

    <br>

&nbsp;
  
  </ul>

  <li> A function to compute the size&nbsp; (i.e. the number of leaves)</li>

  
  <ul>

&nbsp;
  
  </ul>

  <tt>treeSize :: Tree a -&gt; Integer</tt> <br>

  <tt>treeSize (Leaf x) = 1</tt> <br>

  <tt>treeSize (Branch t1 t2) = treeSize t1 + treeSize t2</tt>
  
  <ul>

&nbsp;
  
  </ul>

  <li> Example of a <i>Tree Int</i></li>

  <br>

  <tt>tree&nbsp; =&nbsp; Branch (Leaf 3) (Branch (Leaf 6) (Leaf 9))</tt>
</ul>

<h3>
<hr noshade="noshade" size="3" width="100%">Function types</h3>

<ul>

  <li> Functions are values and have a type</li>

  
  <pre>\x -&gt; x+1,</pre>

  <li> This is a lambda expression with type:<br>

    <tt>Num a =&gt; a -&gt; a</tt></li>

  <li>Notice functions can be anonymous (i.e. no names)<br>

  </li>

  <li> Functions are normally defined by an equation or series of
equations</li>

  
  <pre>inc n = n + 1&nbsp;<br>(alternatively: inc = \n -&gt; n + 1)</pre>

  <li> The type signature declaration used to declare the explicit
type&nbsp;</li>

  
  <pre>&gt; inc :: Int -&gt; Int</pre>

</ul>

<h4> Type inference&nbsp;&nbsp;</h4>

<ul>

  <li>If the type is not explicitly declare then the type system can
infer the correct most general type.<tt><br>

inc :: Num a =&gt; a -&gt; a</tt><br>

  </li>

</ul>

<ul>

  <li> In the tutorial, Hudak et al. use <i>e</i><sub>1</sub> =&gt; <i>e</i><sub>2</sub>
to indicate that <i>e</i><sub>1</sub> <i>reduces to</i> <i>e</i><sub>2</sub>.
My notes use the symbol "~&gt;"</li>

  
  <ul>

    
    <pre>inc ( inc 3 ) ~&gt; 5<br></pre>

  
  </ul>

  <li>Notice we need the "()" , inc inc 3 will give an error <br>

  </li>

</ul>

<hr noshade="noshade" size="2" width="80%"><br>

<h3>Function composition <br>

</h3>

<ul>

  <li>A type of "polymorphism" that has nothing to do with data
structures  is the function <i>composition</i>.&nbsp;</li>

  <li>Haskell the infix operator (.) as follows:</li>

  
  <ul>

    <tt><br>

(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</tt> <br>

    <tt>(f.g)x = f(g x)<br>

    <br>

    </tt>
  
  </ul>

  <li><tt>Composition is a way to GLUE functions together!</tt></li>

  
  <p><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/12composition.gif"><img src="12composition.gif" alt="f composed with g" style="border: 0px solid ; height: 98px; width: 245px;" title=""> </a> </p>

  
  <pre>...&gt; (inc . inc) 3</pre>

  
  <pre>5</pre>

  <li> Or in the script (like math f o g) :</li>

  
  <pre>inc2 = inc . inc</pre>

  
  <ul>

    <li> What is the type of inc and inc2?</li>

  
  </ul>

</ul>

<h3>
<hr size="1" width="100%">Currying</h3>

<ul>

  <li> In the development of functional notations as a model of
computation,  it has been important to concentrate on functions of one
variable</li>

  <li> Curry did considerable work in the area. The idea is often used
today in mathematics.</li>

</ul>

<h3> Currying a function</h3>

<ul>

  <li> A function</li>

  
  <pre><i>f</i> : <i>X</i> x <i>Y</i> -&gt; <i>Z</i></pre>

  <li> can be thought of as a function</li>

  
  <pre><i>f<sub>c</sub></i>:<i>X</i> -&gt; (<i>Y</i> -&gt; <i>Z</i>)</pre>

  <li> where (<i>Y</i> -&gt; <i>Z</i>) is the set of functions from <i>Y</i>
to <i>Z<br>

    <br>

    </i></li>

  <li>It is not a difficult idea</li>

  
  <ul>

    <li>(+) 3 5<i> </i>~&gt; (3 +) 5 ~&gt; 8</li>

    <li>(3 +) is a function that adds 3 to any value</li>

    <li>vs + (3,5) ~&gt; 5</li>

    <li>must have both values&nbsp; <br>

    </li>

  
  </ul>

</ul>

<h3> Example:</h3>

<ul>

  <li> I want a function "extract" that is given two integers "min" and
"max" and a list of integers "list" as input</li>

  <li> The result of the function must be a list of all those numbers in
 "list" that do not lie between "min" and "max" (inclusive), e.g.</li>

  
  <pre>...&gt; extract&nbsp; 3&nbsp; 5&nbsp; [1,5,4,6,3,2,1]&nbsp;<br>[1,6,2,1]</pre>

  <li> Consider</li>

  
  <pre>&gt; extract::Int-&gt;Int-&gt;[Int]-&gt;[Int]<br>&gt; extract min max list<br>&gt;&nbsp;&nbsp;&nbsp;&nbsp; |list == [] = []<br>&gt;&nbsp;&nbsp;&nbsp;&nbsp; |otherwise&nbsp; = extractNonEmpty min max list<br>&gt;&nbsp;&nbsp;&nbsp;&nbsp; where<br>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; extractNonEmpty min max (a:x)<br>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | (a &gt;= min)&amp;&amp;(a &lt;= max) = extract min max x<br>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | otherwise = a:extract min max x</pre>

  <li> Alternatively</li>

  
  <pre>&gt; extract1::Int-&gt;Int-&gt;[Int]-&gt;[Int]<br>&gt; extract1 min max [] = []<br>&gt; extract1 min max (a:x)<br>&gt;&nbsp;&nbsp; | (a &gt;= min) &amp;&amp; (a &lt;= max) = extract1 min max x<br>&gt;&nbsp;&nbsp; | otherwise&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = a:extract1 min max x</pre>

  <li> Functions derived from extract:</li>

  <li> In the script:</li>

  
  <pre>&gt; extractOver8 = extract 8<br>&gt; extractBetween8and16 = extract 8 16</pre>

  <li> In the interpreter:</li>

  
  <pre>...&gt; :t extract<br>extract :: Int -&gt; Int -&gt; [Int] -&gt; [Int]<br>...&gt; :t extractOver8<br>extractOver8 :: Int -&gt; [Int] -&gt; [Int]<br>...&gt; :t extractBetween8and16<br>extractBetween8and16 :: [Int] -&gt; [Int]</pre>

</ul>

<h3>
<hr noshade="noshade" size="1" width="50%">Function application in a
curryed language</h3>

<ul>

  <li> Functions are left associative</li>

  <li> The follow will cause an error!</li>

  <br>

  <b><tt>&nbsp;&nbsp; (+) 3 (*) 2 4</tt></b> <li> NEED "( )"</li>

  <br>

  <b><tt>&nbsp;&nbsp; (+) 3 ((*) 3 4)</tt></b>
</ul>

<hr align="left" size="1" width="99%">
<h3> Regular logs from general logs</h3>

<ul>

  <li> Given a function</li>

  
  <pre>logBase::Float-&gt;Float-&gt;Float</pre>

  <li> The function that returns the logarithm of a number using base 10:</li>

  
  <pre>...&gt;:t logBase 10<br><br>logBase 10 :: Float -&gt; Float</pre>

  <li> Apply the function logBase 10 to 100</li>

  
  <pre>...&gt; logBase 10 100&nbsp;<br>2</pre>

</ul>

<ul>

  
  <pre></pre>

</ul>

<h3>
<hr size="1" width="100%">Using <i>where</i></h3>

<ul>

  <li> Local definitions (scope) via <i>where</i></li>

  
  <ul>

    <li> <i>where</i> can be used for more readability</li>

  
  </ul>

  
  <p><br>

  <b><tt>quadroot :: Float -&gt; Float -&gt; Float -&gt; [Float]</tt></b> <br>

  <b><tt>quadroot a b c</tt></b> <br>

  <b><tt>&nbsp;&nbsp;&nbsp;&nbsp; | delta &lt; 0&nbsp;&nbsp;&nbsp; =
error  "complex roots"</tt></b> <br>

  <b><tt>&nbsp;&nbsp;&nbsp;&nbsp; | delta == 0&nbsp;&nbsp; = [term1]</tt></b> <br>

  <b><tt>&nbsp;&nbsp;&nbsp;&nbsp; | delta &gt; 0&nbsp;&nbsp;&nbsp; =
[term1+term2,  term1-term2]</tt></b> <br>

  <b><tt>&nbsp;&nbsp;&nbsp;&nbsp; where</tt></b> <br>

  <b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; delta = b*b -
4*a*c</tt></b> <br>

  <b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; radix = sqrt
delta</tt></b> <br>

  <b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; term1 =
-b/(2.0*a)</tt></b> <br>

  <b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; term2 =
radix/(2.0*a)</tt></b> <br>

&nbsp; </p>

  <li> Compare with with a code from Pascal</li>

  <br>

  <b><tt>type root_list = ^root_type;</tt></b> <br>

  <b><tt>type root_type = record</tt></b> <br>

  <b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; root: real;</tt></b> <br>

  <b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; next root_list</tt></b> <br>

  <b><tt>end;</tt></b> <br>

  <b><tt>function quadroot( a, b, c: real): root_list;</tt></b>
  
  <ul>

    <b><tt>var delta, radix, term2: real;</tt></b> <br>

    <b><tt>roots, temp: root_list;</tt></b>
  
  </ul>

  <b><tt>begin</tt></b>
  
  <ul>

    <b><tt>roots := NIL;</tt></b> <br>

    <b><tt>delta := b*b - 4*a*c;</tt></b> <br>

    <b><tt>if delta &lt; 0</tt></b>
    
    <ul>

      <b><tt>then write(&lsquo;Error: Complex Roots&rsquo;);</tt></b> <br>

      <b><tt>else begin</tt></b>
      
      <ul>

        <b><tt>radix := sqrt(delta);</tt></b> <br>

        <b><tt>term2 := radix/(2*a);</tt></b> <br>

        <b><tt>new(temp);</tt></b> <br>

        <b><tt>roots^.next:=temp;</tt></b> <br>

        <b><tt>temp^.root := roots^.root - term2;</tt></b> <br>

        <b><tt>roots^.root := roots^.root + term2;</tt></b> <br>

        <b><tt>temp^.next := NIL</tt></b>
      
      </ul>

      <b><tt>end</tt></b>
    
    </ul>

    <b><tt>end;</tt></b> <br>

    <b><tt>quadroot := roots</tt></b>
  
  </ul>

  <b><tt>end;</tt></b> <br>

  
  <hr size="3" width="100%">
  
  <ul>

&nbsp;
    
    <center>
    
    <table bgcolor="#fffff0" border="1" cellpadding="0" cellspacing="0">

      <tbody>

        <tr>

          <td><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/1hSpr01.html">previous</a></td>

          <td><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/3hSpr01.html">&nbsp;next</a></td>

        </tr>

      
      </tbody>
    
    </table>

    </center>

  
  </ul>

  
  <hr align="left" noshade="noshade" width="100%">
</ul>

<br>

<br>

<br>

</body>
</html>
