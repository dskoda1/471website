<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html><head>





  
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

  
  <meta name="Author" content="Head/ Lander">

  
  <meta name="GENERATOR" content="Mozilla/4.73 [en] (Win98; U) [Netscape]">

  
  <meta name="Description" content="CS471 spr 97"><title>Introduction to Functional Paradymn</title></head><body alink="#ff0000" bgcolor="#f5f5f5" link="#3366ff" text="#000000" vlink="#666666">
<h3 style="text-align: center;">Functional Languages: Introduction</h3>
<center>

</center>

<center>
<h4> © Eileen Head, Leslie C. Lander, 2005</h4>

</center>

Purpose:
<ul>

  <li> Why Study Functional Languages?</li>

  <li> Functional Programming Principles.</li>

  <li> Comparing imperative languages and functional languages.</li>

</ul>

Reference:<br>

<ul>

  <li> To a large extent the notes are based on the information in the
excellent text: Simon Thompson, <i>Haskell: The Craft of Functional
Programming</i>, 2nd edition Addison-Wesley Longman, 1999&#8230;</li>

  <li> &#8230;and A Gentle Introduction to Haskell, Version 98, available
on-line: <a href="http://haskell.org/tutorial/">http://haskell.org/tutorial/</a></li>

  <li>Introductory examples: <a href="http://bingweb.binghamton.edu/%7Ehead/CS471/CODE/Scripts/SimpleExample.lhs">SimpleExamples.lhs</a></li>

</ul>


<hr width="100%">
<ul>

</ul>

<h3>
<hr width="100%">Attempt to Solve Problems</h3>

<dl>

  <li> Research began in the 1960s to prove things about programs.</li>

  
  <dl>

Areas that were studied were: <li> How to prove a program is correct.</li>

    <li> Given the same input prove different code computes the same
results.</li>

    <li> Prove one program is faster than another.</li>

    <li> A given program will always terminate.</li>

  
  </dl>

</dl>

This lead researchers to analyze why it is harder to prove things about
programs written in traditional languages than it is to prove theorems
about mathematics.
<h3>
<hr width="100%">What are features of traditional languages
that don't correspond to the mathematical language?</h3>

<ul>

  <li> The truth or falsity of mathematical statements is a property of
the statement.</li>

  
  <ul>

    <li> Variables are not mutable, whereas programming languages have
variables whose content can be changed at any time.</li>

    <li> Programming variables are mutable.</li>

  
  </ul>

  <li> A mathematical proof is static.</li>

  
  <ul>

    <li> The order of facts in a proof is not important as long as the
terms are defined.</li>

    <li> A program is a description of a dynamic process.</li>

    
    <dl>

      
      <dl>

        <li> Sometimes the order matters and other times it does not.
To
fully describe an executing program you not only need the "code" you
also need a copy of the stack, global and static variables, and a copy
of the input.</li>

      
      </dl>

    
    </dl>

  
  </ul>

</ul>

<h3>
<hr width="99%"></h3>

<h3> <i><u>Why Study Functional Languages?</u></i></h3>

<h3> Correctness</h3>

<ul>

  <li> Programming language theorists can reason more easily about the
correctness of a functional-language program</li>

  <li> For a given input a functional-language function always gives
the
same output</li>

  <br>

Global variables and values stored in memory play little role
</ul>

<h3> Specification</h3>

<blockquote> <li> Learning functional programming helps programmers
formulate good specifications for programs.</li>

  <li> Good specification may allow automatic code generation and
verification.</li>

  <li> Learn about specification before you are out of a programming
job!</li>

</blockquote>

<h3>
<hr align="left" noshade="noshade" width="100%"></h3>

<h3> Functional Programming Principles</h3>

<h3> Programming methods</h3>

<ul>

  <li> Techniques derived from functional programming that are in use
in
standard imperative languages include:</li>

  
  <ul>

    <li>using referentially transparent expressions</li>

  
  </ul>

  
  <dl>

    <dd>An expression, <span style="font-style: italic;">E</span>,&nbsp;
is <span style="font-style: italic;">referentially transparent</span>
iff</dd>

  
  </dl>

  
  <ul>

    
    <ul>

      <li>the only thing that matters about <span style="font-style: italic;">E </span>is its value</li>

      <li>replacing any subexpression of <span style="font-style: italic;">E </span>by anoth other equally valued
expression has no <span style="font-weight: bold;">effect</span> on
the value <span style="font-style: italic;">E</span></li>

      <li><span style="font-weight: bold;">every</span> occurence of <span style="font-style: italic;">E</span> in the scope of its variables has
the same value <br>

      </li>

    
    </ul>

    <li>C/C++/Java/C# allow referentially <span style="font-style: italic;">opaque </span>expressions:<br>

      <span style="font-family: monospace;">int i =3; </span><br style="font-family: monospace;">

      <span style="font-family: monospace;"> int n = i++ - i++;&nbsp;
// 3 - 4 = -1&nbsp; </span><br style="font-family: monospace;">

However,
replacing the first occurence of i++ with 3 the result is 0</li>

  
  </ul>

  
  <dl>

    <dd><br>

    </dd>

  
  </dl>

  
  <ul>

  
  </ul>

</ul>

<h3>Imperative code, execution via mutation of memory (assignment to
memory)<br>

</h3>

<ul>

  
  <pre>int gcd(int u, int v) {<br>&nbsp;&nbsp;&nbsp; int x <b>=</b> u;&nbsp;<br>&nbsp;&nbsp;&nbsp; int y <b>=</b> v;&nbsp;<br>&nbsp;&nbsp;&nbsp; int t;&nbsp;<br>&nbsp;&nbsp;&nbsp; while (true) {&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (y == 0) {&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t <b>=</b> y;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y <b>=</b> x % y;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x <b>=</b> t;&nbsp;<br>&nbsp;&nbsp;&nbsp; }&nbsp;<br>}</pre>

</ul>

<h3>Imperiative code, execution via function application<br>

</h3>

<ul>

  
  <pre>int gcd(int u, int v) {&nbsp;<br>&nbsp;&nbsp;&nbsp; if (v == 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return u;<br>&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return gcd(v,u % v);&nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>}</pre>

</ul>

<h3> Matches mathematical definition of gcd</h3>

<ul>

  
  <pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { u&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if v = 0<br>gcd (u, v) = {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; { gcd (v, u mod v)&nbsp; if v &gt; 0<br></pre>

</ul>

<h3> Haskell version of gcd</h3>

&gt; gcd u v = if (v == 0) then u else gcd v (mod u v)
<br>

or <br>

&gt; gcd u 0 = u<br>

&gt; gcd u v = gcd v (u `mod` v)
<ul>

  <li> Note that &#8220;gcd&#8221; is in the Prelude so, you would need to write
&#8220;mygcd&#8221;</li>

  
  <ul>

    <li> or</li>

    <br>

    <tt>&gt; import Prelude hiding (gcd)</tt>
  
  </ul>

</ul>

<br>

<blockquote></blockquote>

<h3>
<hr width="100%">Why Haskell? Why not Lisp/scheme? - It&#8217;s well-known</h3>

<ul>

  <li> Lisp is basically functional but has many imperative-language
constructs, for example:</li>

  
  <ul>

    <li> sequences of commands</li>

    <li> loops</li>

    <li> goto (!)</li>

  
  </ul>

  <li> Lisp is widely used in artificial intelligence because it is
good
for symbolic processing.</li>

  <li> Syntax is not user friendly.</li>

  <li>Lisp/scheme includes update operations which destroys referential
transparency<br>

  </li>

</ul>

<hr align="left" noshade="noshade" width="100%">
<h3> Overview of Haskell Features: A fully Curried Lazy Language with
Overloading</h3>

<ul>

  <li>Simple Syntax</li>

  
  <ul>

    <li>Uses layout rule<br>

      <br>

    </li>

  
  </ul>

  <li>Pure Functional Language</li>

  
  <ul>

    <li>All expressions are referentially transparent<br>

      <br>

    </li>

  
  </ul>

  <li>Haskell is a pure modern functional language where</li>

  
  <ul>

    <li> Computation = function calls (applications)</li>

    <li> Computation != a sequence of changes to the values of variables</li>

    <li> Treat functions like any other type</li>

    <li> Allocation and deallocation of storage is automatic</li>

    <li> <b><i>Lazy parameter evaluation</i></b></li>

  
  </ul>

</ul>

<ul>

  <li> Haskell is a strongly typed language&nbsp;</li>

  
  <ul>

    <li> The data related aspects of Haskell:</li>

    
    <dl>

      
      <dl>

        <li> user defined recursive data types</li>

        <li> polymorphic types which describe families of types</li>

        <li><b>class</b> can construct sets of types.<br>

        </li>

        <li> list comprehension</li>

        <li> inference of the correct types -- types do not need to be
declared</li>

        <li> some pattern matching</li>

      
      </dl>

    
    </dl>

    <li> The ADT aspects of Haskell:</li>

    
    <ul>

      
      <dl>

        <li> modules;</li>

        <li> provides a mechanism for hiding and exporting data and
functions<span style="font-weight: bold;"></span></li>

      
      </dl>

    
    </ul>

  
  </ul>

</ul>

<br>

<br>

<ul>

  
  <ul>

    
    <ul>

      
      <dl>

      
      </dl>

    
    </ul>

  
  </ul>

</ul>

<hr align="left" noshade="noshade" width="100%">
<h3>Getting Started</h3>

Haskell was the first name of H. Curry, a logician in the 30's
and 40's. He will be mentioned again.
<ul>

  <li>The programming environment we will use for executing Haskell
programs is HUGS98 OR GHCi<br>
</li><li>Example GHCi session for:</li>

</ul>

<dl>

  <dd>
    
    <table style="text-align: left;" border="1" cellpadding="2" cellspacing="2">

      <tbody>

        <tr>

          <td style="vertical-align: top;">GHCi, version 6.10.4: http://www.haskell.org/ghc/&nbsp; :? for help<br>
Loading package ghc-prim ... linking ... done.<br>
Loading package integer ... linking ... done.<br>
Loading package base ... linking ... done.<br>

Prelude&gt; 17.2<br>

17.2<br>

Prelude&gt; 2^3 - 15<br>

-7<br>

Prelude&gt;</td>

        </tr>

      
      </tbody>
    
    </table>

    <br>

  </dd>

</dl>

<ul>

  <li><span style="font-weight: bold;">Prelude.hs,</span> (two) file of
standard definitions, are&nbsp; loaded automatically, when HUGS98 is
launched.</li>

  
  <ul>

    <li>both common functions and classes are defined</li>

    <li>operators are defined with their precedences and
associativities. i.e:<br>

    </li>

  
  </ul>

  
  <dl>

    <dd>infix 4 ==, /=, &lt;, `elem`<br>

infixr 3 &amp;&amp;<br>

inflxr 2 ||</dd>

    <dd><br>

    </dd>

  
  </dl>

  
  <ul>

    <li>(/) is floating point division and `div` is integer
division&nbsp; (note the <span style="font-weight: bold;">back-quotes)</span></li>

  
  </ul>

  
  <dl>

    <dd><span style="font-weight: bold;"></span>
      
      <table style="text-align: left;" border="1" cellpadding="2" cellspacing="2">

        <tbody>

          <tr>

            <td style="vertical-align: top;">Prelude&gt; 5 / 2<br>

2.5<br>

Prelude&gt; 5 `div` 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>

2&nbsp; <br>

Prelude&gt; div 5 2<br>

2<br>

            </td>

          </tr>

        
        </tbody>
      
      </table>

      <span style="font-weight: bold;"><br>

      </span></dd>

  
  </dl>

  <li>A pure functional program is just an <span style="font-weight: bold;"><span style="font-style: italic;">expression</span></span>,&nbsp;
Large expressions composed only of literals and operators are
cumbersome.</li>

  <li>We keep expressions manageable by using named
subexpressions.&nbsp; An expression name begins with a <span style="font-style: italic;">lowercase</span> letter.</li>

  <li>Collections of names and their definitions are placed in text
files
called <span style="font-weight: bold;"><span style="font-style: italic;">scripts</span></span></li>

  <li><span style="font-weight: bold;"><span style="font-style: italic;"><span style="font-style: italic;"></span></span></span><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/CODE/Scripts/SimpleExample.lhs">SimpleExamples.lhs</a>
    
    <p> </p>

  </li>

  
  <ul>

    <li>Each script contains a module whose name appears between the
reserve words <span style="font-weight: bold;">module </span>and <span style="font-weight: bold;">where</span><br>

    </li>

    <li>Module name begins with upper case letter</li>

    <li>The file name of the script is its module's name ++ [".lhs" or
".hs")</li>

    <li>.lhs: <span style="font-style: italic;">literate</span>
Haskell script: <br>

    </li>

    
    <ul>

      <li>Any nonblank line that does not begin with a "&gt;" is
a comment.&nbsp; <br>

      </li>

      <li>Comment lines are separated from code by blank
lines.&nbsp; <br>

      </li>

      <li>This is the form we will use.</li>

    
    </ul>

  
  </ul>

  <li><span style="font-weight: bold;">Compiling: </span>There are a
number of ways to load a script into HUGS98.&nbsp; HUGS then compiles
it.</li>

  <li>Scope of names</li>

  
  <ul>

    <li>the <span style="font-style: italic;">global</span> names are
visible everywhere in the script and in the command line</li>

    
    <ul>

      <li>x y&nbsp; and z<br>

      </li>

    
    </ul>

    <li>names can be declared local to a definition in the where clause:</li>

    
    <ul>

      <li>the scope of names defined in a where clause are limited to:</li>

    
    </ul>

    
    <dl>

      <dd>- other definitions in the same where clause<br>

- the right hand side of the definition which the <span style="font-style: italic;">where </span>belongs to<br>

      </dd>

    
    </dl>

    
    <ul>

      <li>the where in the definition of z hides the global name "x"</li>

    
    </ul>

    <dd>
      
      <table style="text-align: left; font-family: monospace;" border="1" cellpadding="2" cellspacing="2">

        <tbody>

          <tr>

            <td style="vertical-align: top;">&gt; z = a + x<br>

&gt;&nbsp;&nbsp;&nbsp;&nbsp; where<br>

&gt;&nbsp;&nbsp;&nbsp;&nbsp; a = 8*5<br>

&gt;&nbsp;&nbsp;&nbsp;&nbsp; x = 7 `rem` -3&nbsp; -- x hides the global
'x'&nbsp;&nbsp; <br>

            </td>

          </tr>

        
        </tbody>
      
      </table>

      <br>

    </dd>

    
    <ul>

    
    </ul>

  
  </ul>

  
  <ul>

    <li><span style="font-weight: bold;">let<span style="font-style: italic;"> is an alternative </span></span>way to
declare names local to an expression.</li>

  
  </ul>

  
  <dl>

    <dd>
      
      <table style="text-align: left;" border="1" cellpadding="2" cellspacing="2">

        <tbody>

          <tr>

            <td style="vertical-align: top;"><span style="font-family: monospace;">&gt; z = let a = 8 * 5</span><br style="font-family: monospace;">

            <span style="font-family: monospace;">&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
x = 7 `rem` -3</span><br style="font-family: monospace;">

            <span style="font-family: monospace;">&gt;&nbsp;&nbsp;&nbsp;
in a + x&nbsp; </span><br>

            </td>

          </tr>

        
        </tbody>
      
      </table>

    </dd>

  
  </dl>

  <li>Layout is <span style="font-style: italic;">syntactically
meaningful</span></li>

  
  <ul>

    <li>Every line of a definition begins to the <span style="font-weight: bold;">right</span> of the first line of the
definition</li>

    <li><span style="font-style: italic;">Offset Rule: </span>Lines
that begin in the same column as the current definition may start a new
definition, or it may continue an enclosing definition.</li>

    <li>Tabs matter.&nbsp; It is better to use white spaces instead of
tab.</li>

    <li>Python is another language that layout is part of the syntax
rule<br>

    </li>

  
  </ul>

  
  <ul>

  
  </ul>

</ul>

<hr align="left" noshade="noshade" width="100%"> <br>

</body></html>