<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="Author" content="Les Lander">
  <meta name="GENERATOR"
 content="Mozilla/4.76 [en] (Windows NT 5.0; U) [Netscape]">
  <title>471 Haskell execution -- Tail Recursion</title>
</head>
<body>
&nbsp;
<center>
<table border="1" cellspacing="0" cellpadding="0" bgcolor="#fffff0">
  <tbody>
    <tr>
      <td><a
 href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/9hSpr01.html">
previous</a></td>
      <td><a
 href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/10hSpr01.html">
&nbsp;next&nbsp;</a></td>
    </tr>
  </tbody>
</table>
</center>
<center>
<h3> Haskell 10</h3>
</center>
<center>
<h3> &copy; Eileen Head, Leslie C. Lander, 2002</h3>
</center>
Purpose: To examine some execution issues. &nbsp;An important topic
covered is Tail recursive function.
<h4>
<hr width="100%"></h4>
<h3> Clever tricks with auxiliary functions</h3>
<blockquote>
  <pre>&gt; fib :: Int -&gt; Int<br>&gt; fib 1 = 1<br>&gt; fib 2 = 1<br>&gt; fib n = fib (n-2) + fib (n-1)</pre>
  <li> Faster version:</li>
  <pre>&gt; fib1 1 = 1<br>&gt; fib1 n = fiba n 1 0 1<br>&gt;&nbsp;&nbsp; where<br>&gt;&nbsp;&nbsp; fiba n c a b =<br>&gt;&nbsp;&nbsp;&nbsp;&nbsp; if c == n then b<br>&gt;&nbsp;&nbsp;&nbsp;&nbsp; else fiba n (c+1) b (a+b)</pre>
</blockquote>
<h3> Linear</h3>
<ul>
  <pre>fiba 7 1 0 1&nbsp;<br>=&gt; fiba 7 2 1 1&nbsp;<br>=&gt; fiba 7 3 1 2&nbsp;<br>=&gt; fiba 7 4 2 3&nbsp;<br>=&gt; fiba 7 5 3 5&nbsp;<br>=&gt; fiba 7 6 5 8&nbsp;<br>=&gt; fiba 7 7 8 13&nbsp;<br>=&gt; 13</pre>
  <li> The number of recursive calls is linear in n. Compare this to</li>
</ul>
<h3> Exponential</h3>
<blockquote>
  <pre>fib 7<br>=&gt; fib 5 + fib 6<br>=&gt; fib 3 + fib 4 + fib 4 + fib 5<br>=&gt; fib 1 + fib 2 + fib 2 + fib 3<br>&nbsp;&nbsp; +fib 2 + fib 3 + fib 3 + fib 4<br>=&gt; 1 + fib 0 + fib 1 + fib 0<br>&nbsp;&nbsp; +fib 1 + fib 1 + fib 2 + fib 0<br>&nbsp;&nbsp; +fib 1 + fib 1 + fib 2 + fib 1<br>&nbsp;&nbsp; +fib 2 + fib 2 + fib 3<br>=&gt; ...</pre>
  <li> exponential (#calls &gt; fib n)</li>
</blockquote>
<h3> Fibonacci really is exponential</h3>
<ul>
  <pre>fibonacci(<i>n</i>) = [(1 + sqrt(5))<i><sup>n</sup></i> - (1 - sqrt(5))<i><sup>n</sup></i>]/ 2<i><sup>n</sup></i> sqrt(5)</pre>
and we can show (1.6)<sup><i>n </i>- 2</sup> &lt; fibonacci(<i>n</i>)
&lt; (1.7)<sup><i>n </i>- 1</sup> for <i>n</i> &gt; 2 <li> Compare
the performance of fib1 20 and fib 20</li>
</ul>
<h3> Using Complex Data Structure to save Computation Time</h3>
<ul>
... Using <i>where</i>
  <p><tt>&gt; fib3 n = fNum</tt> <br>
  <tt>&gt;&nbsp;&nbsp; where</tt> <br>
  <tt>&gt;&nbsp;&nbsp; (fNum,_) = fibP n</tt> <br>
  <tt>&gt;&nbsp;&nbsp; fibP 0 = (0,1)</tt> <br>
  <tt>&gt;&nbsp;&nbsp; fibP n = (y,x+y)</tt> <br>
  <tt>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where</tt> <br>
  <tt>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (x,y) = fibP (n-1)</tt> <br>
&nbsp; </p>
  <li> This solution runs in linear time and linear space</li>
</ul>
<h3> More power in lazy evaluation</h3>
<ul>
&#8230;and at the same time use the list for the computation <br>
&nbsp;
  <pre>&gt; fib2 n = fibs !! n<br>&gt;&nbsp;&nbsp; where<br>&gt;&nbsp; fibs = 0:1:zipWith (+) fibs (tail fibs)</pre>
  <li> The initial &#8220;0&#8221; stands for &#8220;fib2 0,&#8221; which is not normally
defined, used since lists are indexed from 0</li>
  <li> Remember: only compute as much of the list as is needed</li>
  <h3> Details</h3>
  <ul>
    <pre>fibs = 0:1:1:2:3:5:8:13:21:34:...<br>tail fibs=1:1:2:3:5:8:13:21:34:...</pre>
    <pre>0:1:zipWith (+) fibs (tail fibs)<br>=&gt; 0:1:zipWith (+)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0:1:1:2:3:5 :8 :13:21:34:...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1:1:2:3:5:8 :13:21:34:55:...<br>=&gt; 0:1:1:2:3:5:8:13:21:34:55:89:&#8230;</pre>
    <li> Every value that is computed is stored in the list and reused</li>
    <li> <tt>fib2 </tt>runs in linear time</li>
    <dl>
      <dl>
        <li> AND because of lazy evaluation <tt>fib2 </tt>has only
constant space requirements.</li>
      </dl>
    </dl>
  </ul>
  <hr size="1" noshade="noshade" width="100%">
</ul>
<h3> Factorial Recursive definition</h3>
<ul>
  <tt>&gt; factorial 0 = 1</tt> <br>
  <tt>&gt; factorial n = n*factorial (n-1)</tt>
  <blockquote><tt>or using if/else statement</tt></blockquote>
  <tt>&gt; fact n = if ( n==0) then 1 else n*fact (n-1)</tt> <br>
&nbsp; <li> Notice the form of the execution tree:</li>
  <br>
  <a
 href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/17fact.gif"><img
 src="17fact.gif" alt="Recursive Factorial Function" border="0"
 height="275" width="222"> <br>
  </a><b>Notice the pattern of the solid lines. &nbsp;They form a
"comb".</b>
</ul>
<h3> The fibonacci trick with factorial--not as effective</h3>
<blockquote>
  <pre>&gt; fact2 n = facts !! n<br>&gt;&nbsp; where<br>&gt;&nbsp;&nbsp; facts = 1:1:zipWith (*) [2..] (tail facts)</pre>
  <pre>facts = 1:1:2:6:24:120:720:...<br>tail facts = 1:2:6:24:120:720:...<br>[2..]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 2:3:4: 5:&nbsp; 6:&nbsp; 7:...</pre>
  <pre>1:1:zipWith (*)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2:3:4: 5:&nbsp; 6:&nbsp; 7:&nbsp;&nbsp; 8:&nbsp;&nbsp;&nbsp; 9:...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1:2:6:24:120:720:5040:40320:...<br>=&gt; 1:1:2:6:24:120:720:5040:40320&#8230;</pre>
</blockquote>
<h3> Other versions of factorial</h3>
<blockquote>
  <pre>&gt; fact 0 = 1<br>&gt; fact n = n* fact(n-1)</pre>
  <pre>&gt; fact1 n = facta n 0 1<br>&gt;&nbsp; where<br>&gt;&nbsp;&nbsp; facta n c accm = if (c == n) then accm&nbsp;<br>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else facta n (c+1) (c+1)*accm</pre>
</blockquote>
<h3> Tail recursion</h3>
<ul>
  <li> <tt>gcd u v = if (v == 0) then u else gcd v (mod u v)</tt></li>
  <br>
  <a
 href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/17gcd.gif"><img
 src="17gcd.gif" alt="Execution Tree for gcd 12 9" border="0"
 height="300" width="264"> </a> <br>
  <b>NOTICE the pattern of the solid lines: &nbsp; It forms a tail!</b><br>
  <br>
  <li>One important feature of facta and fiba is that they are tail
recursive:</li>
  <pre>facta n c accm = if (c==n) then accm else facta n (c+1) (c+1)*accm</pre>
  <pre>fiba n c a b = if c == n then b else fiba n (c+1) b (a+b)</pre>
  <pre></pre>
</ul>
<h3> The general form of tail recursion</h3>
<ul>
  <pre>f(x) = if p(x) then q(x) else f (h(x))</pre>
  <li> A good compiler can replace tail recursion by a loop
automatically</li>
  <li> The argument x can be a sequence of arguments or a tuple</li>
  <pre>f(x,y,z) = if p(x,y,z) then q(x,y,z) else f(x',y',z')</pre>
  <pre>f x y z = if p x y z then q x y z else f x' y' z'</pre>
</ul>
<h3> Iterative form</h3>
<ul>
  <li> The corresponding iterative code is:</li>
  <pre>type2 f(type1 x) {&nbsp;<br>&nbsp;&nbsp;&nbsp; type1 t = x;&nbsp;<br>&nbsp;&nbsp;&nbsp; while (true) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (p(t)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return q(t);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t = h(t);&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</pre>
  <li> Apply the transformation to:</li>
  <pre>facta n c k = if (c == n) then k else facta n (c+1) (c+1)*k</pre>
</ul>
<h3> Iterative form of facta</h3>
<blockquote>
  <pre>facta n c k = if (c==n) then k else facta n (c+1) (c+1)*k</pre>
  <pre>int iterfacta(int n,int c,int k){<br>&nbsp;&nbsp;&nbsp; int tn = n; // not really needed IN THIS CASE<br>&nbsp;&nbsp;&nbsp; int tc = c;&nbsp;<br>&nbsp;&nbsp;&nbsp; int tk = k;<br>&nbsp;&nbsp;&nbsp; while (true) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tc == tn) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tk;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tn = tn;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tc++;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tk *= tc;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</pre>
</blockquote>
<h3> Comments</h3>
<ul>
  <li> These linear iterations use very little space since no recursive
calls are made</li>
  <li> We see later the effect of calling subprograms on space</li>
  <li> Other functions such as fiba and gcd are also tail recursive and
can be converted to high-speed loops by a compiler</li>
</ul>
<h3> Iterative version of fiba</h3>
<blockquote>
  <pre>fiba n c a b = if c == n then b else fiba n (c+1) b (a+b)</pre>
  <pre>int iterFiba(int n,int c,int a,int b){&nbsp;<br>&nbsp;&nbsp;&nbsp; int tn = n;&nbsp;<br>&nbsp;&nbsp;&nbsp; int tc = c;&nbsp;<br>&nbsp;&nbsp;&nbsp; int ta = a;&nbsp;<br>&nbsp;&nbsp;&nbsp; int tb = b;&nbsp;<br>&nbsp;&nbsp;&nbsp; while (true) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tc == tn) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tb;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tn=tn;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tc++;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int t = ta;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ta = tb;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tb += t;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</pre>
</blockquote>
<h3> Iterative form of gcd (assumes one input is not 0)</h3>
<blockquote>
  <pre>gcd m n = if n == 0 then m else gcd (n, m `mod` n)</pre>
  <pre>int itergcd(int m, int n) {&nbsp;<br>&nbsp;&nbsp;&nbsp; int tm = m;&nbsp;<br>&nbsp;&nbsp;&nbsp; int tn = n;&nbsp;<br>&nbsp;&nbsp;&nbsp; while (true) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tn == 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tm;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int t = tm;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tm = tn;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tn = t `mod` tn;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</pre>
</blockquote>
<h3> Kieburtz and Shultis</h3>
<ul>
  <li> Not all recursive functions are tail recursive. If a function is
not tail recursive, an accumulating parameter will need to be
introduced.</li>
  <li> There is substantial research into this area.</li>
  <li> One very nice result is due to Kieburtz and Shultis.</li>
  <li> Suppose f has the form:</li>
</ul>
<h3> Format for Kieburtz and Shultis</h3>
<blockquote>
  <pre>f x = if p x then q x else r (g x) (f (h x))</pre>
where r is ASSOCIATIVE, i.e.<tt> r x (r y z) = r (r x y) z</tt> <br>
or infix: <tt>x `r` (y `r` z) = (x `r` y) `r` z</tt> <br>
then f can be transformed into the iteration:</blockquote>
<h3> Iterative form</h3>
<blockquote>
  <pre>type2 f(type1 x) {<br>&nbsp;&nbsp;&nbsp; type1 t = x;&nbsp;<br>&nbsp;&nbsp;&nbsp; type2 acc;&nbsp;<br>&nbsp;&nbsp;&nbsp; if (p(t)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return q(t);<br>&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; acc := g(t);<br>&nbsp;&nbsp;&nbsp; } //see note&nbsp;<br>&nbsp;&nbsp;&nbsp; while(true) {&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t = h(t);&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (p(t)) (<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return r(acc,q(t));&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; acc = r(acc,g(t));&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</pre>
</blockquote>
<h3> Some K&amp;S functions</h3>
<ul>
  <li> Note: In general you cannot assign to &#8220;acc&#8221; before checking that
&#8220;p(t)&#8221; is false.</li>
  <li> It can be the case that &#8220;g(t)&#8221; is undefined when &#8220;p(t)&#8221; is true,
e.g. when p(t) is (t == 0) and g(t) is 1/t</li>
  <li> The functions factorial and length are of the K&amp;S form</li>
</ul>
<h3> factorial</h3>
<ul>
  <pre>fact n = if n == 0 then 1 else n * fact(n-1)</pre>
  <pre>r is multiply (*);&nbsp;&nbsp;<br>g(n) = n&nbsp;<br>q(n) = 1;&nbsp;<br>h(n) = n-1;&nbsp;<br>p is (0==)</pre>
  <li> The iterative form is on the next slide</li>
  <li> Notice that the iterative code simply modifies two memory
locations until a predicate is satisfied</li>
</ul>
<h3> Iterative version</h3>
<blockquote>
  <pre>long f(int x) {<br>&nbsp;&nbsp;&nbsp; int t = x;&nbsp;<br>&nbsp;&nbsp;&nbsp; long acc;&nbsp;<br>&nbsp;&nbsp;&nbsp; if (t==0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<br>&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; acc := t;&nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; while(true) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t = t-1;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (t==0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return acc*1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; acc = acc*t;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</pre>
</blockquote>
<h3> Garbage</h3>
<ul>
  <li> Functional languages generate many temporary data structures
during execution</li>
  <li> The data structures may be shared among several temporary
variables, e.g. there may be several variables pointing at different
parts of a list</li>
  <li> Temporary storage stops being useful as soon as a function
evaluation is complete...</li>
</ul>
<h3> Garbage collection</h3>
<ul>
&#8230;it becomes garbage <li> A program would soon run out of memory if the
memory storing the garbage were not cleared for reuse</li>
  <li> This needs to be an automatic process since the programmer has
no control of memory allocation</li>
  <li> The automatic process is called garbage collection</li>
</ul>
<h3> Garbage collection</h3>
<ul>
  <li> In fact, garbage collection is also important for
object-oriented systems and Java provides automatic garbage collection</li>
  <li> Functional programming environments must provide garbage
collection to be able to make larger computations or run for a longer
time</li>
  <li> We may look at techniques for garbage collection later</li>
</ul>
<hr width="100%">
<center>
<table border="1" cellspacing="0" cellpadding="0" bgcolor="#fffff0">
  <tbody>
    <tr>
      <td><a
 href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/8hSpr01.html">
previous</a></td>
      <td><a
 href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/10hSpr01.html">
&nbsp;next&nbsp;</a></td>
    </tr>
  </tbody>
</table>
</center>
<hr align="left" size="6" noshade="noshade" width="100%"> <br>
<br>
</body>
</html>
