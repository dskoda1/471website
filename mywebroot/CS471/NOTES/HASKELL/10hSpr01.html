<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html><head>








  
  
  
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">



  
  
  
  <meta name="Author" content="Head/ Lander">



  
  
  
  <meta name="GENERATOR" content="Mozilla/4.77 [en] (Windows NT 5.0; U) [Netscape]">



  
  
  
  <meta name="Description" content="CS471 spr 97"><title>Foundation of Functional Programming</title><meta http-equiv="content-type" content="text/html; charset=utf-8"></head><body style="background-color: rgb(245, 245, 245); color: rgb(0, 0, 0);" alink="#ff0000" link="#00ff00" vlink="#666666">



<div style="text-align: center;">
<h3>Haskell 11<span style="font-weight: bold;"><br>



</span>© Eileen Head, Leslie C. Lander, Spring 2011</h3>



</div>



<center></center>



<center>
</center><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/CODE/Scripts/Theory.lhs">Related
Haskell code</a> <br>



&nbsp;<a href="http://lambdadance.spacebar.org/">Lambda Dance</a> <br>



<a href="http://www.boost.org/doc/html/lambda.html">Implementing Lambda
Expressions in C++</a><br>
<a href="http://www.ddj.com/184406320">Functional Programming in Java (Dr. Dobbs)</a><br>
<a href="http://www.infoq.com/presentations/Functional-Programming-A-Pragmatic-Introduction">Functional Programming A Pragmatic Introduction</a><br>



<hr align="left" noshade="noshade" width="100%">Brief overview of
lambda calculus (without the Type theory.)
<ul>



  <li> Alonzo Church (1930s) introduced lambda calculus as a framework
to study computations with functions</li>



  <li> Lambda Calculus is equivalent to computation by Turing Machines.</li>



  <li> Lambda Calculus is a minimal notation that exposes only what is
essential to study computations with functions.</li>



  <li> The two essential operations with functions are</li>



  
  
  
  <ul>



    <li> function creation</li>



    <li> function application</li>



  
  
  
  </ul>



  
  
  
  <hr align="left" noshade="noshade" width="100%">
</ul>



<h4> Traditional lambda-notation</h4>



<ul>



  <li> A lambda abstraction has the form</li>



  
  
  
  <ul style="font-weight: bold;">



    <font color="#000099">\ <i>x</i>.
E</font>
  
  
  
  </ul>



which denotes a function with formal argument <font style="font-weight: bold;" color="#3366ff">x</font>
and with body <font style="font-weight: bold;" color="#3333ff">E</font>
  
  
  
  <ul>



    <li> <font style="font-weight: bold;" color="#3333ff">E</font><font color="#000000"> is
called \</font>
-term (or \ -expression)</li>



  
  
  
  </ul>



  <li> Functions do not have names</li>



  <li> Functions have a single argument</li>



  
  
  
  <ul>



    <li> functions with one argument can be generalized to multiple args</li>



    <br>



    
    
    
    <hr align="left" noshade="noshade" width="100%">
  
  
  
  </ul>



  <li> The only thing a function can do is to apply it to an argument</li>



  <li> Notation used</li>



  
  
  
  <ul style="font-weight: bold;">



    <font color="#000099">E F</font>
  
  
  
  </ul>



  <font color="#000000">to denote the application of function </font><font style="font-weight: bold;" color="#000099">E</font><font color="#000000"> to actual argument</font><font style="font-weight: bold;" color="#000099"> F</font>
  
  
  
  <ul>



    
    
    
    <hr align="left" noshade="noshade" width="100%">
  
  
  
  </ul>



  <li> There are only three kinds of expressions</li>



  
  
  
  <table>



    <caption> <br>



    </caption><tbody>



    
    
    
    </tbody> <tbody>



      <tr>



        <td><font color="#990000">E</font> ::=</td>



        <td><br>



        </td>



        <td><br>



        </td>



        <td><br>



        </td>



      </tr>



      <tr>



        <td><br>



        </td>



        <td style="font-weight: bold;"><font color="#990000">x</font></td>



        <td>&nbsp;</td>



        <td><i><font color="#000099">Variables</font></i></td>



      </tr>



      <tr>



        <td><br>



        </td>



        <td style="font-weight: bold;">| <font color="#990000">E<sub>1&nbsp;</sub>
E<sub>2</sub></font></td>



        <td><br>



        </td>



        <td><i><font color="#000099">Application</font></i></td>



      </tr>



      <tr>



        <td><br>



        </td>



        <td>| <font style="font-weight: bold;" color="#990000">\<i>x</i>.
E</font></td>



        <td><br>



        </td>



        <td><i><font color="#000099">Abstraction</font></i></td>



      </tr>



    
    
    
    </tbody>
  
  
  
  </table>



  
  
  
  <ul>



    
    
    
    <ul>



&nbsp;
    
    
    
    </ul>



  
  
  
  </ul>



  <li> Examples</li>



  
  
  
  <ul>



    <li> <i>x</i> is a variable which is <i>bound</i> by lambda.</li>



    
    
    
    <dl>



      
      
      
      <dl>



        <li> Identity function:<b> <font color="#000099">\<i>x</i>. <i>x</i></font></b></li>



        <li> <b><font color="#000099">\ <i>x</i>. (+)<i> x</i> <i>x</i></font></b></li>



        
        
        
        <dl>



          <li> E is (+)<i> x x</i></li>



        
        
        
        </dl>



      
      
      
      </dl>



    
    
    
    </dl>



    <li> <b><font color="#000099">\ <i>y</i>. ( \ <i>x</i>. <i>x</i>)</font></b></li>



    <li><b><font color="#000099">\ <i>x </i>.&nbsp; (+) <i>x y</i><br>



      </font></b></li>



  
  
  
  </ul>



  <li> Bindings</li>



  
  
  
  <ul>



    <li> Application associates to the left</li>



    
    
    
    <ul>



      <i>E F G&nbsp;</i> parses as ( <span style="font-style: italic;">E
F </span>) <span style="font-style: italic;">G</span>
    
    
    
    </ul>



    <li> Abstractions definitions extends as far to the right as
possible</li>



    
    
    
    <ul>



      <b><font color="#000099">\ <i>x</i>. <i>x \ </i><i>y</i>. <i>E
F G&nbsp; </i></font></b><font color="#000000">parses as</font> <br>



      <b><font color="#000099">\ <i>x</i>.
( <i>x</i> ( \ <i>y</i>. ( <u style="text-decoration: underline;">( <i>E
F </i>)</u><span style="text-decoration: underline;"> </span><span style="font-style: italic;"><span style="text-decoration: underline;">G</span>
      </span>)
) )</font></b> <br>



      <b><font color="#000099">\ <i>x</i>. ( <i>x</i> ( \ <i>y</i>.<u>
( (<i>E F </i>) <i>G </i>)</u> ) )</font></b> <br>



      <b><font color="#000099">\ <i>x</i>. ( <i>x </i><u>( \<i> y</i>.
( ( <i>E F </i>) <i>G </i>) )</u> )</font></b> <br>



      <b><u><font color="#000099">\ <i>x</i>. ( <i>x</i> ( \ <i>y</i>.
( ( <span style="font-style: italic;">E F</span>) <span style="font-style: italic;">G </span>) ) )</font></u></b> <br>



      
      
      
      <hr align="left" noshade="noshade" width="100%">
    
    
    
    </ul>



  
  
  
  </ul>



  <li> The textbook&nbsp; has the example :</li>



  
  
  
  <pre>(\x. + 1 x)</pre>



  <li> Haskell</li>



  
  
  
  <pre>\x -&gt; (+) 1 x or \x -&gt; 1 + x</pre>



  <li> (In Common Lisp and Scheme, this can be written (lambda (x) (+ 1
x))</li>



  <li> Notice that lambda-calculus functions can be anonymous (no name
is needed)</li>



</ul>



<hr width="100%">
<ul>



  <li> The body of the function is also the scope of the binding for <i>x</i>
.</li>



  <li> A variable that is not bound is called <i>free</i>.</li>



  <li> Thus <i>x</i> is bound and <i>y</i> is free in</li>



  
  
  
  <ul>



    <li> (\ <i>x</i>. + <i>x</i> <i>y</i>)</li>



  
  
  
  </ul>



  <li> We might have lambda abstractions with more than one variable:</li>



  
  
  
  <ul>



    <li> (\&nbsp;<i> y</i>. ( \ <i>x</i>. + <i>x
y</i>))</li>



    <li> Here <i>x</i> and <i>y</i> are both <i>bound,</i> but by
different <i>lambdas</i>.</li>



  
  
  
  </ul>



  <li> Such expressions can be evaluated (application) when they are
given arguments:</li>



  
  
  
  <ul>



    <tt>(</tt>\<tt><i> x</i>. * <i>x x</i>
) 7</tt> <br>



    <tt>=&gt; (* 7 7)</tt> <br>



    <tt>=&gt; 49</tt> <br>



    
    
    
    <hr align="left" noshade="noshade" size="1" width="150"> <br><span style="font-family: monospace;">



(\ </span><i style="font-family: monospace;">y</i><span style="font-family: monospace;">. </span><br style="font-family: monospace;"><span style="font-family: monospace;">



&nbsp;&nbsp;&nbsp;&nbsp; (\ </span><i style="font-family: monospace;">x</i><span style="font-family: monospace;">.+ </span><i style="font-family: monospace;">x
y</i><span style="font-family: monospace;"> ) ) 3 </span><br style="font-family: monospace;"><span style="font-family: monospace;">



=&gt; (\ </span><i style="font-family: monospace;">x</i><span style="font-family: monospace;">. + </span><i style="font-family: monospace;">x</i><span style="font-family: monospace;"> 3) </span><br>



    
    
    
    <hr align="left" noshade="noshade" size="1" width="150">
  
  
  
  </ul>



  <li> whereby a function is evaluating to another function and</li>



  
  
  
  <ul><span style="font-family: monospace;">



(\ </span><i style="font-family: monospace;">x</i><span style="font-family: monospace;">. + </span><i style="font-family: monospace;">x</i><span style="font-family: monospace;"> 3 ) 1 </span><br style="font-family: monospace;"><span style="font-family: monospace;">



=&gt; (+ 1 3) </span><br style="font-family: monospace;">



=&gt; 4
  
  
  
  </ul>



  <li> Hence:</li>



  <br>



  <tt>(\</tt> <tt><i>y</i>.</tt> <br>



  <tt>&nbsp; (\</tt> <tt><i>x</i>. + <i>x y</i> )) 3 1</tt> <br>



  <tt>=&gt; 4</tt> <br>



&nbsp; <li> This sequence of two functions, each function taking one
variable, is equivalent to the function of two variables. The
expression
(+ 2) has a value as a function that adds 2 to any value.</li>



  <br>



  <tt>((+ 2) 3) = (+ 2 3) -&gt; 5</tt>.
</ul>



<ul>



  <li> Turning functions of many variables into sequences of functions,
each of one variable, is called <i>currying. </i>This term comes from
American mathematician, <b>HASKELL</b> B. Curry, who popularized its
use
in the 1950s.</li>



</ul>



<h4> Haskell shorthand</h4>



<ul>



  <li> &nbsp;&nbsp;&nbsp; Haskell has an abbreviated way to express
nested lambda-functions:</li>



  
  
  
  <ul>



    <tt><br>



(\ x y z&nbsp; -&gt;&nbsp; x&nbsp; +&nbsp; y&nbsp; +&nbsp; z)<br>



    <br>



    </tt>
  
  
  
  </ul>



  
  
  
  <ul>



    <li> &nbsp;&nbsp;&nbsp; is an abbreviation of</li>



    <br>



&nbsp;&nbsp;&nbsp;<tt> (\x -&gt; (\y -&gt; (\z -&gt; x + y + z)))<br>



    <br>



    </tt>
  
  
  
  </ul>



  <li> &nbsp;&nbsp;&nbsp; Thus even (\ x y z -&gt; x + y + z) is
treated
as if it were in Curried form:</li>



&nbsp;
  
  
  
  <ul>



&nbsp;&nbsp;&nbsp; <tt>...&gt;:t (\ x y z -&gt; x+y+z)</tt> <br>



    <tt>&nbsp;&nbsp;&nbsp; \ x y z-&gt; x + y + z :: Num a =&gt; a
-&gt; a -&gt; a -&gt; a</tt>
  
  
  
  </ul>



</ul>



<h4>
<hr width="100%">There are very precise rules for transforming lambda
expressions.</h4>



The historical names for the rules are "alpha-conversions",
"beta-conversions" and "eta-conversions".
<ul>



  <li> <b>Beta-conversions</b> are rules for <b>function application</b>(substitution).
A copy of the body of the lambda abstraction is made and occurrences of
the bound variable being replaced by the argument.&nbsp;</li>



  
  
  
  <ul>



i.e. By substituting 2 for <i>x </i>we get
    
    
    
    <ul>



(( \&nbsp;<i> x.</i> + <i>x </i>1) 2) is equivalent to ( + 2 1) .
    
    
    
    </ul>



  
  
  
  </ul>



  <li> <b>Alpha conversions</b> (renaming) are for handling variable
names in different scopes. This does not change the meaning of the
abstraction.&nbsp; </li>



  
  
  
  <ul>



    <li> For example:</li>



    
    
    
    <ul>



      
      
      
      <ul>



\ x . x+1&nbsp; &lt;--&gt; \&nbsp; y . y+1 &nbsp;
      
      
      
      </ul>



    
    
    
    </ul>



    <li> <b>Name capture </b>problem:</li>



    
    
    
    <dl>



      
      
      
      <dl>



        <li> Consider</li>



( \&nbsp;<i> x.</i>(<i> </i>\ <i>y.</i>+ <i>x
y </i>) <i>y </i>)
      
      
      
      </dl>



    
    
    
    </dl>



  
  
  
  </ul>



</ul>



<ul>



  
  
  
  <ul>



    
    
    
    <dl>



      
      
      
      <dl>



        <li> The<b> </b>problem:</li>



        <br>



The first occurrence of <i>y </i>is bound while the second is free. <br>



If we carelessly replace <i>x </i>by <i>y</i>we get the incorrect
reduction:
        
        
        
        <ul>



(<i> </i>\&nbsp;<i> y.</i> + <i>y y</i> )
        
        
        
        </ul>



        <li> Using alpha reduction rules which allows us to change
variable names we get the correct reduction:</li>



        
        
        
        <ul><span style="font-family: monospace;">



( \&nbsp;</span><i style="font-family: monospace;"> x.</i><span style="font-family: monospace;"> ( \&nbsp;</span><i style="font-family: monospace;"> y.</i><span style="font-family: monospace;"> + </span><i style="font-family: monospace;">x y </i><span style="font-family: monospace;">) </span><i style="font-family: monospace;">y </i><span style="font-family: monospace;">) </span><br style="font-family: monospace;"><span style="font-family: monospace;">



=&gt; ( \&nbsp;</span><i style="font-family: monospace;"> x.</i><span style="font-family: monospace;"> (</span><i style="font-family: monospace;"> </i><span style="font-family: monospace;">\</span><i style="font-family: monospace;"> z.</i><span style="font-family: monospace;"> + </span><i style="font-family: monospace;">x z </i><span style="font-family: monospace;">) </span><i style="font-family: monospace;">y </i><span style="font-family: monospace;">)</span><br style="font-family: monospace;"><span style="font-family: monospace;">



=&gt; ( \&nbsp;</span><i style="font-family: monospace;"> z.</i><span style="font-family: monospace;"> + </span><i style="font-family: monospace;">y z </i>)
        
        
        
        </ul>



      
      
      
      </dl>



    
    
    
    </dl>



  
  
  
  </ul>



</ul>



<ul>



  <li> <b>Eta conversions </b>are used to eliminate "redundant"
lambda
abstractions.The eta conversion rule states</li>



  
  
  
  <ul>



    
    
    
    <ul>



\&nbsp; x . f x&nbsp; =&gt;&nbsp; f
    
    
    
    </ul>



  
  
  
  </ul>



provided x does not occur free in f and f is a function.
  
  
  
  <ul>



    <li> For example:</li>



    
    
    
    <ul><span style="font-family: monospace;">



(</span><i style="font-family: monospace;"> </i><span style="font-family: monospace;">\&nbsp;</span><i style="font-family: monospace;"> x.</i><span style="font-family: monospace;">&nbsp;</span><i style="font-family: monospace;"> </i><span style="font-family: monospace;">( \&nbsp;</span><i style="font-family: monospace;">
y.&nbsp; y </i><span style="font-family: monospace;">+1) </span><i style="font-family: monospace;">x</i><span style="font-family: monospace;"> ) </span><br style="font-family: monospace;"><span style="font-family: monospace;">



=&gt;&nbsp;</span><i style="font-family: monospace;"> </i><span style="font-family: monospace;">(</span><i style="font-family: monospace;"> \</i><span style="font-family: monospace;">&nbsp;</span><i style="font-family: monospace;"> y. y+</i> 1)
    
    
    
    </ul>



  
  
  
  </ul>



</ul>



<hr width="100%">
<h4> The order that the beta reductions are applied to a lambda
abstraction can have an effect on the final result.</h4>



<blockquote>Application-Order (pass by value): <br>



( ( \&nbsp;<i> x. </i>* <i>x x </i>)&nbsp; ( + 2 3) ) <br>



=&gt; ( ( \&nbsp;<i> x. </i>* <i>x x </i>) 5 ) <br>



=&gt; ( * 5 5) <br>



=&gt; 25
  
  
  
  <p>Normal Order (pass by name): <br>



(( \&nbsp;<i> x. </i>* <i>x x </i>) ( + 2 3)) <br>



=&gt; (* (+ 2 3 )( + 2 3)) <br>



=&gt; (* 5 ( + 2 3)) <br>



=&gt; (* 5 5) <br>



=&gt; 25</p>



</blockquote>



<ul>



  <li> Now consider :</li>



  
  
  
  <ul>



&nbsp;<span style="color: rgb(255, 102, 102); font-weight: bold;">( \y . 2)</span><span style="font-weight: bold;">&nbsp; </span><span style="color: rgb(0, 102, 0); font-weight: bold;">(<span style="text-decoration: underline;">(\
x.&nbsp; x x )</span> <span style="text-decoration: underline;">( \&nbsp;
x.&nbsp; x x )</span>)</span>&nbsp;&nbsp;
  
  
  
  </ul>



</ul>



<ul>



  
  
  
  <ul>



  
  
  
  </ul>



</ul>



<ul>



  <li> Beta reduction on (<span style="color: rgb(153, 0, 0);">( \</span><i style="color: rgb(153, 0, 0);"> x. x x </i><span style="color: rgb(153, 0, 0);">)</span> <span style="color: rgb(0, 0, 153);">( \</span><i style="color: rgb(0, 0, 153);"> x.&nbsp;</i><span style="color: rgb(0, 0, 153);"> </span><i style="color: rgb(0, 0, 153);">x x </i><span style="color: rgb(0, 0, 153);">)</span> ) goes into "an infinite loop".</li>



  
  
  
  <dl>



    <dd><br>



(<span style="color: rgb(153, 0, 0);">( \</span><i style="color: rgb(153, 0, 0);"> x. x x </i><span style="color: rgb(153, 0, 0);">)</span> <span style="color: rgb(0, 0, 153);">( \</span><i style="color: rgb(0, 0, 153);"> x.&nbsp;</i><span style="color: rgb(0, 0, 153);"> </span><i style="color: rgb(0, 0, 153);">x x </i><span style="color: rgb(0, 0, 153);">)</span> ) ~&gt; (<span style="color: rgb(153, 0, 0);"></span><span style="color: rgb(153, 0, 0);"></span><span style="color: rgb(0, 0, 153);">( \</span><i style="color: rgb(0, 0, 153);"> x.&nbsp;</i><span style="color: rgb(0, 0, 153);"> </span><i style="color: rgb(0, 0, 153);">x x </i><span style="color: rgb(0, 0, 153);">)</span> <span style="color: rgb(153, 0, 0);"></span><span style="color: rgb(153, 0, 0);"></span><span style="color: rgb(0, 0, 153);">( \</span><i style="color: rgb(0, 0, 153);"> x.&nbsp;</i><span style="color: rgb(0, 0, 153);"> </span><i style="color: rgb(0, 0, 153);">x x </i><span style="color: rgb(0, 0, 153);">)</span> )<br>



      <br>



    </dd>



  
  
  
  </dl>



  
  
  
  <ul>



    <li> Thus, if you attempt an application-order evaluation on <br>



    </li>



  
  
  
  </ul>



  
  
  
  <dl>



    <dd>((
\&nbsp;<i> y. </i>2)(( \&nbsp;<i> x.&nbsp;</i> <i>x
x </i>) ( \&nbsp;<i> x.&nbsp;</i> <i>x x </i>)))
the result is undefined.</dd>



  
  
  
  </dl>



  
  
  
  <ul>



  
  
  
  </ul>



</ul>



<ul>



  <li> However, using normal order evaluation on <br>



  </li>



  
  
  
  <dl>



    <dd>(<span style="color: rgb(204, 0, 0);"> ( \<span style="font-style: italic;">y</span> . 2)</span>&nbsp; <span style="color: rgb(0, 102, 0);">((\</span><i style="color: rgb(0, 102, 0);">
x.&nbsp;</i><span style="color: rgb(0, 102, 0);"> </span><i style="color: rgb(0, 102, 0);">x x </i><span style="color: rgb(0, 102, 0);">) ( \&nbsp;</span><i style="color: rgb(0, 102, 0);">
x.&nbsp;</i><span style="color: rgb(0, 102, 0);"> </span><i style="color: rgb(0, 102, 0);">x x </i><span style="color: rgb(0, 102, 0);">))</span>&nbsp; ) </dd>



  
  
  
  </dl>



  <dd>we get the value 2.</dd>



  <br>



&nbsp; <li> The<b> Church-Rosser Theorem</b>&nbsp; proves that lambda
expressions can always be reduced using normal order to a normal order
form that cannot be reduced further. This gives us a way to compare
functions. A practical application implication is that functional
language translators can substitute a function by a more efficient and
equivalent function.</li>



  
  
  
  <ul>



    <li> A term is said to be <i>normal form</i> if <b>no </b>beta
reductions apply; i.e. there is no subterms of the form ( \<i> x.&nbsp;</i>
      <i>M </i>)<i>N</i></li>



    <li> The <i>normal form</i> corresponds roughly to a halting
configuation of a Turing machine.</li>



    <li> The term (\&nbsp;<i> x. x x </i>)
(
\&nbsp;<i> x.&nbsp;</i> <i>x x </i>) has no normal form.</li>



    
    
    
    <ul>



&nbsp;
    
    
    
    </ul>



  
  
  
  </ul>



  <li> Note: Haskell's Type checking rejects (lambda x. x x) but lisp
and Scheme do not.</li>



  
  
  
  <ul>



...&gt; :t (\x -&gt; x x) <br>



ERROR: Type error in application <br>



*** expression&nbsp;&nbsp;&nbsp;&nbsp; : x x <br>



*** term&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
x <br>



*** type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :
a -&gt; b <br>



*** does not match : a <br>



*** because&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : unification
would give infinite type
  
  
  
  </ul>



</ul>



<hr width="100%">
<h3> Booleans</h3>



<ul>



  <li> Define two functions:</li>



  
  
  
  <pre><b>true<br><font color="#000099">T</font></b> "="&nbsp; (\x.&nbsp; \y. x)</pre>



  
  
  
  <pre>(in Haskell: (\x y -&gt; x))</pre>



  
  
  
  <pre><b>false<br><font color="#990000">F</font></b> "="&nbsp; (\x.&nbsp; \y. y)</pre>



  
  
  
  <pre>(in Haskell: (\x y -&gt; y))</pre>



  <li> Then define <br>



  </li>



  
  
  
  <pre>if a then b else c "="&nbsp; \z. (a z) (b z) (c z)<br></pre>



  
  
  
  <ul>



    
    
    
    <pre>Given "(if a then b else c) z " which is <br>(\ z. (a z) (b z) (c z)) z and assuming <tt>(a z) ~&gt; <b><font color="#000099">T</font></b></tt><br>we compute the following:<br><br>(\ z. (a z) (b z) (c z)) z <br>=&gt; (a z) (b z) (c z)<br>=&gt; ( \ x.&nbsp; \ y. x) (b z) (c z)&nbsp;<br>=&gt; ( \ y. (b z)) (c z)&nbsp;<br>=&gt; (b z)</pre>



  
  
  
  </ul>



  <li> <b>NOT&nbsp;&nbsp;&nbsp; </b>=&nbsp;&nbsp; ( \<i> w</i>. <i>w
    </i><b><font color="#990000">F</font><font color="#000099"> T</font>
)</b></li>



  
  
  
  <ul>



&nbsp;=&nbsp;&nbsp; ( \ <i>w</i>. <i>w </i>( \
x.&nbsp; \ y. y) ( \ x.&nbsp; \ y. x) )<br>



  
  
  
  </ul>



  
  
  
  <dl>



    <dd>
      
      
      
      <table style="text-align: left;" border="0" cellpadding="0" cellspacing="15">



        <caption><br>



Example:&nbsp;&nbsp; NOT&nbsp; <font color="#000099">T</font><br>



        </caption><tbody>



          <tr>



            <td style="vertical-align: top;">=&gt;&nbsp; ( \ <i>w</i>.&nbsp;
            <i>w </i><b><font color="#993300">F</font><font color="#000099"> T</font></b> ) <b><font color="#000099">T</font></b>
            </td>



            <td style="vertical-align: top;">Definition of Not<br>



            </td>



          </tr>



          <tr>



            <td style="vertical-align: top;">=&gt;<b> T F T</b></td>



            <td style="vertical-align: top;">Apply T to the lambda term<br>



            </td>



          </tr>



          <tr>



            <td style="vertical-align: middle;">=&gt; (\ x.&nbsp; \ z.
x)
F T<br>



            </td>



            <td style="vertical-align: top;">Expand T<br>



Apply alpha rule<br>



            </td>



          </tr>



          <tr>



            <td style="vertical-align: middle;">=&gt; ( \ z. F) T<br>



            </td>



            <td style="vertical-align: top;">Apply F to the lambda term<br>



            </td>



          </tr>



          <tr>



            <td style="vertical-align: middle;">=&gt; (\z.&nbsp; (\
x.&nbsp; \ y. y) ) T<br>



            </td>



            <td style="vertical-align: top;">Expand F<br>



            </td>



          </tr>



          <tr>



            <td style="vertical-align: middle;">=&gt; (\ x.&nbsp; \ y .
y) </td>



            <td style="vertical-align: top;">Apply T to lambda term<br>



            </td>



          </tr>



          <tr>



            <td style="vertical-align: top;">=&gt; <b>F</b></td>



            <td style="vertical-align: top;">Definition of F<br>



            </td>



          </tr>



        
        
        
        </tbody>
      
      
      
      </table>



    </dd>



  
  
  
  </dl>



</ul>



<hr width="80%">
<ul>



  <li> <a name="lambdaOne"></a>We shows how to express integers as
lambda abstractions.&nbsp; We define what integer 0 looks like and a
function <i>successor</i> that is applied recursively <i>k</i>+1
times
to produce the <i>k</i>'s integer.&nbsp; Therefore each integer in
lambda calculus is in fact a function. (Underline indicates what will
be changed.)<br>



  </li>



</ul>



<blockquote><b>zero</b> = \ s&nbsp; . \ z . z <br>



  <b>successor</b> = \ n. \s. \ z ( s (( n s ) z ) ). <br>



one =&nbsp; \ s. \ z ( s z) <br>



two =&nbsp; \ s. \z ( s (s z))&nbsp; <br>



  <br>



  
  
  
  <table style="text-align: left;" border="0" cellpadding="5" cellspacing="3">



    <caption>
    
    
    
    <h4>one ??=?? <font color="#990000">successor&nbsp;</font> <font color="#000099">zero</font></h4>



    <small> Apply <span style="color: rgb(204, 0, 0);">successor</span>
function to <span style="color: rgb(0, 0, 153);">zero</span><br>



Replace words with lambda terms</small><br>



    
    
    
    <h4> <font color="#990000">successor</font> <font color="#000099">zero</font>
&nbsp; =&nbsp;&nbsp; \<font color="#990000"> n. \
s. \ z ( s ( ( n s
) z ) )</font> <font color="#000099">(\
s&nbsp; . \ z . z)<br>



    </font><br>



    </h4>



    </caption><tbody>



      <tr>



        <td style="text-align: left; vertical-align: middle; white-space: nowrap;">=&gt;
\<font color="#990000"><u>
n</u>. \
s. \ z ( s ( ( <span style="text-decoration: underline;">n</span> s
) z ) )</font> <u><font color="#000099">(\
s'&nbsp; . \ z . z)</font></u><font color="#000099">&nbsp; </font><u><font color="#000099"><br>



        </font></u></td>



        <td style="vertical-align: top;">1) <span style="font-style: italic;">n</span> to be replaced by lambda term<br>



&nbsp; &nbsp;&nbsp; <u><font color="#000099">(\
s'&nbsp; . \ z . z)</font></u>&nbsp; <br>



&nbsp;&nbsp; and rename <span style="color: rgb(51, 51, 255);">zero's</span>
s to s'.<br>



        </td>



      </tr>



      <tr>



        <td style="vertical-align: middle;"> =&gt; \ s. \
z ( s (&nbsp; <u>( <span style="color: rgb(204, 0, 0);">\ s'&nbsp; .
\ z . z</span>) s)</u>&nbsp; z) </td>



        <td style="vertical-align: top;">2) The result is<br>



&nbsp;&nbsp; <u>( <span style="color: rgb(204, 0, 0);">\ s'&nbsp; . \
z . z</span>)</u> <br>



&nbsp; Now apply<br>



&nbsp;&nbsp; <u><span style="color: rgb(204, 0, 0);">\ s'&nbsp; . \ z
. z</span></u> to&nbsp; s <br>



        </td>



      </tr>



      <tr>



        <td style="vertical-align: middle;"> =&gt;&nbsp; \ s. \ z ( s <u>(
\z' . z')
z)</u> )</td>



        <td style="vertical-align: top;">3) The result is <u>( \z . z)</u>.&nbsp;
        <br>



&nbsp; Rename z to z'<br>



&nbsp; Now apply <u>( \z' . z')</u> to z.<br>



        </td>



      </tr>



      <tr>



        <td style="vertical-align: middle;">=&gt; \ s. \ z ( s z ) </td>



        <td style="vertical-align: top;">one's representation<br>



        </td>



      </tr>



    
    
    
    </tbody>
  
  
  
  </table>



  
  
  
  <p> </p>



  <li> <b>iszero<i> </i></b>(x)&nbsp;&nbsp; =&nbsp;&nbsp; (\ x. x <b>F</b>
    <b>NOT F</b>)</li>



  <br>



&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; =&gt;&nbsp; (\ x. x <span style="color: rgb(153, 0, 0);">(\ x.&nbsp; \ y. y)&nbsp;</span> <span style="color: rgb(0, 0, 153);">( \ </span><i style="color: rgb(0, 0, 153);">w</i><span style="color: rgb(0, 0, 153);">. </span><i style="color: rgb(0, 0, 153);">w</i><span style="color: rgb(0, 0, 153);"> (\
x.&nbsp; \ y. y) (\ x.&nbsp; \ y. x)</span> ) <span style="color: rgb(153, 51, 0);">(\ x.&nbsp; \ y. y)</span>
  
  
  
  <blockquote> <li> Example: <b>iszero</b> (0) = (\x. x <b>F NOT F</b>)<b>
(</b>\ s&nbsp; . \ z . z)</li>



    
    
    
    <blockquote>=&gt; (\ s&nbsp; . \ z . z) <b>F NOT F</b> <br>



=&gt; (\ z . z)&nbsp;<b> NOT F</b> <br>



=&gt;<b> NOT F</b> <br>



=&gt;<b> T</b></blockquote>



  </blockquote>



</blockquote>



<ul>



  <li> Addition can be defined as</li>



&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">\ w. \ z.
\ y.&nbsp; \x . ((wy) ((xy) z) </span> <br>



  <li>Multiplication can be defined as <br>



  </li>



&nbsp;&nbsp;<span style="font-weight: bold;"> \ w. \ z. \ y&nbsp; w (zy)</span>
</ul>



<ul>



These interpretations of booleans and positive integers in <i>lambda</i>
calculus allow us to write functions such as&nbsp; <tt>Hfact&nbsp;</tt>
(below)&nbsp; entirely in <i>lambda</i> notation.
</ul>



<hr width="100%">
<h3> Properties of functions</h3>



<ul>



  <li> A <b><i>function f</i></b> is a rule that takes an input value
x
and returns a value f (x) or f&nbsp; x</li>



  
  
  
  <ul>



    <li> The inputs x belong to a set X (called the<b> domain </b>of f
).</li>



    <li> The values y = f (x) belong to a set Y (called the <b>range</b>(co-domain)
of&nbsp; f&nbsp; ).<br>
      <br>
</li>



  
  
  
  </ul>
  <li>A function<span class="Apple-converted-space">&nbsp;</span><tt style="color: rgb(0, 0, 0); font-style: italic; font-variant: normal; font-weight: bold; letter-spacing: normal; line-height: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; background-color: rgb(255, 255, 255);">f</tt><span style="font-weight: bold; font-style: italic;" class="Apple-converted-space">&nbsp;</span>is said to be<span class="Apple-converted-space">&nbsp;</span><i style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-variant: normal; font-weight: bold; letter-spacing: normal; line-height: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; background-color: rgb(255, 255, 255); font-size: medium;">strict</i><span class="Apple-converted-space">&nbsp;</span>if, when applied to a nonterminating expression, it also fails to terminate.<br>
    <br>
  </li>




  <li> <b><i>Referential transparency </i></b>is the property that
appling&nbsp; <b><i>f </i></b>to an object <b><i>a</i></b> will
always
result in the same object <i>f </i>(<i>a</i>).</li>



</ul>



<ul>



  <li> <i>one-to-one </i>(<i>injective</i>) function has the property
if <i>f </i>( <b><i>a </i></b>) =&nbsp; <i>f </i>(<i><b>b </b>)</i>
then<i> a </i>equals<i>
b</i>.<br>
    <br>
</li>



  <li> <i><font color="#3333ff">fix point</font> property </i>of a<i>
value:</i></li>



</ul>



<dl style="margin-left: 40px;">



  <dd>A function<i>&nbsp; <b>f&nbsp; </b></i>whose domain and
range overlap often have one or more common <b>domain-range </b>value<b><i>
a</i></b>
with the property&nbsp; <b><i>f</i> (<i> a</i> ) = <i>a. </i></b>These
values are called&nbsp; <b><i>fixed points.</i></b></dd>



</dl>



<ul>



  <li> <b>You should be aware that the domain and range can be
themselves sets of functions.</b></li>



  <br>



  
  
  
  <hr width="100%">
</ul>



<h3> Meaning of recursion</h3>



<ul>



  <li> WHAT DOES RECURSION MEAN?</li>



  <li> You know what a recursive function looks like:</li>



  
  
  
  <pre>length x = if x == [] then 0 else 1 + length (tail x)</pre>



  <li> How do we write this as a lambda abstraction?</li>



  
  
  
  <pre>(\x -&gt; if x == [] then 0 else 1 + ???(tail x))</pre>



</ul>



<h3> What do we do with the ??? ?</h3>



<ul>



  <li> Recursion is vital to functional programming and lambda-calculus
is a model for such calculation</li>



  <li> Defining recursion is a challenge&#8230;</li>



  <li> Consider a new non-recursive function</li>



  
  
  
  <pre>H<sub>len</sub> :: :: (Num u, Eq t) =&gt; ([t] -&gt; u) -&gt; [t] -&gt; u <br>H<sub>len</sub> = (\f x -&gt; if x == [] then 0 else 1 + (f (tail x)))</pre>



</ul>



<h3> H<sub>len</sub> length = length</h3>



<ul>



  <li> How does H work?</li>



  <li> Try it on the function &#8220;sum&#8221;</li>



  
  
  
  <pre>H<sub>len</sub> sum [4,5,6] =&gt; 1 + sum [5,6] =&gt; 1 + 11 =&gt; 12</pre>



  <li> This is not much to do with &#8220;sum&#8221;</li>

  <li>Try it on the function "head"
    
    <pre>H<sub>len</sub> head [4,5,6] =&gt; ???<br></pre>

  </li>

  <li> However, if we knew what &#8220;length&#8221; was, we would have</li>



  
  
  
  <pre>H<sub>len</sub> length [4,5,6] =&gt; 1 + length [5,6] =&gt; 3</pre>



</ul>



<h3> Fixed-points of <i>H<sub>len</sub></i> is the function <i>length</i></h3>



<ul>



  <li> In fact <i>H<sub>len</sub></i> <i>length</i> = <i>length</i>
and
&#8220;length&#8221; is the only function like that</li>



  
  
  
  <ul>



    <li> <i>length</i> is defined to be the function f that satisfies
Hlen f = f</li>



  
  
  
  </ul>



  <li> We do not get into the conditions when such a fixed-point of <b>Hlen</b>
exists
here</li>



  <li> Another example is <i>factorial</i>.</li>



  <li> Our text book shows another example, <i>gcd.</i></li>



</ul>



<h3> Factorial</h3>



<ul>



  
  
  
  <pre>factorial n = if n ==0 then 1 else n * (factorial (n - 1))</pre>



  <li> An attempt to write lambda abstraction to compute factorial:</li>



  
  
  
  <pre>(\n -&gt; if n == 0 then 1 else n * ???(n-1))</pre>



  <li> Define the lambda abstraction &nbsp; Hfact by</li>

</ul>

<dl>

  <dd>
    
    <pre>Hfact :: (Int-&gt;Int)-&gt;Int-&gt;Int<br><span style="font-family: monospace;">Hfact = \ f&nbsp;n -&gt; (if n==0 then 1 else n * f (n-1))</span></pre>

  </dd>

</dl>

<ul>

  
  <pre></pre>



</ul>



<h3> Applying H<sub>fact</sub></h3>



<ul>



  <li>Apply H<sub>fact</sub> to ( ^ 2)</li>

</ul>

<dl>

  <dd><span style="font-family: monospace;">H</span><sub style="font-family: monospace;">fact </sub><span style="font-family: monospace;">(^ 2) 4 =&gt; ??</span></dd>

</dl>

<ul>

  <li> Apply H<sub>fact</sub> to the Fibonacci function:</li>



  
  
  
  <pre>H<sub>fact</sub> fib = (\n -&gt; if n==0 then 1 else n * fib(n-1))</pre>



  
  
  
  <pre>e.g. H<sub>fact</sub> fib 5 = 5*fib 4 = 5*3=15</pre>



not much to do with fib, <br>

  <br>



  
  <li>but if we had a factorial function fact we
would have <br>



    </li>

  
  <ul>



    

  
  
  
  </ul>



  
  
  
  <dl>



    <dd><br>



Hfact fact = (\n -&gt; if n == 0 then 1 else n * fact(n-1) </dd>



  
  
  
  </dl>



</ul>



<h3> General definition</h3>



<ul>



  <li> Here</li>



  
  
  
  <pre>H<sub>fact</sub> fact is fact,</pre>



i.e. the factorial function is the &#8220;smallest&#8221; fixed point of H<sub>fact<br>



  <br>



  </sub> <li> In general, to give meaning to the recursive function</li>



  
  
  
  <pre>f = (\ x. if (cond(x)) then val(x) else expr(f, x))</pre>



(which cannot be expressed in lambda-notation), we define
  
  
  
  <pre>H<sub>f</sub> =(\ F. \ x. if (cond(x)) then val(x) else expr(F, x))</pre>



</ul>



<h3> The fixed-point combinator</h3>



<ul>



  <li> The function f is the unique &#8220;least&#8221; fixed-point of H<sub>f</sub></li>



  <li> There is a lambda-expression that returns the fixed-point called
the fixed-point combinator (at least Y exists in untyped
lambda-calculus):</li>



  
  
  
  <pre>Y = (\ h. <span style="text-decoration: underline;">(\ x. h (x x))</span> <span style="text-decoration: underline;">(\ x. h (x x)</span>))<br></pre>

  
  <pre></pre>



</ul>



<h3> factorial = Y H<sub>fact</sub></h3>



<ul>



  <li> Consider:</li>



  
  
  
  <pre>Y = (\ h. (\ x. h (x x)) (\ y. h (y y)))</pre>



  <li> Substitution on both sides shows that Y H = H (Y H) so that Y H
is a fixed point of H.</li>



  <li> You can also check that:</li>



  
  
  
  <pre>Y H<sub>fact</sub> n = if n == 0 then 1 else n * Y H<sub>fact</sub> (n - 1)</pre>



  <li> So</li>



  
  
  
  <pre>factorial = Y H<sub>fact</sub></pre>



</ul>



<h3> The fixed point does not always exist</h3>



<ul>



  <li> Existence of a &#8220;least&#8221; fixed point is subtle and we have not
proved its existence here</li>



  <li> Clearly some recursive functions are not really defined and
would
not be fixed points of an operator, e.g.</li>



  
  
  
  <pre>f  = \ n -&gt; if n == 0 then 1 else f (abs n + 1)</pre>



  <li> Only defined for n=0, not defined for any positive or negative n</li>



</ul>



<hr noshade="noshade" size="2" width="35%">
<h3>How it works in Haskell</h3>



<ul>



  <li>Here is the recursive factorial code:<br>



  </li>



</ul>

<span style="font-family: monospace;">

&gt; factorial :: Int-&gt;Int</span><br style="font-family: monospace;">

<span style="font-family: monospace;">

&gt; factorial n </span><br style="font-family: monospace;">

<span style="font-family: monospace;">

&gt;&nbsp;&nbsp; = if (n == 1) then 1 else n * factorial(n-1)</span>
<ul>



  <li>Lets write a non-recursive function that does the first "step" of a function f.
    <br>



  </li>



  <li>If f is factorial then it does the first step of factorial.</li>



</ul>

<span style="font-family: monospace;">

&gt; hFactStep :: (Int-&gt;Int)-&gt;Int-&gt;Int</span><br style="font-family: monospace;">

<span style="font-family: monospace;">

&gt; hFactStep = \ f n -&gt; if n==0 then 1 else n * f (n-1)</span><br style="font-family: monospace;">



<br>



<ul>



  <li>We can define factorial' as follows:</li>



</ul>



<dl>



  <dd>&gt; factorial' =&nbsp;hFactStep factorial'</dd>



</dl>



<ul>



  <li>An example evaluation :&nbsp;</li>



</ul>



<dl>



  <dd>
    
    
    
    <pre wrap=""><span style="text-decoration: underline;">factorial'</span> 2  ~&gt;</pre>



  </dd>



  <dd>
    
    
    
    <pre wrap=""><span style="text-decoration: underline;">hFactStep </span>factorial' 2 ~&gt;</pre>



  </dd>



  <dd>
    
    
    
    <pre wrap=""><span style="text-decoration: underline;">if ( 2 == 0) then 1 else 2 * </span>factorial' (2-1) ~&gt;</pre>



  </dd>



  <dd>
    
    
    
    <pre wrap="">2 * <span style="text-decoration: underline;">factorial'</span> 1 ~&gt;</pre>



  </dd>



  <dd>
    
    
    
    <pre wrap="">2 * (<span style="text-decoration: underline;"> hFactStep</span> factorial' 1 ) ~&gt;</pre>



  </dd>



  <dd>
    
    
    
    <pre wrap="">2 * (<span style="text-decoration: underline;">if( 1 == 0) then 1 else 1 *</span> factorial' (1-1)) ~&gt;</pre>



  </dd>



  <dd>
    
    
    
    <pre wrap="">2 * ( 1* <span style="text-decoration: underline;">factorial</span>' 0) ~&gt;</pre>



  </dd>



  <dd>
    
    
    
    <pre wrap="">2 * ( 1 * (<span style="text-decoration: underline;">hFactStep </span>factorial' 0) ) ~&gt;</pre>



  </dd>



  <dd>
    
    
    
    <pre wrap="">2 * ( 1 * <span style="text-decoration: underline;">if( 0 == 0) then 1 else n </span>* factorial' (1-n)) ~&gt;</pre>



  </dd>



  <dd>
    
    
    
    <pre wrap="">2 * ( 1 * ( 1))</pre>



  </dd>



  <dd>~&gt; 2<br>



  </dd>



</dl>



<ul>



  <li>Remember that if <i>x = f x</i> then <i>x is the fix point of f</i>
&nbsp;</li>



  
  
  
  <ul>



    <li>In this case factorial is the fix point of hFactStep!</li>



    <li>So hFactStep factoral equals factorial</li>



  
  
  
  </ul>



</ul>



<ul>



  <li>We can rewrite all recursive functions in this form.&nbsp;</li>



  <li>Now we can define our fix point operator ( Haskells equivalent Y combinator)<br>



  </li>



</ul>



<dl>



  <dd>
    
    
    
    <pre wrap="">&gt; fix f = f (fix f )<br></pre>



  </dd>



</dl>



<ul>



  <li>This looks like a recursive definition again, but if you want a
system without explicit recursion you have to disallow this as a
function. In such a system, fix is a builtin operator, and the equation
can be seen as a rewrite rule that lets you reason about the evaluation
of expressions that contain it.</li>



  <li>So now we can define an non recursive factorial"" using fix as follows:</li>



</ul>



<dl>



  <dd>
    
    
    
    <pre wrap="">&gt; <span style="text-decoration: underline;">factorial"</span> = fix hFactStep&nbsp;</pre>



  </dd>



</dl>



<ul>



  <li>Redoing the example:</li>



</ul>



<dl>



  <dd>
    
    
    
    <pre wrap=""><span style="text-decoration: underline;">factorial"</span> 2  ~&gt;</pre>



  </dd>



  <dd>
    
    
    
    <pre wrap=""><span style="text-decoration: underline;">fix hFactStep</span> 2 ~&gt;</pre>



  </dd>



  <dd>
    
    
    
    <pre wrap=""><span style="text-decoration: underline;">hFactStep </span>(fix hFactStep) 2 ~&gt;</pre>



  </dd>



  <dd>
    
    
    
    <pre wrap=""><span style="text-decoration: underline;">if ( 2 == 0) then 1 else 2 * </span>(fix hFactStep) (2-1) ~&gt;</pre>



  </dd>



  <dd>
    
    
    
    <pre wrap="">2 * (<span style="text-decoration: underline;">fix hFactStep</span>) 1 ~&gt;</pre>



  </dd>



  <dd>
    
    
    
    <pre wrap="">2 * ( <span style="text-decoration: underline;">hFactStep</span> (fix hFactStep) 1 ) ~&gt;</pre>



  </dd>



  <dd>
    
    
    
    <pre wrap="">2 * (<span style="text-decoration: underline;">if ( 1 == 0) then 1 else 1 </span>* (fix hFactStep) (1-1)) ~&gt;</pre>



  </dd>



  <dd>
    
    
    
    <pre wrap="">2 * ( 1* (<span style="text-decoration: underline;">fix hFactStep</span>) 0) ~&gt;</pre>



  </dd>



  <dd>
    
    
    
    <pre wrap="">2 * ( 1 * (<span style="text-decoration: underline;">hFactStep </span>(fix hFactStep) 0) ) ~&gt;</pre>



  </dd>



  <dd>
    
    
    
    <pre wrap="">2 * ( 1 *<span style="text-decoration: underline;"> if( 0 == 0) then 1 else n *</span> (fix hFactStep) (n-1)) ~&gt;</pre>



  </dd>



  <dd>
    
    
    
    <pre wrap="">2 * ( 1 * ( 1)) ~&gt; 2</pre>



  </dd>



</dl>



<ul>



  <li>Each occurence of "fix hFactStep" above is in a sense the same,
and could evaluate in the same way. But since the expression is a
function (in this case), how it actually behavor depends on its
arguments.</li>



  <li>Because Haskell is lazy, and there's no structure sharing between
the occurences, each occurence is only expanded as often as necessary.</li>



</ul>



<ul>



</ul>



<ul>



</ul>



<ul>



</ul>



<hr width="100%">
<h3> What is great about the function model (also the Logical model)
for
computing verses the imperative model?</h3>



How does the functional scale?
<blockquote>
  
  
  
  <blockquote><font size="-2"><u>References</u>:</font> <br>



    <font size="-2">Fischer, Alice E. and Grodzinsky, Frances S. <i>The
Anatomy of Programming Languages</i>, Prentice Hall 1993</font> <br>



    <font size="-2">Kogge, Peter M <i>The Architecture of Symbolic
Computers</i>, McGraw-Hill Series, 1991</font> <br>



    <font size="-2">Stark, Richard <i>LISP, Lore and Logic</i>,
Springer-Verlag,1990</font> <br>



    <font size="-2">Louden, Kenneth C. <i>Programming Languages
Principles and Practice</i>, PWS Publishing Company, 1993</font> <br>



    <font size="-2">Scott, Michael, <i>Programming Language
Pragmatics, </i>Morgan Kaufmann, 2000</font> <br>



    <font size="-2">Kozen, Dexter, <i>Autmata and Computability</i>,
Springer, 1997</font><br>



    </blockquote></blockquote>



<br>



<br>



<br>



</body></html>