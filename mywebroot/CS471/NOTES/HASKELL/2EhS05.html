<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Lazy Evaluation</title>



<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"></head><body>
<center>
<h3> Haskell 2</h3></center><h4> Propose:</h4>
<ul>
<li>Understand why lazy evaluation works in functional languages<br>
</li>
<li> To illustrate a practical application lazy evaluation.</li>
<li>To illustrate strict functions<br>
</li>
<li>Understand why tail recursion is important.<br>
</li>
</ul>
<h3>
<hr align="left" noshade="noshade" size="4" width="100%"></h3>
<h3> Parameter Passing Revisited -- Evaluation policies <br>
</h3>
The basic strategy:<br>
<div style="margin-left: 40px;">Substitute each argument
for occurences
of its parameter in the function body.</div>
leaves open the when the substitution should take place!<br>
<span style="font-weight: bold;"><br>
<span style="font-weight: bold;">Applicative order/
Innermost </span></span>evaluation
policy:<br>
<ol>
<li>Evaluate each argument to obtain its value</li>
<li>Substitute each argument value for each occurence of the
corresponding parameter in the body <br>
</li>
<li>Evaluate the function which is then the value of the
application</li>
</ol>
<div style="margin-left: 40px;"><span style="font-weight: bold;">Example:<br>
</span><span style="font-family: monospace;">2 + <span style="font-weight: bold;">(\x -&gt; (x&nbsp; +
3) / (6 - x))</span> (7 - 2)</span><br style="font-family: monospace;">
<span style="font-family: monospace;">~&gt; 2 + (\x
-&gt; (x + 3) / (6
- x))&nbsp; 5</span><br style="font-family: monospace;">
<span style="font-family: monospace;">~&gt; 2 + ((5
+3) /(6 -5))</span><br style="font-family: monospace;">
<span style="font-family: monospace;">~&gt; 2 +( 8/1 )<br>
</span>~&gt;&nbsp;&nbsp; 2 + 8<br style="font-family: monospace;">
<span style="font-family: monospace;">~&gt; 10</span><br>
<span style="font-weight: bold;"><span style="font-weight: bold;"></span><br>
</span></div>
<ul>
<li>"call by value"&nbsp; </li>
</ul>
<span style="font-weight: bold;">Normal order/Outermost </span>evalution
policy
<ol>
<li> Substitute each argument - <i>unevaluated- </i>for
each
occurence of the corresponding parameter in the body</li>
<li> Evaluate the resulting expression, evaluating each
subexpression <i> only</i> when and <i>if</i>&nbsp;
its value is <i>needed.</i><span style="font-weight: bold;"></span></li>
</ol>
<dl>
<dd><span style="font-weight: bold;">Example</span>:&nbsp;</dd>
<dd><span style="font-family: monospace;">2 + <span style="font-weight: bold;">(\x -&gt; (x&nbsp; + 3)
/ (6 - x))</span> (7 - 2 )<br>
~&gt; 2 + (((7 - 2) +3) / (6 -(7-2))<br>
~&gt; 2 + ((5 +3) /(6 - (7-2))<br>
~&gt; 2 + (8 / (6 - (7-2))<br>
~&gt; 2 + (8 / (6 - 5))<br>
~&gt; 2 + (8 /1)<br>
~&gt; 2 + 8<br>
~&gt; 10</span></dd>
<dt><br>
</dt>
</dl>
<ol>
</ol>
<span style="font-weight: bold;"></span>
<h4> The Church-Rosser Theorem</h4>
<ul>
<li> For any expression for which <i>applicative order
evaluation
and normal order evaluation</i> both succeed, they get the same
results.</li>
<li> Do functions always return a value?</li>
<li>Bottom (_|_) denotes the "value" of an expression which
does not
return a value, <br>
</li>
<ul>
<li>either because it loops endlessly or because it aborts
due to
an error
such as division by zero. </li>
</ul>
<li>A function is strict in an argument if</li>
<ul>
<li>f&nbsp; bottom = bottom</li>
<li>lazy evaluation =&gt; Haskell has non-strict
functions by
default</li>
</ul>
<dl>
<dd><span style="font-family: monospace;">(\x
-&gt; 99) (3/0)</span></dd>
</dl>
<ul>
<li>In Haskell the operator <span style="font-weight: bold;">$! </span>forces
arguement evaluation i.e. lazy evaluation is replace with applicative
evaluation. (see factS below)</li>
<li>Java, C, and C++ short circuit operators are also
non-strict<br>
Why?</li>
</ul>
<ul>
</ul>
<h4> Normal Order vs Applicative order</h4>
<li> Normal order always succeed when applicative does</li>
<li> AND it succeeds for some expressions that applicative
order fails</li>
<br>
<tt>Example:<br>
<br>
<span style="font-weight: bold;">(\x y -&gt; if x
then 7 else 2 * y)
(3&gt;1) (7/0)</span></tt><br>
Normal order/Outermost:<tt><br>
~&gt; if <span style="text-decoration: underline;">3&gt;1</span>
then
7 else 2 * (7/0)<br>
~&gt; if true then 7 else 2 * (7/0)<br>
~&gt; 7</tt><br>
Applicative order/Innermost fails<tt><br>
~&gt; (\x y -&gt; if x then 7 else 2*y) true <span style="text-decoration: underline;">(7/0)</span><br>
~&gt; (\x y -&gt; if x then 7 else 2*y) true <span style="font-style: italic;">bottom<br>
~&gt; bottom </span>("undefined")<br>
</tt>
</ul>
<tt> </tt>
<ul>
<li> The price of Normal order
evaluation is additional computation.</li>
<br>
<tt>Example:</tt><br>
<tt>cube = <span style="font-weight: bold;">\x
-&gt; x * x * x</span></tt><br>
<tt>Evaluate: cube (cube 2)</tt>
<p><tt>Applicative order/Innermost evaluation:</tt>
<br>
<tt>cube (cube 2)</tt> <br>
<tt>~&gt; cube( <span style="text-decoration: underline;">2 * 2</span>
* 2)</tt> <br>
<tt>~&gt; cube( <span style="text-decoration: underline;">4 * 2</span>)</tt>
<br>
<tt>~&gt; cube(8)</tt> <br>
<tt>~&gt; <span style="text-decoration: underline;">8
* 8</span> * 8</tt> <br>
<tt>~&gt; <span style="text-decoration: underline;">64
* 8</span></tt> <br>
<tt>~&gt; 512</tt> <br>
Only 4 multiplications </p>
<p><tt>Normal order/Outermost evaluation:</tt> <br>
<tt>cube (cube 2)</tt> <br>
<tt>~&gt; cube 2 * cube 2 * cube 2</tt> <br>
<tt>~&gt; <span style="text-decoration: underline;">2
* 2</span> * 2
* cube 2 *cube 2</tt> <br>
<tt>~&gt; <span style="text-decoration: underline;">4
* 2</span> *
cube 2 * cube 2</tt> <br>
<tt>~&gt; 8 * cube 2 * cube 2</tt> <br>
<tt>~&gt; 8 * (<span style="text-decoration: underline;">2
* 2</span>
* 2)&nbsp; * cube 2</tt> <br>
<tt>~&gt; 8 * (<span style="text-decoration: underline;">4
* 2</span>)
* cube 2</tt><br>
<tt>~&gt; <span style="text-decoration: underline;">8
* 8</span> *
cube 2</tt><br>
<tt>~&gt; 64 * cube 2</tt> <br>
<tt>~&gt; 64 * (<span style="text-decoration: underline;">2
* 2</span>
* 2)</tt> <br>
<tt>~&gt; 64 * (<span style="text-decoration: underline;">4
* 2</span>)</tt> <br>
<tt>~&gt; 64 * 8</tt> <br>
<tt>~&gt; 512</tt> <br>
8 multiplications <br>
&nbsp;
WHY?? </p>
<li> <b>Lazy evaluation </b>("call by need") is a
variant of Normal
order evaluation.</li>
<br>
<tt>cube (cube 2)</tt><br>
<tt>~&gt; let x = cube 2 in x * x * x</tt><br>
<tt>~&gt; let x = <span style="text-decoration: underline;">2 * 2</span>
* 2 in x * x * x</tt><br>
<tt>~&gt; let x = <span style="text-decoration: underline;">4 * 2</span>
in x * x * x</tt><br>
<tt>~&gt; let x = 8 in x * x * x</tt><br>
<tt>~&gt; <span style="text-decoration: underline;">8
* 8</span> * 8</tt><br>
<tt>~&gt; 64 * 8</tt><br>
<tt>~&gt; 512</tt><br>
Only 4 multiplications <br>
&nbsp;
<ul>
<li> This way of binding parameters to arguments enable all
occurrences of a parameter to "share" the value of the corresponding
arguments.</li>
<ul>
<li> Each argument evaluated <i>at most
once.</i></li>
<li><i>What is the relationship between lazy
evaluation
and&nbsp; referential transparency?</i></li>
<li><i><span style="font-style: italic;">How
does this relate
to reading Haskell scripts?</span><br>
        </i></li>
</ul>
</ul>
<li> <i>Lazy&nbsp;</i> strategy
combines</li>
<ul>
<li> Applicative&nbsp; strategy's efficiency</li>
<li> Normal strategy's safety</li>
&nbsp;
</ul>
<hr width="100%">
<table width="62%">
<caption>
<center><b>Summary</b></center>
</caption> <tbody>
<tr>
<td>
<center>&nbsp;<b><i><u>Strategy</u></i></b></center>
</td>
<td><br>
</td>
<td>
<div style="text-align: left;"> <b><i><u>Number
of evaluations</u></i></b></div>
</td>
<td> <b><i><u>Safety</u></i></b>
</td>
</tr>
<tr>
<td>
<center>Applicative order evaluation&nbsp; <br>
(call by value)</center>
</td>
<td>
<center>&nbsp;</center>
</td>
<td>&nbsp;exactly 1</td>
<td>&nbsp;least</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>
<center>Normal order evaluation <br>
(outermost) <br>
(call by name)</center>
</td>
<td>
<center>&nbsp;</center>
</td>
<td>&nbsp;0 .. infinity</td>
<td>&nbsp;more</td>
</tr>
<tr>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>
<center>Lazy <br>
(call by need)</center>
</td>
<td>&nbsp;</td>
<td>&nbsp;0 or 1</td>
<td>&nbsp;more</td>
</tr>
</tbody>
</table>
</ul>
<h3>
<hr width="100%">&nbsp;<i>ay </i>?</h3>
<ul>
<li> <tt>ay = 'a' : ay</tt></li>
<li> Is it legal?</li>
</ul>
<hr align="left" noshade="noshade" width="100%">
<hr style="width: 100%; height: 2px;"><br>
</body></html>