<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="Author" content="Les Lander">
  <meta name="GENERATOR"
 content="Mozilla/4.76 [en] (Windows NT 5.0; U) [Netscape]">
  <title>471 Haskell execution -- Tail Recursion</title>
</head>
<body>
&nbsp;
<center>
<table bgcolor="#fffff0" border="1" cellpadding="0" cellspacing="0">
  <tbody>
    <tr>
      <td><a
 href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/9hSpr01.html">previous</a></td>
      <td><a
 href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/10hSpr01.html">&nbsp;next&nbsp;</a></td>
    </tr>
  </tbody>
</table>
</center>
<center>
<h3> Haskell 10</h3>
</center>
<center>
<h3> &copy; Eileen Head, Leslie C. Lander, 2002</h3>
</center>
Purpose:&nbsp; Covered is Tail recursive function.&nbsp; To do informal
type inference.<br>
<h4>
<hr width="100%"></h4>
<h3>Polymorphic type inference <br>
</h3>
<ul>
  <li>Haskell's type-inference system works for polymorphic types. </li>
</ul>
<div style="margin-left: 40px;">Example: <br>
<div style="margin-left: 40px;"><span style="font-family: monospace;">&gt;
foldr f k [] = k </span><br style="font-family: monospace;">
<span style="font-family: monospace;">&gt; foldr f k (x:xs) = f x
(foldr f k xs) </span><br>
</div>
Informally, we note how the parameters are used, and type them
separately (using as many type variables as we need): <br>
<div style="margin-left: 40px;"><span
 style="font-family: monospace; text-decoration: underline;">f ::
a-&gt;b-&gt;c</span> -- a 2 argument function <br>
<span style="font-family: monospace;"><span
 style="text-decoration: underline;">k :: d</span> </span><br>
<span style="font-family: monospace; text-decoration: underline;">[],
(x:xs) :: [e]</span> -- list patterns <br>
<span style="font-family: monospace; text-decoration: underline;">x :: e</span>
-- left argument of (:) <br>
<span style="font-family: monospace; text-decoration: underline;">xs ::
[e]</span><span style="text-decoration: underline;"> </span>-- right
argument of (:) <br>
</div>
</div>
<div style="margin-left: 40px;">so <br>
<div style="margin-left: 40px;"><span
 style="font-family: monospace; text-decoration: underline;">foldr ::
(a-&gt;b-&gt;c) -&gt; d -&gt; [e] -&gt; g </span><br>
</div>
<br>
Then we look for equalities between type variables: <br>
&nbsp; <span style="font-family: monospace;">g = d</span> because
foldr f k [] = k <br>
&nbsp; <span style="font-family: monospace;">e = a</span> because f is
applied to x <br>
&nbsp; <span style="font-family: monospace;">g = b</span> because f is
applied to <span style="font-family: monospace;">(foldr f k xs) </span><br>
&nbsp; <span style="font-family: monospace;">g = c</span> because <span
 style="font-family: monospace;">foldr f k (x:xs) </span><br>
is defined as an application of f <br>
<br>
Eliminating variables, we obtain <br>
foldr :: (a-&gt;b-&gt;b) -&gt; b -&gt; [a] -&gt; b <span
 style="font-weight: bold;"><br>
</span>
<hr style="width: 100%; height: 2px;"><span style="font-weight: bold;"></span></div>
<h3> Clever tricks with auxiliary functions</h3>
<blockquote>
  <pre>&gt; fib :: Int -&gt; Int<br>&gt; fib 1 = 1<br>&gt; fib 2 = 1<br>&gt; fib n = fib (n-2) + fib (n-1)</pre>
  <li> Faster version:</li>
  <pre>&gt; fib1 1 = 1<br>&gt; fib1 n = fiba n 1 0 1<br>&gt;&nbsp;&nbsp; where<br>&gt;&nbsp;&nbsp; fiba n c a b =<br>&gt;&nbsp;&nbsp;&nbsp;&nbsp; if c == n then b<br>&gt;&nbsp;&nbsp;&nbsp;&nbsp; else fiba n (c+1) b (a+b)</pre>
</blockquote>
<h3> Linear&nbsp; -- Dynamic Programming style<br>
</h3>
<ul>
  <pre>fiba 7 1 0 1&nbsp;<br>=&gt; fiba 7 2 1 1&nbsp;<br>=&gt; fiba 7 3 1 2&nbsp;<br>=&gt; fiba 7 4 2 3&nbsp;<br>=&gt; fiba 7 5 3 5&nbsp;<br>=&gt; fiba 7 6 5 8&nbsp;<br>=&gt; fiba 7 7 8 13&nbsp;<br>=&gt; 13</pre>
  <li> The number of recursive calls is linear in n. Compare this to</li>
</ul>
<h3> Exponential</h3>
<blockquote>
  <pre>fib 7<br>=&gt; fib 5 + fib 6<br>=&gt; fib 3 + fib 4 + fib 4 + fib 5<br>=&gt; fib 1 + fib 2 + fib 2 + fib 3<br>&nbsp;&nbsp; +fib 2 + fib 3 + fib 3 + fib 4<br>=&gt; 1 + fib 0 + fib 1 + fib 0<br>&nbsp;&nbsp; +fib 1 + fib 1 + fib 2 + fib 0<br>&nbsp;&nbsp; +fib 1 + fib 1 + fib 2 + fib 1<br>&nbsp;&nbsp; +fib 2 + fib 2 + fib 3<br>=&gt; ...</pre>
  <li> exponential (#calls &gt; fib n)</li>
</blockquote>
<h3> Fibonacci really is exponential</h3>
<ul>
  <pre>fibonacci(<i>n</i>) = [(1 + sqrt(5))<i><sup>n</sup></i> - (1 - sqrt(5))<i><sup>n</sup></i>]/ 2<i><sup>n</sup></i> sqrt(5)</pre>
and we can show (1.6)<sup><i>n </i>- 2</sup> &lt; fibonacci(<i>n</i>)
&lt; (1.7)<sup><i>n </i>- 1</sup> for <i>n</i> &gt; 2 <li> Compare
the performance of fib1 20 and fib 20</li>
</ul>
<h3> Using Complex Data Structure to save Computation Time</h3>
<ul>
... Using <i>where</i>
  <p><tt>&gt; fib3 n = fNum</tt> <br>
  <tt>&gt;&nbsp;&nbsp; where</tt> <br>
  <tt>&gt;&nbsp;&nbsp; (fNum,_) = fibP n</tt> <br>
  <tt>&gt;&nbsp;&nbsp; fibP 0 = (0,1)</tt> <br>
  <tt>&gt;&nbsp;&nbsp; fibP n = (y,x+y)</tt> <br>
  <tt>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; where</tt> <br>
  <tt>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (x,y) = fibP (n-1)</tt> <br>
&nbsp; </p>
  <li> This solution runs in linear time and linear space</li>
</ul>
<h3> More power in lazy evaluation -- memorization<br>
</h3>
<ul>
&#8230;and at the same time use the list for the computation <br>
&nbsp;
  <pre>&gt; fib2 n = fibs !! n<br>&gt;&nbsp;&nbsp; where<br>&gt;&nbsp; fibs = 0:1:zipWith (+) fibs (tail fibs)</pre>
  <li> The initial &#8220;0&#8221; stands for &#8220;fib2 0,&#8221; which is not normally
defined, used since lists are indexed from 0</li>
  <li> Remember: only compute as much of the list as is needed</li>
  <h3> Details</h3>
  <ul>
    <pre>fibs = 0:1:1:2:3:5:8:13:21:34:...<br>tail fibs=1:1:2:3:5:8:13:21:34:...</pre>
    <pre>0:1:zipWith (+) fibs (tail fibs)<br>=&gt; 0:1:zipWith (+)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0:1:1:2:3:5 :8 :13:21:34:...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1:1:2:3:5:8 :13:21:34:55:...<br>=&gt; 0:1:1:2:3:5:8:13:21:34:55:89:&#8230;</pre>
    <li> Every value that is computed is stored in the list and reused</li>
    <li> <tt>fib2 </tt>runs in linear time</li>
    <dl>
      <dl>
        <li> AND because of lazy evaluation <tt>fib2 </tt>has only
constant space requirements.</li>
      </dl>
    </dl>
  </ul>
  <hr noshade="noshade" size="1" width="100%">
</ul>
<h3> Factorial Recursive definition</h3>
<ul>
  <tt>&gt; factorial 0 = 1</tt> <br>
  <tt>&gt; factorial n = n*factorial (n-1)</tt>
  <blockquote><tt>or using if/else statement</tt></blockquote>
  <tt>&gt; fact n = if ( n==0) then 1 else n*fact (n-1)</tt> <br>
&nbsp; <li> Notice the form of the execution tree:</li>
  <br>
  <a
 href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/17fact.gif"><img
 src="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/17fact.gif"
 alt="Recursive Factorial Function"
 style="border: 0px solid ; width: 222px; height: 275px;"> <br>
  </a><b>Notice the pattern of the solid lines. &nbsp;They form a
"comb".</b>
</ul>
<h3> The fibonacci trick with factorial--not as effective</h3>
<blockquote>
  <pre>&gt; fact2 n = facts !! n<br>&gt;&nbsp; where<br>&gt;&nbsp;&nbsp; facts = 1:1:zipWith (*) [2..] (tail facts)</pre>
  <pre>facts = 1:1:2:6:24:120:720:...<br>tail facts = 1:2:6:24:120:720:...<br>[2..]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 2:3:4: 5:&nbsp; 6:&nbsp; 7:...</pre>
  <pre>1:1:zipWith (*)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2:3:4: 5:&nbsp; 6:&nbsp; 7:&nbsp;&nbsp; 8:&nbsp;&nbsp;&nbsp; 9:...<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1:2:6:24:120:720:5040:40320:...<br>=&gt; 1:1:2:6:24:120:720:5040:40320&#8230;</pre>
</blockquote>
<h3> Other versions of factorial</h3>
<blockquote>
  <pre>&gt; fact 0 = 1<br>&gt; fact n = n* fact(n-1)</pre>
  <pre>&gt; fact1 n = facta n 0 1<br>&gt;&nbsp; where<br>&gt;&nbsp;&nbsp; facta n c accm = if (c == n) then accm&nbsp;<br>&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else facta n (c+1) (c+1)*accm</pre>
</blockquote>
<h3> Tail recursion</h3>
<ul>
  <li> <tt>gcd u v = if (v == 0) then u else gcd v (mod u v)</tt></li>
  <br>
  <a
 href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/17gcd.gif"><img
 src="17gcd.gif" alt="Execution Tree for gcd 12 9"
 style="border: 0px solid ; width: 264px; height: 300px;"> </a> <br>
  <b>NOTICE the pattern of the solid lines: &nbsp; It forms a tail!</b><br>
  <br>
  <li>One important feature of facta and fiba is that they are tail
recursive:</li>
  <pre>facta n c accm = if (c==n) then accm else facta n (c+1) (c+1)*accm</pre>
  <pre>fiba n c a b = if c == n then b else fiba n (c+1) b (a+b)</pre>
  <pre></pre>
</ul>
<h3> The general form of tail recursion</h3>
<ul>
  <pre>f(x) = if p(x) then q(x) else f (h(x))</pre>
  <li> A good compiler can replace tail recursion by a loop
automatically</li>
  <li> The argument x can be a sequence of arguments or a tuple</li>
  <pre>f(x,y,z) = if p(x,y,z) then q(x,y,z) else f(x',y',z')</pre>
  <pre>f x y z = if p x y z then q x y z else f x' y' z'</pre>
</ul>
<h3> Iterative form</h3>
<ul>
  <li> The corresponding iterative code is:</li>
  <pre>type2 f(type1 x) {&nbsp;<br>&nbsp;&nbsp;&nbsp; type1 t = x;&nbsp;<br>&nbsp;&nbsp;&nbsp; while (true) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (p(t)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return q(t);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t = h(t);&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</pre>
  <li> Apply the transformation to:</li>
  <pre>facta n c k = if (c == n) then k else facta n (c+1) (c+1)*k</pre>
</ul>
<h3> Iterative form of facta</h3>
<blockquote>
  <pre>facta n c k = if (c==n) then k else facta n (c+1) (c+1)*k</pre>
  <pre>int iterfacta(int n,int c,int k){<br>&nbsp;&nbsp;&nbsp; int tn = n; // not really needed IN THIS CASE<br>&nbsp;&nbsp;&nbsp; int tc = c;&nbsp;<br>&nbsp;&nbsp;&nbsp; int tk = k;<br>&nbsp;&nbsp;&nbsp; while (true) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tc == tn) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tk;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tn = tn;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tc++;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tk *= tc;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</pre>
</blockquote>
<h3> Comments</h3>
<ul>
  <li> These linear iterations use very little space since no recursive
calls are made</li>
  <li> We see later the effect of calling subprograms on space</li>
  <li> Other functions such as fiba and gcd are also tail recursive and
can be converted to high-speed loops by a compiler</li>
</ul>
<h3> Iterative version of fiba</h3>
<blockquote>
  <pre>fiba n c a b = if c == n then b else fiba n (c+1) b (a+b)</pre>
  <pre>int iterFiba(int n,int c,int a,int b){&nbsp;<br>&nbsp;&nbsp;&nbsp; int tn = n;&nbsp;<br>&nbsp;&nbsp;&nbsp; int tc = c;&nbsp;<br>&nbsp;&nbsp;&nbsp; int ta = a;&nbsp;<br>&nbsp;&nbsp;&nbsp; int tb = b;&nbsp;<br>&nbsp;&nbsp;&nbsp; while (true) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tc == tn) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tb;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tn=tn;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tc++;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int t = ta;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ta = tb;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tb += t;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</pre>
</blockquote>
<h3> Iterative form of gcd (assumes one input is not 0)</h3>
<blockquote>
  <pre>gcd m n = if n == 0 then m else gcd (n, m `mod` n)</pre>
  <pre>int itergcd(int m, int n) {&nbsp;<br>&nbsp;&nbsp;&nbsp; int tm = m;&nbsp;<br>&nbsp;&nbsp;&nbsp; int tn = n;&nbsp;<br>&nbsp;&nbsp;&nbsp; while (true) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tn == 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return tm;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int t = tm;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tm = tn;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tn = t `mod` tn;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</pre>
</blockquote>
<h3> Kieburtz and Shultis</h3>
<ul>
  <li> Not all recursive functions are tail recursive. If a function is
not tail recursive, an accumulating parameter will need to be
introduced.</li>
  <li> There is substantial research into this area.</li>
  <li> One very nice result is due to Kieburtz and Shultis.</li>
  <li> Suppose f has the form:</li>
</ul>
<h3> Format for Kieburtz and Shultis</h3>
<blockquote>
  <pre>f x = if p x then q x else r (g x) (f (h x))</pre>
where r is ASSOCIATIVE, i.e.<tt> r x (r y z) = r (r x y) z</tt> <br>
or infix: <tt>x `r` (y `r` z) = (x `r` y) `r` z</tt> <br>
then f can be transformed into the iteration:</blockquote>
<h3> Iterative form</h3>
<blockquote>
  <pre>type2 f(type1 x) {<br>&nbsp;&nbsp;&nbsp; type1 t = x;&nbsp;<br>&nbsp;&nbsp;&nbsp; type2 acc;&nbsp;<br>&nbsp;&nbsp;&nbsp; if (p(t)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return q(t);<br>&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; acc := g(t);<br>&nbsp;&nbsp;&nbsp; } //see note&nbsp;<br>&nbsp;&nbsp;&nbsp; while(true) {&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t = h(t);&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (p(t)) (<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return r(acc,q(t));&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; acc = r(acc,g(t));&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</pre>
</blockquote>
<h3> Some K&amp;S functions</h3>
<ul>
  <li> Note: In general you cannot assign to &#8220;acc&#8221; before checking that
&#8220;p(t)&#8221; is false.</li>
  <li> It can be the case that &#8220;g(t)&#8221; is undefined when &#8220;p(t)&#8221; is true,
e.g. when p(t) is (t == 0) and g(t) is 1/t</li>
  <li> The functions factorial and length are of the K&amp;S form</li>
</ul>
<h3> factorial</h3>
<ul>
  <pre>fact n = if n == 0 then 1 else n * fact(n-1)</pre>
  <pre>r is multiply (*);&nbsp;&nbsp;<br>g(n) = n&nbsp;<br>q(n) = 1;&nbsp;<br>h(n) = n-1;&nbsp;<br>p is (0==)</pre>
  <li> The iterative form is on the next slide</li>
  <li> Notice that the iterative code simply modifies two memory
locations until a predicate is satisfied</li>
</ul>
<h3> Iterative version</h3>
<blockquote>
  <pre>long f(int x) {<br>&nbsp;&nbsp;&nbsp; int t = x;&nbsp;<br>&nbsp;&nbsp;&nbsp; long acc;&nbsp;<br>&nbsp;&nbsp;&nbsp; if (t==0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 1;<br>&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; acc := t;&nbsp;<br>&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; while(true) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t = t-1;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (t==0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return acc*1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; acc = acc*t;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>&nbsp;&nbsp;&nbsp; }<br>}</pre>
</blockquote>
<hr width="100%">
<center>
<table bgcolor="#fffff0" border="1" cellpadding="0" cellspacing="0">
  <tbody>
    <tr>
      <td><a
 href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/8hSpr01.html">previous</a></td>
      <td><a
 href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/10hSpr01.html">&nbsp;next&nbsp;</a></td>
    </tr>
  </tbody>
</table>
</center>
<hr align="left" noshade="noshade" size="6" width="100%"> <br>
<br>
</body>
</html>
