<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta http-equiv="content-type"
 content="text/html; charset=ISO-8859-1">
  <title>Practice</title>
  <meta name="author" content="Eileen Head">
  <meta content="text/html; charset=UTF-8" http-equiv="content-type">
</head>
<body>
<!-- ================================================================================  --><!-- This HTML file was created by AbiWord.                                            --><!-- AbiWord is a free, Open Source word processor.                                    --><!-- More information about AbiWord is available at http://www.abisource.com                --><!-- ================================================================================  -->
<div>
<p><span style="">Outcomes: You should<br>
</span></p>
<ul>
  <li>understand types in haskell</li>
  <li>understand the difference between recursion and function
application</li>
  <li>understand what it means that "functions are first class"</li>
  <li>understand the difference between tail recursive functions and
non-tail recursive functions and why it is important</li>
  <li>understand the term "referential transparency" and why is it
good to do<br>
  </li>
  <li>be able to write code<br>
  </li>
  <ul>
    <li>using primitive recursion</li>
    <li>using list comprehension notation</li>
    <li>using hof as the main mechanism <br>
    </li>
    <li>using infinite data structures <br>
    </li>
    <ul>
      <li>zip and zipwith<br>
      </li>
    </ul>
    <li>to define Haskell classes and create instance type in that
class (like <a
 href="http://bingweb.binghamton.edu/%7Ehead/CS471/HW/hwF03Generic.html">homework
11)</a><br>
    </li>
  </ul>
  <li>understand how to derive types of a given expression</li>
  <li>understand lamba expressions <br>
  </li>
  <li>the different parameter passing techniques -- normal order,
applicative order, lazy evaluation</li>
  <li>functional program practices that carry over to imperative
programming.<br>
  </li>
</ul>
<p><span style=""><br>
The following Haskell function </span><span
 style="font-weight: bold; font-family: 'Courier New';">checksum</span><span
 style=""> that takes a string of 0's and 1's and returns the sum of
the 1's in the string. </span></p>
<p style="text-align: left;" dir="ltr" class="List_2"><span
 style="font-weight: bold; font-family: 'Courier New';">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt;
checksum "00111001"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4</span></p>
<p style="text-align: left;" dir="ltr" class="List_2"><span
 style="font-weight: bold;">Question: </span><span style="">What is
the most general signature (type) of checksum? </span></p>
<p><span style="font-weight: bold;">Answer</span><span
 style="font-weight: bold; font-family: 'Courier New';">: </span><span
 style="font-weight: bold;">______________________________________________________________________</span></p>
<p><span style="font-weight: bold;">Code: </span><span style="">Define
</span><span style="font-weight: bold; font-family: 'Courier New';">checksum</span><span
 style=""> using explicit recursive function.</span></p>
<p><span style="font-weight: bold;">Answer:
&nbsp;&gt; </span><span
 style="font-weight: bold; font-family: 'Courier New';">checksum
&nbsp;&nbsp;___________________________________________________________</span></p>
<p><span style="">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________________________________________________________________________________</span></p>
<p style="text-align: left; margin-left: 0.25in; text-indent: -0.25in;"
 dir="ltr" class="List_2"><span style="">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;______________________________________________________________________________________</span></p>
<p style="text-align: left;" dir="ltr" class="List_2"><span
 style="font-weight: bold;">Code: &nbsp;</span><span style="">Define </span><span
 style="font-weight: bold; font-family: 'Courier New';">checksum</span><span
 style=""> using map, foldr, foldl and/or filter.</span></p>
<p style="text-align: left;" dir="ltr" class="List_2"><span
 style="font-weight: bold;">Answer:</span><span
 style="font-weight: bold; font-family: 'Courier New';"> &gt; checksum
= _______________________________________________________<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="">______________________________________________________________________________________</span></p>
<p style="text-align: left;" dir="ltr" class="List_2"><span
 style="font-weight: bold;">Code: </span><span style="">Define </span><span
 style="font-weight: bold; font-family: 'Courier New';">checksum </span><span
 style="">using </span><span style="font-weight: bold;">sum</span><span
 style=""> or </span><span style="font-weight: bold;">fold </span><span
 style="">and list comprehension notation. </span></p>
<p style="text-align: left; margin-left: 0.25in; text-indent: -0.25in;"
 dir="ltr" class="List_2"><span style="font-weight: bold;">Answer:</span><span
 style="font-weight: bold; font-family: 'Courier New';"> &gt; checksum
str = ________________________________________________________<br>
<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="">______________________________________________________________________________________</span></p>
<span style="font-weight: bold;"><br>
</span>What is the most general type?&nbsp;&nbsp; Remember:<span
 style="font-weight: bold;">
<dl>
  <dd><span style="font-family: monospace; font-weight: bold;">map ::
(a -&gt; b) -&gt; [a] -&gt; [b] <br>
uncurry :: (a -&gt; b -&gt; c) -&gt; (a,b) -&gt; c <br>
(.) :: (a -&gt; b) -&gt; (c -&gt; a) -&gt; c -&gt; b<br>
(:) :: a -&gt; [a] -&gt; [a]<br>
    <br>
    </span> </dd>
</dl>
<ol style="list-style-type: lower-alpha;">
  <li style="font-family: monospace;"><big>uncurry (+) ::</big></li>
  <li style="font-family: monospace;"><big>(:) 1 :: <br>
    </big></li>
  <li style="font-family: monospace;"><big>map (:)<br>
    </big></li>
  <li style="font-family: monospace;"><big><span
 style="font-weight: bold;">map uncurry ::</span></big></li>
  <li style="font-family: monospace;"><big><span
 style="font-weight: bold;">map map ::<br>
    </span></big></li>
</ol>
<br>
Show each step in the unrolling of the following functions<br>
<br>
</span><span style="font-weight: bold;"><span
 style="font-family: &quot;Courier New&quot;;"></span><br>
</span><span style="font-weight: bold; color: rgb(102, 0, 0);"><font
 face="Courier New,Courier"><b>foldl</b>
f z [ ]
= z</font> <br>
<font face="Courier New,Courier">foldl f z (x:xs)
= foldl
f (f z x) xs</font><br>
</span>
<span style="font-weight: bold;"><br>
<span style="font-family: monospace;">foldl (||) False [ 4&lt; x|
x&lt;- [1,3,4]]</span>
<br>
<br>
<br>
</span>
<span style="font-weight: bold;"><font face="Courier New,Courier"
 style="color: rgb(102, 0, 0);"><b>foldr</b>
f s [ ]
= s</font><span style="color: rgb(102, 0, 0);"> </span><br
 style="color: rgb(102, 0, 0);">
<font face="Courier New,Courier" style="color: rgb(102, 0, 0);"><font>foldr
f s (x:xs)
= f
x (foldr f s xs)</font></font><br>
</span><span style="font-weight: bold;"><br>
<span style="font-family: monospace;">foldr (||) False [ 4&lt; x|
x&lt;- [1,3]]<br>
<br>
<br>
What would happen if I had<br>
</span></span><span style="font-weight: bold;"><span
 style="font-family: monospace;"><span style="font-weight: bold;"><span
 style="font-family: monospace;">foldr (||) True [ 4&lt; x| x&lt;-
[1,3]]</span></span><br>
</span></span><span style="font-weight: bold;"><span
 style="font-family: monospace;"><br>
<br>
Define "or lst" to return true if one element in the list, lst, is true
and false otherwise.&nbsp; USE only HOF.<br>
<br>
<br>
</span></span><span style="font-weight: bold;"><span
 style="font-family: monospace;">
<div>
<p><big><span style="font-weight: bold; font-family: 'Courier New';">fn
(2 +
5 + 9 + 7) ( 3 + 3 + 5 )</span></big><span style=""> where fn is
defined as<br>
&nbsp; &nbsp; &nbsp; &nbsp; </span><span
 style="font-weight: bold; font-family: 'Courier New';"><big>fn a b = b
+ b</big> </span></p>
<p><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; Answer: </span><span
 style="">Assume </span><span style="font-weight: bold;">normal</span>
<span style=""> order (outer most) evaluation</span><span
 style="font-family: 'Arial';">:</span></p>
<p><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; Answer: </span><span
 style="">Assume </span><span style="font-weight: bold;">applicative</span><span
 style=""> order (inner most) evaluation:</span></p>
<p><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; Answer: </span><span
 style="">Assume </span>
<span style="font-weight: bold;">lazy</span><span style=""> evaluation</span></p>
</div>
<br>
</span></span><br>
<br>
</div>
</body>
</html>
