<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">
  <title>Type Systems - Chap 7</title>

  
</head><body>
<center>
<h3>Type Systems <br>
Spring 2013
</h3>
</center>

<hr style="width: 100%; height: 2px;">
<h3>The Definition of Types: 3 POV</h3>

<ul>

  <li><span style="font-style: italic;">denotational</span>
pov:&nbsp;</li>
  <li><span style="font-style: italic;">constructive</span>
pov:&nbsp;</li>
  <ul>
  </ul>
  <li><span style="font-style: italic;">abstract based </span>pov:</li>
  <ul>
  </ul>
  <li>programmer's pov: a mixture of these pov.</li>
</ul>

<ul>

</ul>

<h3>Classification of Types</h3>

<span style="font-weight: bold;">Simple types:
Predefined types used to construct all other types</span><br style="font-weight: bold;">

<ul>

  <li>keywords (int, etc) </li>
</ul>

Discrete Types: Enumerated and Subrange Types
<ul>

  <dl>
    <li>Enumerated types consist of a set of named elements.<br>
    </li>
    <li> Various languages (Pascal, Ada, Modula-2, C++) allow
users to
define enumerated types:</li>
    <dl>
      <b><tt>&nbsp; TYPE&nbsp;
Traffic_signal&nbsp; IS&nbsp; (Red,
Green);</tt></b><br>
      <b><tt>&nbsp; TYPE&nbsp; Rainbow&nbsp;
IS&nbsp; (Red, Orange,
Yellow, Green, Blue, Violet);</tt></b>
      <li> This is
Ada, Pascal will not
allow Red and Green to appear in two enumerated types.</li>
      <b><tt>&nbsp; &nbsp;SUBTYPE&nbsp;
Brighter IS&nbsp; Rainbow&nbsp;
RANGE&nbsp; Red..Yellow;</tt></b>
      <li> It is
obvious to the compiler
that
Red is of type Rainbow.</li>
      <li> Enumerated types have Predecessor and Successor
functions
provided in the language and, in some cases, other functions:</li>
      <dl>
&nbsp;
      </dl>
      <b><tt>Rainbow&#8217;SUCC(Green) is Blue</tt></b><br>
      <b><tt>Rainbow&#8217;PRED(Yellow) is Orange</tt></b><br>
      <b><tt>Rainbow&#8217;LAST is Violet</tt></b><br>
      <b><tt>Rainbow&#8217;FIRST is Red</tt></b><br>
&nbsp;
      <li> Maximum value for integers</li>
      <dl>
        <b><tt>ADA:&nbsp; Integer&#8217;LAST</tt></b><br>
        <b><tt>Pascal: MAXINT</tt></b><br>
        <b><tt>Java: java.lang.Integer.MAX_VALUE</tt></b><br>
        <b><tt>C : &lt;Limits.h&gt;</tt></b>
      </dl>
    </dl>
    <dl>
    </dl>
  </dl>
</ul>

<ul>

  <ul>
    <li>C: <span style="font-style: italic;">enums</span>
are basically a way to alias names to integers</li>
    <li>C++: <span style="font-style: italic;">enums</span>
define an actual type </li>
    <li>Java 5 has "linguistic support" for <span style="font-style: italic;">enum</span>
types.&nbsp;</li>
    <ul style="list-style-type: disc;">
      <li><a target="_blank" href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.9"><span style="font-style: italic;">enum</span>
(</a> Language Specification 3rd ed)</li>
      <ul>
        <li><a target="_blank" href="http://stackoverflow.com/questions/726155/java-enums-can-have-behavior"><span style="font-style: italic;">enums</span></a>
have methods and state</li>
      </ul>
    </ul>
  </ul>
</ul>

<div style="margin-left: 40px;"><b>Subsets/subranges</b></div>

<ul>

  <dl>
    <li> Languages can provide subranges of scalar types</li>
  </dl>
  <dl>
    <li> Pascal and Modula-2</li>
  </dl>
  <dl style="margin-left: 40px;">
&nbsp;<b><tt>TYPE&nbsp; Uppercase =
&#8216;A&#8217;..&#8216;Z&#8217; ;</tt></b><br>
  </dl>
  <dl>
    <li> Ada also allows subtypes or new&nbsp; types
&nbsp;</li>
    <dd><b><tt>SUBTYPE Myrange is Integer RANGE 10.
. 100</tt></b></dd>
    <dd><span style="font-family: monospace; font-weight: bold;">TYPE
Mytype is NEW Integer RANGE 10. . 100</span></dd>
    <dd><br>
    </dd>
    <dd><b><tt>X : Myrange;</tt></b>&nbsp;</dd>
    <dd><b><tt>Y : Mytype;</tt></b>&nbsp;</dd>
    <dd><b><tt>Z : Integer;</tt></b> <br>
    </dd>
  </dl>
</ul>

<ul>

  <li><b><tt>legal: Z := X;&nbsp; X := Z; </tt></b><span style="font-family: monospace;">(if
Z in the
range of X)</span></li>
  <li><b><tt>not legal: Z := Y;</tt></b> <br>
  </li>
  <li>The range portion is called a <i>type constraint</i></li>
  <li>Myrange is a <i>constrained subtype</i><br>
  </li>
  <li>Mytype is called a <i>derived type.</i><br>
  </li>
</ul>

<h3>
Composite, or
constructed type&nbsp;</h3>

<ul>

  <dl>
    <li> Grouping of elementary data elements</li>
    <dl>
      <li> Aggregate of heterogeneous types</li>
      <dd> Records</dd>
      <dl>
      </dl>
      <li> Aggregate of homogeneous types</li>
      <dl>
        <dt> Arrays</dt>
      </dl>
      <li> Aggregate of aggregates</li>
      <dd> <i>linked lists</i></dd>
      <dl>
      </dl>
    </dl>
    <hr size="1" width="100%">
  </dl>
</ul>

<span style="font-weight: bold;">Records:</span><br>

<ul>

  <li><b>C&nbsp; provides <i>structs </i>:</b></li>
  <dl>
    <dl>
      <b><tt>struct Rec {</tt></b>
      <ul>
        <dl>
          <b><tt>int x;</tt></b><br>
          <b><tt>int y;</tt></b><br>
          <b><tt>char a;</tt></b><br>
          <b><tt>float f;</tt></b>
        </dl>
        <b><tt>}</tt></b>
      </ul>
      <br>
Declaration and Initialization <br>
      <tt><b>struct Rec var = { 1; 1; 'a'; 1.2 };<br>
      </b></tt>
    </dl>
  </dl>
</ul>

<ul>

  <dl>
  </dl>
</ul>

<ul>

  <dl>
    <li> Java: does not have <span style="font-style: italic;">structs</span></li>
    <dd> Classes without methods can be viewed as records.</dd>
    <dl>
    </dl>
    <li> C++:&nbsp;<span style="font-style: italic;">
structs</span> may have methods</li>
    <li>C#:<span style="font-style: italic;"> structs</span>
may have methods</li>
    <dl>
      <dt> <span style="font-style: italic;">structs </span>are value
types vs <span style="font-style: italic;">classes</span>
which are
reference types </dt>
    </dl>
  </dl>
</ul>

<ul>

  <dl>
  </dl>
</ul>

<blockquote>
  <hr size="2" width="50%"></blockquote>

<ul>

  <li><b>Ada records:</b></li>
  <dl style="font-family: monospace;">
    <dl>
      <span style="font-weight: bold;">TYPE&nbsp;Emp_name_typ&nbsp;IS&nbsp;RECORD
      </span><br style="font-weight: bold;">
      <span style="font-weight: bold;">&nbsp;
&nbsp;First : String(1..20); </span><br style="font-weight: bold;">
      <span style="font-weight: bold;">&nbsp;
&nbsp;Middle : String(1..10); </span><br style="font-weight: bold;">
      <span style="font-weight: bold;">&nbsp;
&nbsp;Last : String(1..20); </span><br style="font-weight: bold;">
      <span style="font-weight: bold;">END RECORD; </span>
      <p style="font-weight: bold;">TYPE&nbsp;
Emp_rec_typ&nbsp; IS&nbsp; RECORD<br>
&nbsp; &nbsp;Emp_name : Emp_name_typ; <br>
&nbsp; &nbsp;Hourly_rate : Float; <br>
END&nbsp;RECORD; </p>
      <span style="font-weight: bold;"></span>
      <p><span style="font-weight: bold;">Employee_record :
Emp_rec_typ;</span> </p>
    </dl>
  </dl>
</ul>

<dl>

  <hr noshade="noshade" size="1" width="50%">
</dl>

<ul>

  <li><b>Haskell example:<br>
    </b></li>
  <dl>
    <dl>
      <b><tt>data People = Person String Int</tt></b><br>
      <tt><br>
      </tt> <dt> People
is
the type name</dt>
Person is the constructor
    </dl>
  </dl>
</ul>

<ul>

  <dl>
    <li>Implementation issue:</li>
  </dl>
</ul>

<dl style="margin-left: 40px;">

How are records stored in memory
and what are offsets? <dt>Initialization&nbsp; </dt>
</dl>

<dl>

  <dd><br>
  </dd>
</dl>

<dl style="margin-left: 40px;">

</dl>

<dl>

</dl>

<ul>

</ul>

<ul>

  <dl>
    <hr size="1" width="100%">
  </dl>
</ul>

<h3>Type Checking
</h3>

<ul>

  <dl>
    <li> Compiled languages usually do as much type checking as
possible before running the program.&nbsp; (Static type checking).</li>
  </dl>
  <dl>
  </dl>
  <dl>
    <li> Some languages must include tables in the run-time
environment for dynamic type checking.</li>
  </dl>
</ul>

<li style="margin-left: 40px;">Issue for statically typed
languages</li>

<div>
<ul>
  <ul>
    <li>type equivalence</li>
    <li>type compatibility</li>
    <li>type inference</li>
  </ul>
</ul>
</div>

<h3>When are two types the
same? -- Type
Equivalence</h3>

<ul>

  <dl>
    <b>Structural Equivalence</b>
    <dl>
      <li> Based on the idea that data types that have identical
structures should be compatible.</li>
      <li> Exact definition of equivalence varies from one
language to
another.</li>
    </dl>
    <b>Name Equivalence </b>(Sometime called strict)
    <dl>
      <li> Data types are equivalent only if they have the same
name</li>
    </dl>
    <dl>
      <hr size="1" width="100%"><b>Arrays</b>
      <li>Is array [ 1 .. 10 ]
compatible with array [ 0
.. 9 ] ?</li>
      <li> C avoids the problem because all arrays start with 0.</li>
      <li> Algol 68 would make the array type compatible.</li>
      <br>
      <hr size="1" width="100%"><b>Records</b>
      <li>Are these two records
equivalent?<br>
      </li>
      <dl>
        <p><b><tt>record</tt></b><b><tt><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x : integer;</tt></b><b><tt><br>
&nbsp; &nbsp; &nbsp; y : char<br>
end<br>
        </tt></b></p>
        <p><b><tt>record<br>
        </tt></b><b><tt>&nbsp; &nbsp;
&nbsp; a : integer;</tt></b><b><tt><br>
&nbsp; &nbsp; &nbsp; b : character;</tt></b></p>
        <dl>
        </dl>
        <b><tt>end<br>
        <br>
        </tt></b>
      </dl>
      <li> Algol 68 requires field names to be the same with the
same
type. So it is not considered equivalent.</li>
      <br>
      <li> Ada uses name equivalence.</li>
      <dl>
        <b><tt>type T1 is range 1..10</tt></b><br>
        <b><tt>type T2 is range 1..10</tt></b>
      </dl>
      <b><i>Derived</i></b>&nbsp;types are
not the same type. <br>
    </dl>
  </dl>
</ul>

<ul>

  <dl>
    <dl>
      <li> To have compatibility we use <b><i>subtypes</i></b>,
e.g.</li>
    </dl>
  </dl>
</ul>

<dl>

</dl>

<dl style="margin-left: 120px;">

  <b><tt>subtype S is T1 range 2..5</tt></b><br>
  <b><tt> </tt></b>
</dl>

<dl>

</dl>

<ul>

  <dl>
    <b>Beware of anonymous types in Ada:</b>
    <dl>
      <li> Variable declarations of arrays and tasks (without
giving a
name to the corresponding type) may create anonymous type that are
different each time: (Ada)</li>
      <br>
      <b><tt>x, y: array(1..9) of integer;</tt></b>
      <dl>
is equivalent to:
      </dl>
      <b><tt>type internal_type1 is array (1..9) of integer;</tt></b><br>
      <b><tt>type internal_type2 is array (1..9) of integer;</tt></b>
      <dl>
        <b><tt>x: internal_type1;</tt></b><br>
        <b><tt>y: internal_type2;</tt></b>
      </dl>
      <li> x and y have different internal names.</li>
      <dl>
        <li> Therefore have different types. So x := y is illegal.</li>
      </dl>
      <h4>
      <hr size="1" width="100%"><b>C</b></h4>
    </dl>
    <dl>
      <li> In C, structural equivalence is used, <b>except
for
struct&#8217;s,</b>
where name equivalence is used.</li>
      <dl>
        <li> Note: <span style="font-style: italic;">typedef</span>
does not create a new type.</li>
      </dl>
      <li> Java uses name equivalence.</li>
      <br>
      <hr size="1" width="100%">Sometimes called
Declaration Equivalence
      <li> The follow would be considered
equivalent
(as in some Pascal implementations):</li>
      <dl>
        <b><tt>x,y: array[1..10] of</tt></b>
        <dl>
          <b><tt>record a : integer;</tt></b><br>
          <b><tt>&nbsp;&nbsp;&nbsp; &nbsp;
&nbsp;b : char</tt></b>
        </dl>
        <b><tt>&nbsp; &nbsp; &nbsp; end;</tt></b>
      </dl>
      <li> The use of <b><tt>typedef</tt></b>
in C introduces a new
name
for the same type.</li>
      <dl>
        <b><tt>typedef char *str;</tt></b><br>
        <b><tt>str p;</tt></b><br>
        <b><tt>char *q;</tt></b>
      </dl>
      <i>p </i>and <i>q</i>&nbsp;have the
same type.
    </dl>
    <hr size="1" width="100%">
  </dl>
</ul>

<h3>
Type Checking &nbsp; </h3>

<ul>

  <dl>
    <dl>
      <li> Compiled languages usually do as much type checking as
possible before running the program.&nbsp; (Static type checking).</li>
      <li> Some languages must include tables in the run-time
environment for dynamic type checking.</li>
      <li>Are the types equivalent/compatible?</li>
      <li> Ada has to do run-time constraint checking.</li>
      <dl>
        <b><tt>type T1 is range 1..99;</tt></b><br>
        <b><tt>subtype S is T1 range 1..9;</tt></b>
        <dl>
          <b><tt>X : T1;</tt></b><br>
          <b><tt>Y : S;</tt></b>
        </dl>
        <b><tt>begin</tt></b>
        <dl>
          <b><tt>Y := 6;</tt></b><br>
          <b><tt>X := 2 * Y;</tt></b><br>
          <b><tt>Y := X;</tt></b>
        </dl>
      </dl>
this causes a run-time exception.
    </dl>
  </dl>
  <hr size="1" width="100%">
</ul>

<h3>Type Compatibility&nbsp;</h3>

<ul>

  <li>Not all languages require <span style="font-style: italic;">type
equivalence </span>in
every context</li>
</ul>

<div style="margin-left: 40px;">
<ul>
</ul>
<h4> Coercion</h4>
<ul>
  <li>Automatic conversion<br>
  </li>
  <ul>
    <li> Ada require explicit conversion which is like casting in
C
(Java/ C++)</li>
    <li>Haskell has several overloaded functions that serve as
explicit
coercions:</li>
    <ul>
      <li>fromInteger, fromRational, toInteger, toRational,
fromIntegral, fromRealFrac, fromIntegral, fromRealFrac <br>
      </li>
      <li>fromInteger and fromRation are implicitly used to
provide
overloaded numeric literals:<tt> </tt></li>
    </ul>
  </ul>
  <li> 4.5 + 6 in most languages is probably 4.5 + 6.0</li>
  <ul>
    <li> + is usually an overloaded operator, adding integers or
reals
(floats)</li>
    <li> Usually addition of reals</li>
  </ul>
  <li> The Louden describes a PL/I&#8217;s problem: (Rule:
fractional value&#8217;s
precision must be maintained.)</li>
  <br>
  <ul>
    <tt>1/3 + 15 returns 5.33333333333333</tt><br>
  </ul>
&nbsp;
  <li> Type widening is more natural than type
narrowing in
general.</li>
  <ul>
    <li> type widening</li>
    <dl>
      <dl>
        <li> int to real</li>
        <li> 2-byte int to 4 byte int</li>
      </dl>
      <li> type narrowing</li>
      <dl>
        <li> real to int</li>
      </dl>
    </dl>
  </ul>
  <ul>
    <li>Java uses the terms <span style="font-style: italic;"><span style="font-style: italic;"><span style="font-weight: bold;">numerical
promotion </span></span></span><span style="font-weight: bold;">and<span style="font-style: italic;"> widening conversion</span></span></li>
    <li>APL uses&nbsp;&nbsp;<span style="font-weight: bold;"><span style="font-style: italic;"><span style="font-weight: bold;"></span>promotion&nbsp;</span></span>to
means coercion from a <span style="font-weight: bold;">scalar</span>
to
an <span style="font-weight: bold;">aggregate</span></li>
  </ul>
  <dl>
    <dd>What do you think this means?<br>
      <br>
    </dd>
  </dl>
  <li> The programmer should be aware:</li>
  <ul>
    <li>No standard definition for such terms<br>
    </li>
    <li> The same code is executed for different types</li>
    <ul>
      <li> The primitive type is changed and stored in a
temporary
location for use.</li>
    </ul>
  </ul>
</ul>
<dl>
  <dd><span style="font-weight: bold;">Casting</span><br>
    <span style="font-style: italic;"></span><span style="font-weight: bold;"></span></dd>
</dl>
<ul>
  <li>In C++ the term <span style="font-style: italic;">cast </span>refers
to four different kinds of explicit type conversion</li>
  <ul>
    <li><span style="font-family: monospace;"><span style="font-weight: bold;">static_cast:</span></span>produces
a new
value "equivalent" to the original.</li>
    <ul>
      <li><span style="font-family: monospace;">double
x = static_cast
3;</span></li>
      <li><span style="font-family: monospace;">same
a C cast<br>
        </span></li>
    </ul>
    <li><span style="font-family: monospace;"><span style="font-weight: bold;">dynamic_cast:</span></span>a
run-time
type-checked conversion of a pointer.</li>
    <dl style="font-family: monospace;">
      <dd>Parent *&nbsp; p = new Child;&nbsp; //up cast</dd>
    </dl>
    <dl style="font-family: monospace;">
      <dd>Child * c = dynamic_cast&lt;Child *&gt;
p;&nbsp; //downcast <br>
      </dd>
    </dl>
    <ul>
      <li>Value is 0 if the conversion is invalid</li>
    </ul>
    <li><span style="font-family: monospace;"><span style="font-weight: bold;">reinterpret_cast:</span></span>
produces no
new values; merely changes the set of functions that can be applied to
the original value</li>
    <ul>
      <li>few reinterpret_casts are portable</li>
      <li>completely unchecked</li>
    </ul>
    <li><span style="font-weight: bold; font-family: monospace;">const_cast:</span>
removes const protection from a parameter</li>
  </ul>
</ul>
</div>

<hr>
<hr style="width: 100%; height: 2px;">
<h3>Sequence data types:<br>
</h3>

<ul>

  <b>Arrays</b>
  <dl>
    <dl>
      <b>Legal subscripts types:</b>
      <dl>
        <li> C, C++, Java indexes are always integers starting at
0.</li>
        <li> FORTRAN 77, FORTRAN 90 uses integers.&nbsp; The
lower
bound
default if 1.</li>
        <li> Pascal allows any ordinal type to be an index.</li>
        <dl>
type WkE = (Sat, Sun); <br>
Costs = array[WkE] of real;
        </dl>
        <li> Ada allows any discrete type (page 153) to be an
index.</li>
        <dl>
          <li>Integers, Booleans and characters are examples of <i>discrete
types </i>( also called <i>ordinal types</i>)<i>.</i><br>
          </li>
          <li> Unconstrained 2-dimensional array</li>
          <br>
          <b><tt>TYPE&nbsp; Matrix_type&nbsp; IS</tt></b>
          <dl>
            <b><tt>ARRAY(Integer range &lt;&gt;,
Integer range
&lt;&gt;) OF Integer;<br>
            </tt></b>
            <li> &nbsp;<a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/Chap3.html#elaboration">Elaboration</a></li>
&nbsp;
          </dl>
          <li> Constrained 2-dimensional array</li>
          <b><tt>TYPE&nbsp; Matrix_4x4_type&nbsp; IS</tt></b>
          <dl>
            <b><tt>ARRAY(1..4, 10..13) OF Integer;</tt></b>
          </dl>
        </dl>
      </dl>
      <hr size="1" width="100%">
      <dl>
        <li>If the arrays are allocated during compile time then
the
range is statically bound.</li>
        <dl>
          <li> Fortran 77</li>
          <li> Global or automatic array (value model) variable
in C:</li>
          <br>
          <b><tt>int arr [ 40 </tt></b>]; <br>
&nbsp;
          <dl>
            <li> Range bound static, storage ?</li>
            <dl>
&nbsp;
            </dl>
          </dl>
          <li> <a name="gccArray"></a>Automatic
Arrays (variable
length
arrays) declared in&nbsp; C functions:</li>
          <dl>
            <b><tt>void cFunction (int size ) {</tt></b><br>
            <b><tt>&nbsp;&nbsp;&nbsp;&nbsp;
int marbles [size][size/2];</tt></b><br>
            <b><tt>}</tt></b><br>
&nbsp;
            <li> Range bound dynamic, storage dynamic</li>
            <li> Prior to C99 this code would not compile.</li>
            <li>Prior to C99: When multidimensional arrays are
used, it
is necessary to specify the bounds of but the first dimension.<br>
            </li>
          </dl>
        </dl>
      </dl>
      <h4>
      <hr size="1" width="100%">When and where does
array allocation
take place?</h4>
      <li> If&nbsp; the arrays are allocated from the heap
then both
the
storage allocation and the subscript ranges can be dynamically bound.</li>
      <li> Java: reference model</li>
      <dl>
      </dl>
    </dl>
  </dl>
  <ul>
    <ul>
      <li> Storage only on the heap</li>
      <li> Arrays are objects</li>
      <ul>
        <b><tt>String [ ] sArray = new String[5];</tt></b><br>
        <b><tt>Object [ ] myArray = new Object
[sArray.length];</tt></b>
      </ul>
      <li> Java does do range checking.&nbsp; All arrays
have a field
length that never changes.</li>
    </ul>
    <li>C, C++ can also dynamically allocate storage from the
heap.</li>
    <ul>
      <li>C, C++ does not do range checking.</li>
    </ul>
  </ul>
  <dl>
  </dl>
</ul>

<ul>

  <dl>
    <dl>
      <li> Perl:</li>
      <dl>
        <li> variables names for arrays begin with "@"</li>
        <li> storage is dynamically allocated</li>
        <li> example:</li>
        <br>
        <tt>@myPerlarr = ("one","two","three");</tt><br>
        <tt>$myPerlarr[0]&nbsp;&nbsp; </tt>is the
scalar with value <tt>"one"</tt><br>
        <tt>@myPerlarr[26] = "wow";</tt>
        <dl>
          <li> <tt>Extends the array to length 26.</tt></li>
        </dl>
      </dl>
      <h4>
      <hr size="1" width="100%">How is the array
stored in
memory?&nbsp; Runtime calculation of array element.</h4>
      <dl>
        <h4> <a name="effectiveAddress"></a>Computing
effective
address:</h4>
        <li>Arrays in most language implementation are stored in
contiguous location in memory. &nbsp;</li>
        <li> Some languages arrays of arrays.</li>
        <dl>
          <dl>
&nbsp;
          </dl>
        </dl>
      </dl>
      <a href="IMAGES/2cArrays.gif"><img style="border: 0px solid ; width: 629px; height: 298px;" alt="Arrays" src="IMAGES/2cArrays.gif"> </a>
    </dl>
  </dl>
</ul>

<div style="margin-left: 40px;">
<ul>
  <li> Left declaration is a true two-dimensional array.</li>
  <li> Right declarations is an array of pointers to
array of
chars.</li>
  <li>What are the trade offs? &nbsp; </li>
</ul>
</div>

<ul>

  <dl>
    <dl>
      <dl>
      </dl>
    </dl>
  </dl>
</ul>

<dl style="margin-left: 80px;">

  <li>The key feature of arrays is <b><i>O</i>
(1)</b> access
time
to any array element.<br>
  </li>
  <li> Formula for computing the effective address of a one
dimensional array:</li>
  <dl>
    <li> <tt>A: array [LowerBound .. UpperBound]</tt></li>
    <li> Let <i>ba</i> be the base address of
array A, and</li>
    <li> Let <i>size</i> be the number of
addressable
units(bytes)
required to store a value of base type of A.</li>
    <li> &nbsp;Then the effective address of <i>A</i>[<i>k</i>]
is:</li>
    <dl>
      <li> <i>ba</i> + <i>size </i>*
(<i>k</i> - LowerBound of <i>A</i>)</li>
      <li>As you can see the cost of computing <i>A</i>[<i>k</i>]
is independent of <i>k.<br>
</i><br>
      </li>
    </dl>
  </dl>
  <li> <span style="font-weight: bold;">Multidimensional arrays</span>:&nbsp; Where does the
second
element of the array go?&nbsp;</li>
  <dl>
    <li> <tt>A: array [LowerBound .. UpperBound ] of
array
[1..4]
of char</tt></li>
    <a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/2majorOrderArr.gif">
    </a>
  </dl>
</dl>

<dl style="margin-left: 160px;">

  <li>Row-major
-- Rows are contiguous in memory A[2,4] is followed by A[2,5]</li>
  <li>Column-major major columns are contiguous, A[2,4] is
followed by A[3,4]</li>
  <li>Fortran uses Column major most languages uses row major -- <br>
  </li>
</dl>
<dl style="margin-left: 160px;">
  <li>What is the implications for porting code? (Cache?, program correctness?)<br>
  </li>
</dl>



<ul style="margin-left: 40px;">

  <dl>
    <dl>
      <dl>
        <a href="2majorOrderArr.gif"> </a>
      </dl>
    </dl>
  </dl>
</ul>

<ul>

  <dl>
    <dl>
      </dl></dl>
</ul>
<dl>
  <h4>
      <hr size="1" width="100%"> </h4>
</dl>
<ul>
  <dl>
    <dl>

      <h4>Can arrays be initialized when they have their storage
allocated?</h4>
      <dl>
        <li> Initialization: In FORTRAN, Java, C and Ada, arrays
can be
initialized in their declaration.</li>
        <li> Forcing a &#8220;2 dimensional&#8221; array
representation with
initialization in Java:</li>
        <dl>
          <dl>
            <b><tt>double[ ] [ ] identity = {</tt></b>
            <dl>
              <b><tt>{ 1.0, 0.0, 0.0 },</tt></b><br>
              <b><tt>{ 0.0, 1.0, 0.0 },</tt></b><br>
              <b><tt>{ 0.0, 0.0, 1.0 }</tt></b>
            </dl>
            <b><tt>};</tt></b>
          </dl>
          <li> Note: "global" variables in Java are initialized
(0,nil)
but NOT local variables.</li>
        </dl>
      </dl>
      <hr size="1" width="100%">
    
    </dl>

  
  </dl>

</ul>

<blockquote>
  <blockquote>
    <h4>Haskell, Prolog</h4>
    <ul>
      <li>Do not have arrays.</li>
      <li><b><i>list</i></b>s are the way
to sequence data.</li>
      <li>How are lists different from arrays?</li>
    </ul>
    <br>
  </blockquote>
</blockquote>

<ul>

  <li>Programming in C++, C# and Java you should use collection
frameworks provided in the languages.</li>
</ul>

<hr size="1" width="100%">
<h3>Pointers:</h3>

<ul>

  <li>C, C++ pointer types</li>
  <ul>
    <li>polymorphic data types</li>
  </ul>
  <dl style="font-family: monospace;">
    <dd>int * x;</dd>
  </dl>
  <dl style="font-family: monospace;">
    <dd>float * y;</dd>
  </dl>
  <ul>
    <li>the R-value is an address<br>
    </li>
  </ul>
  <br>
  <li>C pointers' "units" are adjusted according to the size of
the
type
they point to. <br>
  </li>
</ul>

<div style="margin-left: 40px;"><span style="font-family: monospace;">m<span style="font-weight: bold;">ain(){</span></span><br style="font-family: monospace; font-weight: bold;">
<span style="font-family: monospace; font-weight: bold;">&nbsp; char*
ptChr =0; </span><br style="font-weight: bold;">
<span style="font-family: monospace; font-weight: bold;">&nbsp; short*
ptShort =0;</span><br style="font-weight: bold;">
<span style="font-family: monospace; font-weight: bold;">&nbsp; long*
ptLong =0;</span><br style="font-family: monospace; font-weight: bold;">
<span style="font-family: monospace; font-weight: bold;">&nbsp; int i;</span><br style="font-family: monospace; font-weight: bold;">
<span style="font-family: monospace; font-weight: bold;">&nbsp;</span><br style="font-family: monospace; font-weight: bold;">
<span style="font-family: monospace; font-weight: bold;">&nbsp;
printf("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Index Char Short&nbsp; Long\n");</span><br style="font-family: monospace; font-weight: bold;">
<span style="font-family: monospace; font-weight: bold;">&nbsp; for ( i
=0; i &lt; 6; i++) {</span><br style="font-family: monospace; font-weight: bold;">
<span style="font-family: monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;
printf("Offset of Pointers %d&nbsp;&nbsp;&nbsp;
%d&nbsp;&nbsp;&nbsp; %2d&nbsp;&nbsp;&nbsp;
%2d\n",</span><br style="font-family: monospace; font-weight: bold;">
<span style="font-family: monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; i, ptChr+i, ptShort+i, ptLong+i);</span><br style="font-family: monospace; font-weight: bold;">
<span style="font-family: monospace; font-weight: bold;">&nbsp; }</span><br style="font-family: monospace; font-weight: bold;">
<span style="font-family: monospace; font-weight: bold;">}</span><br style="font-family: monospace; font-weight: bold;">
</div>

<div style="margin-left: 40px; font-weight: bold;">~&gt;<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp; &nbsp;Index Char Short Long</tt><br>
<tt>Offset of Pointers &nbsp;0&nbsp; &nbsp;
0&nbsp;&nbsp;&nbsp;&nbsp;
0&nbsp; &nbsp; 0</tt><br>
<tt>Offset of Pointers &nbsp;1&nbsp; &nbsp;
1&nbsp;&nbsp;&nbsp;
&nbsp;2&nbsp;&nbsp;&nbsp; 4</tt><br>
<tt>Offset of Pointers &nbsp;2&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp;&nbsp;&nbsp;
4&nbsp;&nbsp;&nbsp; 8</tt><br>
<tt>Offset of Pointers &nbsp;3&nbsp; &nbsp;
3&nbsp;&nbsp; &nbsp;
6&nbsp;&nbsp; 12</tt><br>
<tt>Offset of Pointers &nbsp;4&nbsp; &nbsp;
4&nbsp;&nbsp;&nbsp;&nbsp;
8&nbsp;&nbsp; 16</tt><br>
<tt>Offset of Pointers &nbsp;5&nbsp; &nbsp;
5&nbsp;&nbsp;&nbsp;
10&nbsp;&nbsp; 20</tt></div>

<ul>

  <li> C++ allows functions to return l-values</li>
  <ul style="font-weight: bold;">
    <tt>int a[10];</tt><br>
    <tt>int&amp; f(int I) { return (a[I]); }</tt><br>
    <tt>f(5) = 17;</tt><br>
    <tt>// This assigns 17 to a[5]</tt>
  </ul>
</ul>

<ul>

  <dl>
    <li> Pointer (access) types provide a way of manipulating
memory
addresses.</li>
    <li> Pointers may be used to create recursive types, e.g.
linked
list and trees.</li>
  </dl>
</ul>

<ul>

  <dl>
    <li> C example:</li>
    <ul>
      <p> <b><tt>typedef struct tree {</tt></b> <b><tt><br>
&nbsp;&nbsp; int val;</tt></b><b><tt><br>
&nbsp;&nbsp; struct tree* right;</tt></b><span style="font-family: monospace;"><span style="font-weight: bold;"><br>
&nbsp;&nbsp; struct
tree* left;</span></span> <b><tt><br>
}</tt></b><br>
      </p>
    </ul>
  </dl>
</ul>

<h3>Pointers and Arrays in C</h3>

<ul>

  <li> There is a close correspondence between types "<i>array
of Ttype"</i>
and <i>"pointer to Ttype"</i>.</li>
  <br>
  <tt style="font-weight: bold;">int a[10], *ip;</tt><br style="font-weight: bold;">
  <tt style="font-weight: bold;">ip = a;</tt><br style="font-weight: bold;">
  <tt style="font-weight: bold;">ip = &amp;a[0];</tt><br>
&nbsp;
  <ul>
    <li><span style="font-family: monospace;"> a[i] </span>can
be defined as <span style="font-family: monospace;">*(( a
)+( i ))</span></li>
    <li> In fact <b><tt>a[i]</tt></b> is
the same as <b><tt>i[a]</tt></b>!</li>
    <li>Since <tt>ip = a;&nbsp;</tt>is legal is <tt>a = ip;&nbsp;</tt>legal?</li>
  </ul>
</ul>

</body></html>