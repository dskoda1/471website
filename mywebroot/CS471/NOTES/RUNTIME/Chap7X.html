<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="content-type"><title>Chap7 --</title></head><body><h3>Polymorphism:</h3>








<ul><li> Ways the Language allows you to code routines with the
same
identifier but the actual parameters can be of different types.</li></ul>








<a href="IMAGES/16poly.gif"><img style="border: 0px solid ; width: 371px; height: 188px;" alt="Polymorphic Diagram" src="IMAGES/16poly.gif"></a>
<br>








<br>








<ul><li> Polymorphism is a bad term to use.</li><li>Helpful definitions:</li></ul>








<dl><dd>"A function or operator is <span style="font-style: italic;">polymorphic</span>
is it has at least two possible types."<sup>1</sup><br>








"A function or operator exhibits <span style="font-style: italic;">ad
hoc</span> <span style="font-style: italic;">polymorphism</span>
if it
has at least two but only <span style="font-weight: bold;">finitely
    </span>many
possible types."<sup>1</sup><span style="font-style: italic;"><span style="font-style: italic;"><span style="font-style: italic;"></span></span></span><br>








"A function or operator exhibits <span style="font-style: italic;">universal
polymorphism</span> if it has infinitely many possible types"<br>








  </dd></dl>








<h3> Overloading</h3>








<ul><li> When the same symbol translates to different code based on
the
(static) actual parameter types:<br>








  </li>








We say that the operator/function is overloaded.
</ul>








<ul><li>Which code is usually bound statically (before runtime)<br>








  </li><li> In most languages &#8216;+&#8217; corresponds to
different code i.e.:</li><ul><tt>3 + 4</tt></ul><tt>Vs</tt><ul><tt>3.6&nbsp; +&nbsp; 4.1<br>








    <br>








    </tt></ul><li> Java adds another meaning to &#8216;+&#8217;</li><ul><tt>&#8220;one&#8221; + &#8220;two&#8221;</tt></ul><li> Ada and C++ allow users to overload operators.</li><ul><li>The interaction between overloading and coercion can be
very
tricky.<br>








    </li></ul><li> C has no USER overloading -- operators or functions</li><li>Java does not allow users to overload operators.</li><li> &nbsp;<a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/5rAdaOverload.html">Overload
Example from Ada</a></li></ul>








<h4>Dangerous Overloading of Operators</h4>








<ul><li> C</li><tt>z = &amp;y&nbsp; /* assign the address of y to x */</tt><br><tt>z = x &amp; y /*assign the bit-wise AND of x and y */</tt><li>
Fortran:</li><ul><tt>AVG = SUM/COUNT</tt></ul>








( If SUM=20 and COUNT=30 are integers and AVG is a real variable. Then
AVG will be 0.0) <li> Pascal uses a different symbols for
integer
division and real division.&nbsp; div vs &#8216;/&#8217;</li><li> Ada makes the above statement illegal since the types do
not
match!</li></ul>








<hr noshade="noshade" size="2" width="60%">
<h3>Inclusion Polymorphism&nbsp; Also called subtype
Polymorphism--- <br>








</h3>








<ul><li>A function or operator exhibits <span style="font-style: italic;">inclusion</span>(<span style="font-style: italic;">subtype) polymorphism</span>
if one or
more
of its parameter type have subtypes.</li><li>Ada, Pascal, Haskell, small talk, C++ and Java allow
subtyping.</li></ul>








<hr noshade="noshade" size="2" width="60%">
<h3>Object Oriented Programming Languages <br>








</h3>








are characterized by their support of 4 facilities
<ul><li>Encapsulation<br>








  </li><li>Inheritance</li><li>Inclusion polymorphism</li><li>Dynamic binding of function calls to function bodies
(dynamic
dispatching)</li></ul>








<h4>Object Oriented languages without CLASSES</h4>








<ul><li>Prototype-based languages<br>








  </li><ul><li>Self, JavaScript</li><li>No constructors -- new objects are created from scratch
by
listing all methods</li><li>Usually dynamically typed. <br>








    </li><li>Usually very small amount of encapsulation<br>








    </li><li>No static inheritance --&nbsp; uses a
dynamic&nbsp; mechanism
called <i>delegation</i> <br>








    </li><ul><li>What is a Computer? <br>








        
        
        
        
        
        
        
        <table style="text-align: left;" border="0" cellpadding="2" cellspacing="2" width="85%">








          <tbody>








            <tr>








              <td align="left" valign="top">Class
Based - lists<br>








              </td>








              <td align="left" valign="top">Prototyped
Base</td>








            </tr>








            <tr>








              <td valign="top">
              
              
              
              
              
              
              
              <ul><li>CPU</li><li>keyboard</li><li>Monitor <br>








                </li></ul>








              </td>








              <td valign="top">
              
              
              
              
              
              
              
              <ul><li>like an Apple Computer<br>








                </li></ul>








              </td>








            </tr>








          
          
          
          
          
          
          
          </tbody>
        
        
        
        
        
        
        
        </table>








      </li></ul></ul></ul>








<h4 style="margin-left: 80px;"><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/HASKELL/3hJF03.html">Inclusion
Polymorphism&nbsp; --- Run-time
dispatching</a></h4>








<h4>Parametric Polymorphism</h4>








to be discussed later.
<hr style="width: 100%; height: 2px;">
<h4>C++ -- Memory Leaks and an interesting way to handle it.</h4>








<ul><li>What is the life and scope of the variables in the
following
code?</li></ul>








<div style="margin-left: 40px;">
<dl style="font-family: monospace; font-weight: bold;"><dd>{ int i = 7;<br>








&nbsp; int *p = new int; /* also new int(); */<br>








&nbsp; *p = 4;<br>








}<br>








  </dd></dl>








</div>








<ul><ul><li>How do we correct the memory leak?</li></ul></ul>








<ul><li>&nbsp;A class that handles the delocation
responsibility (good
for stack variables)<br>








  </li></ul>








<div style="margin-left: 40px;">
<dl><dd><span style="font-family: monospace;"><span style="font-weight: bold;">class SuperPtr {<br>








&nbsp;superPtr(){<br>








&nbsp; &nbsp;prt = new int;<br>








&nbsp;}<br>








&nbsp;~superPtr() {<br>








&nbsp; &nbsp;delete ptr;<br>








&nbsp;}<br>








&nbsp;int* ptr;<br>








}<br>








    </span></span></dd></dl>








<ul><ul><li>What happens when you try to use it? i.e.</li></ul></ul>








<dl><dd><span style="font-family: monospace;"><span style="font-weight: bold;">{ &nbsp;...<br>








&nbsp; superPtr sp;<br>








&nbsp; &nbsp;...<br>








}<br>








    </span></span></dd></dl>








</div>








<ul><dd><span style="font-family: monospace;"><span style="font-weight: bold;"> </span></span><br>








    <span style="font-family: monospace;"><span style="font-weight: bold;"> </span></span></dd><ul><li>To make useful we want SuperPtr objects to behave link
pointers
overload the pointer operator ("*"). So include the method:</li></ul><div style="margin-left: 40px;">
  
  
  
  
  
  
  
  <dl><dd><span style="font-family: monospace;"><span style="font-weight: bold;">SuperPrt:: operator * () {<br>








&nbsp; return *prt; &nbsp;// <small>returns the
reference of the
location prt was pointing to</small> <br>








}</span></span><br>








      <br>








    </dd></dl>








  
  
  
  
  
  
  
  <ul><ul><li>Now we can write:&nbsp;</li></ul><dl><dt><span style="font-family: monospace;"><span style="font-weight: bold;">{ SuperPrt sp;<br>








&nbsp; &nbsp;...<br>








&nbsp; &nbsp;*sp = 7;<br>








&nbsp; &nbsp;...<br>








}<br>








        </span></span></dt></dl><ul><li>What happens during execution?</li></ul><dl><dd><br>








        <br>








      </dd></dl></ul>








  </div><ul><li>Extending SuperPtr class to the <i><a href="file:///mnt/extra/homes/head/Courses/471/NOTES/RunTime/2rS04.html#pair">pair&lt;int,
int&gt;</a>, &nbsp;</i>we need to overload both the
"*" and "-&gt;"</li></ul><div style="margin-left: 40px;">
  
  
  
  
  
  
  
  <dl><dd><tt><b>class SuperPtr {<br>








      <br>








&nbsp; public : <br>








&nbsp; &nbsp;SuperPtr() { prt = new pair&lt;int,
int&gt; (); }<br>








&nbsp; &nbsp;~SuperPtr() { delete prt; }<br>








&nbsp; &nbsp;pair&lt;int,int&gt; * prt;<br>








&nbsp; &nbsp;pair&lt;int,int&gt; &amp; operator* ();<br>








&nbsp; &nbsp;pair&lt;int,int&gt; * operator -&gt;();<br>








&nbsp; &nbsp;<br>








}<br>








pair&lt;int,int&gt;&amp; SuperPrt::operator*() { return
*prt; }<br>








pair&lt;int,int&gt;* SuperPrt::operator-&gt;() { return
prt; }<br>








... SuperPrt::f(...) {...}<br>








      <br>








//<i>Using it<br>








      <br>








      </i>void fun(void){ <br>








&nbsp; &nbsp;SuperPtr Sp; &nbsp;//<small> Where is
SuperPtr ? where is
prt?</small><br>








&nbsp; &nbsp;Sp-&gt; first=7; //<small>Returns a
reference to member <i>prt.</i>So
executes like prt-&gt;first</small><br>








&nbsp; &nbsp;SuperPtr* S = new SuperPtr;<br>








&nbsp; &nbsp;(*S); &nbsp;// <small>dereference
operator,&nbsp;</small> <br>








&nbsp;&nbsp; S-&gt; f(); // <small>component
selection operator</small><br>








&nbsp; &nbsp;(*S)-&gt;first; // <small>Overloaded
"-."</small><br>








      </b></tt></dd></dl>








  
  
  
  
  
  
  
  <dl><dd>}<br>








    </dd></dl>








  <span style="font-family: monospace;"></span></div><a href="http://ootips.org/yonat/4dev/smart-pointers.html">More
tips
on
smart-pointers</a></ul>










<p></p></body></html>