<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html><head>



  
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

  
  <meta name="Author" content="Eileen Head">

  
  <meta name="GENERATOR" content="Mozilla/4.77 [en] (Windows NT 5.0; U) [Netscape]"><title>Routines - Parameter Passing</title></head><body>
<br>

<center>
<h3>Parameter Passing Semantics: Fall 15<br>
</h3>
</center>

<h3> Goal: Explore various different parameter passing schemes
and
typing of functions.</h3>

<h3> What will be covered ?</h3>

<ul>

  <li> The semantics of different parameter passing mechanisms</li>
  <li> Named parameters</li>
</ul>

<hr width="100%"> <span style="font-weight: bold;">Subprograms/subroutines/functions
and Parameters</span>
<ul>

  <hr width="100%">Ada Example:
  <p><b><tt>PROCEDURE max (x,y : in INTEGER; maximum
: out INTEGER) is</tt></b> </p>
  <ul>
    <b><tt>BEGIN</tt></b> <br>
    <b><tt>&nbsp; IF x &gt; y THEN</tt></b>
    <ul>
      <b><tt>maximum := x;</tt></b>
    </ul>
    <b><tt>&nbsp; ELSE</tt></b>
    <ul>
      <b><tt>maximum := y;</tt></b>
    </ul>
    <b><tt>&nbsp; END IF;</tt></b> <br>
    <b><tt>END max;<br>
    <br>
    <br>
    <br>
    </tt></b>
  </ul>
  <b><tt>FUNCTION max1 (x,y : in INTEGER) return INTEGER is</tt></b>
  <ul>
    <b><tt>BEGIN</tt></b> <br>
    <b><tt>&nbsp; IF x &gt; y THEN</tt></b>
    <ul>
      <b><tt>return x;</tt></b>
    </ul>
    <b><tt>&nbsp; ELSE</tt></b>
    <ul>
      <b><tt>return y;</tt></b>
    </ul>
    <b><tt>&nbsp; END IF;</tt></b> <br>
    <b><tt>END max1;<br>
    <br>
    <br>
    </tt></b>
  </ul>
</ul>

<hr width="100%"> <span style="font-weight: bold;">Parameter
Passing Mechanisms</span>
<dl>

  <li> One of the most important design decisions is which
parameter
passing methods are implemented</li>
</dl>

<div style="margin-left: 40px;">
<dl>
  <li> Pass by Value (Pass by&nbsp;<span style="font-style: italic;">assignment</span>,
Pass by <span style="font-style: italic;">sharing</span>)</li>
  <li> Pass by Result</li>
  <li> Pass by Value Result (also called Copy in, Copy out)</li>
  <li> Pass by Reference</li>
  <li> Pass by Name</li>
</dl>
</div>

<dl>

  <dl>
    <br>
    <hr width="100%">
    <h4> Pass by Value (Pass by "assignment")
&nbsp;</h4>
  </dl>
</dl>

<ul>

  <li>Default mechanism in Pascal, Modula-2, Ada and C#</li>
  <li>Main mechanism in C and Algol 68, Swift and Objective C</li>
  <ul>
    <li>Swift(2.0) treats parameters as constants<br>
      <div style="margin-left: 40px;"><span style="font-family: monospace; font-weight: bold;">func foo(i: Int) {</span><br style="font-family: monospace; font-weight: bold;">
      <span style="font-family: monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp; i++ // COMPILER ERROR</span><br style="font-family: monospace; font-weight: bold;">
      <span style="font-family: monospace; font-weight: bold;">}</span><br>
      <span style="font-family: monospace; font-weight: bold;"></span></div>
      <br>
      <span style="font-weight: bold;"></span></li>
    <li><span style="font-weight: bold;">to allow modification in function<br>
      </span>
      <div style="margin-left: 40px;"><span style="font-weight: bold;"><span style="font-family: monospace;">func foo(var i: Int) {</span></span><br style="font-family: monospace;">
      <span style="font-weight: bold;"><span style="font-family: monospace;">&nbsp;&nbsp;&nbsp; i++</span></span><br style="font-family: monospace;">
      <span style="font-weight: bold;"><span style="font-family: monospace;">}</span></span><br style="font-family: monospace;">
      <span style="font-weight: bold;"><span style="font-family: monospace;">// ...</span></span><br style="font-family: monospace;">
      <span style="font-weight: bold;"><span style="font-family: monospace;">var x = 1</span></span><br style="font-family: monospace;">
      <span style="font-weight: bold;"><span style="font-family: monospace;">foo(x)</span></span><br style="font-family: monospace;">
      <span style="font-weight: bold;"><span style="font-family: monospace;">println(x)</span></span><br>
      <span style="font-weight: bold;"></span></div>
      <br>
    </li>
    <ul>
      <br style="font-family: monospace; font-weight: bold;">
    </ul>
  </ul>

  <li>Behavior depends on whether the language uses a&nbsp;<span style="font-style: italic;">value</span> model
or&nbsp;<span style="font-style: italic;">reference&nbsp;</span>model.</li>
  <ul>
    <li><b>Only</b> mechanism in Java and Python</li>
    <li>immutable vs mutable objects</li>
  </ul>
</ul>

<dl>

  <dl>
    <dl>
      <br>
      <hr size="1" width="100%">
    </dl>
  </dl>
</dl>

<div style="margin-left: 40px;"><span style="font-weight: bold;">Pascal,
Java and Modula-2 parameters are treated like initialized local
variables</span>
<dl>
  <li> Assignments to the parameters do not cause changes
outside
the subprogram</li>
  <li> Ada: The <i>in</i> parameter may not be
assigned to</li>
  <li> Java: The keyword <i>final</i> prevents
assigning to the
parameter at all.</li>
</dl>
<hr size="1" width="75%"> What kinds of methods can not be easily coded?</div>

<dl>

</dl>

<div style="margin-left: 40px;">
<ul>
  <li>Swap &nbsp;-- Can a subroutine be written to exchange the value
of 2 parameter?</li>
</ul>
</div>

<hr size="1" width="75%">
<div style="margin-left: 40px;"><span style="font-weight: bold;">Evaluation
of parameters</span> </div>

<div style="margin-left: 40px;">
<dl>
  <li>Order of evaluation of parameters with side effects
can be
resolved by insisting on an order in evaluating (right to left or left
to right).</li>
  <dl>
    <li> Java enforces the above</li>
  </dl>
  <li> Most languages the evaluation order is implementation
dependent.</li>
</dl>
</div>

<dl>

  <hr size="1" width="100%"><span style="font-weight: bold;">Parameter
Evaluation and Side Effects</span><br>
</dl>

<div style="margin-left: 40px;">
<dl>
  <li> Try on a variety of C and
C++
compilers:&nbsp;</li>
</dl>
<div style="margin-left: 120px;"><b><tt>y = -1;<br>
</tt></b><b><tt>upOnly(++y, ++y);</tt></b><br>
</div>
</div>

<div style="margin-left: 40px;">
<dl>
  <dl>
    <dl>
      <li>Some implementations evaluate the first parameter
(and
modify it) before the second, others evaluate the last parameter first.</li>
      <li> Some language definitions make this dependency an
error.</li>
    </dl>
  </dl>
</dl>
</div>

<dl>

  <dl>
    <hr size="3" width="100%">
    <h4> Pass by Reference <br>
    </h4>
  </dl>
</dl>

<div style="margin-left: 40px;"><b><tt>program Test();<br>
</tt></b><b><tt>var innocent :integer;<br>
<br>
</tt></b><b><tt>procedure modify(var Share: integer);<br>
</tt></b>
<div style="margin-left: 40px;">
<dl>
  <b><tt>begin</tt></b><span style="font-family: monospace;"><span style="font-weight: bold;"><br>
  </span></span>
</dl>
<div style="margin-left: 40px;"><b><tt>Share := Share + 3;</tt></b></div>
<dl>
  <b><tt>end;</tt></b><br>
</dl>
</div>
<dl>
  <b><tt>&nbsp;begin <br>
  </tt></b>
</dl>
<div style="margin-left: 40px;">
<dl>
  <b><tt>innocent := 100;</tt></b><br>
  <b><tt>modify(innocent) {upon return innocent is
103}</tt></b>
</dl>
</div>
<dl>
  <b><tt>&nbsp;end; &nbsp; </tt></b><br>
&nbsp;
</dl>
</div>

<dl>

  <dl>
    <ul>
      <dl>
        <dl>
        </dl>
        <li> The argument's allocated location is bound to the
parameter
during the call.</li>
      </dl>
    </ul>
  </dl>
</dl>

<div style="margin-left: 120px;">The parameter becomes an <b>alias</b>
for the argument<b>.</b></div>

<dl>

  <dl>
    <ul>
      <dl>
        <dl>
        </dl>
        <li> Therefore any changes to the parameter will have
affects
outside the called subprogram.</li>
        <li> Arguments must have l-values.</li>
        <li> This is the only mechanism in Fortran 77 and earlier.</li>
        <li> Pascal, Modula 2 use the keyword <i>VAR</i>
to signal
pass by reference</li>
        <li>C# use the keyword <span style="font-style: italic;">ref </span>to
signal
pass by reference</li>
        <dl>
          <hr noshade="noshade" size="1" width="100%">
        </dl>
      </dl>
      <span style="font-style: italic;"></span>
    </ul>
  </dl>
</dl>

<div style="margin-left: 40px;">
<dl>
  <li>Simulation
of pass by reference<span style="font-style: italic;"></span> </li>
</dl>
</div>

<dl>

  <dl>
    <ul>
      <dl>
      </dl>
    </ul>
  </dl>
</dl>

<div style="margin-left: 80px;">
<dl>
  <li> C &amp; Algol68: A pointer is used to pass a
location
explicitly.<br>
  </li>
  <li> In C:&nbsp; pass by value (<span style="font-style: italic;">assignment</span>)
a
pointer type.<br>
  </li>
</dl>
</div>

<div style="margin-left: 80px; font-family: monospace;"><b>void refer
(int *x) {<br>
</b>
<div style="margin-left: 40px;"><b><tt>*x += 1;</tt></b></div>
<b>}</b><br>
<b>int main() {</b><br>
<div style="margin-left: 40px;">
<dl>
  <b><tt>int a;</tt></b><br>
  <b><tt>&#8230;</tt></b><br>
  <b><tt>refer(&amp;a);</tt></b>
</dl>
</div>
}<br>
</div>

<dl>

  <dl>
    <ul>
      <li>C: Arrays are passed with the same semantics as <span style="font-style: italic;"></span>reference
"types" are passed
in Java.</li>
      <dl>
        <dd style="font-family: monospace; font-weight: bold;">int
passArr( int [] a) {</dd>
        <dt style="font-family: monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
...</dt>
        <dd><span style="font-family: monospace; font-weight: bold;">}</span><br>
        </dd>
      </dl>
      <li>C++ has introduced explicit "pass-by-reference" by
introducing a&nbsp;<span style="font-style: italic;">reference</span>
type -- alias --</li>
    </ul>
  </dl>
</dl>

<div style="margin-left: 120px;"><b><tt>void refer(int&amp; x){<br>
</tt></b>
<div style="margin-left: 40px;"><b><tt>x += 1;</tt></b></div>
<b><tt>}<br>
</tt></b><b><tt>void fun() {</tt></b><br>
<div style="margin-left: 40px;">
<dl>
  <b><tt>int&nbsp; a;</tt></b><br>
  <b><tt>...</tt></b><br>
  <b><tt>refer(a);</tt></b>
</dl>
</div>
<b><tt>}<br>
</tt></b></div>

<dl>

  <dl>
    <ul>
      <dl>
        <dl>
          <br>
          <hr noshade="noshade" size="1" width="100%">
        </dl>
        <li> C++: The ref type can be used other in locations :</li>
      </dl>
    </ul>
  </dl>
</dl>

<div style="margin-left: 120px;"><b><tt>void f() {<br>
</tt></b>
<div style="margin-left: 40px;">
<dl>
  <b><tt>int i;</tt></b><br>
  <b><tt>int &amp;r = i;&nbsp;</tt></b>//
r refers to i <br>
  <b><tt>r = 9;&nbsp;</tt></b>//
the value i becomes is 9 <br>
i<b><tt>nt * p = &amp;i;&nbsp;</tt></b>//
p points to i <br>
  <b><tt>int &amp; rr = r ;</tt></b>&nbsp;//
rr&nbsp;refers
to
i
</dl>
</div>
<b><tt>}</tt></b> <br>
</div>

<dl>

  <dl>
    <ul>
      <dl>
        <dl>
          <h6>(Ellis &amp; Stroustup,<i>Annotated C++, </i>page 153)</h6>
          <hr noshade="noshade" size="1" width="100%">
        </dl>
      </dl>
    </ul>
  </dl>
</dl>

<div style="margin-left: 120px;"><b><tt>procedure swap (var x: integer,</tt></b><br>
<b><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
var y: integer);</tt></b>
<div style="margin-left: 40px;">
<dl>
</dl>
<b><tt>var z:integer</tt></b><br>
<b><tt>begin<br>
</tt></b>
<div style="margin-left: 40px;">
<dl>
  <b><tt>z:=x;</tt></b><br>
  <b><tt>x:=y;</tt></b><br>
  <b><tt>y:=z;</tt></b>
</dl>
</div>
<b><tt>end<br>
</tt></b>
<dl>
</dl>
</div>
<b><tt>}</tt></b> <br>
</div>

<dl style="margin-left: 120px;">

</dl>

<dl>

  <dl>
    <ul>
      <dl>
        <li> Early versions of Fortran did not check if the
actual
parameter was assignable.</li>
      </dl>
    </ul>
  </dl>
</dl>

<div style="margin-left: 120px;">
<ul>
  <li> Calling swap(1,2) would result in the constants
being
interchanged.&nbsp; Later the code would calculate 1+1 = 4.</li>
</ul>

</div>

<div style="margin-left: 40px;">
<hr style="width: 100%; height: 2px;"></div>
<div style="margin-left: 80px;"><span style="font-weight: bold;">R-Value references &amp; c++11 <span style="font-style: italic;">move constructor</span><br>
</span>
<ul>
  <li><a target="_blank" href="http://www.drdobbs.com/cpp/moving-and-rvalue-references/240157455">Moving and Rvalue References | Dr Dobb's</a></li>
  <li><a target="_blank" href="http://thbecker.net/articles/rvalue_references/section_01.html">C++ Rvalue References Explained by Thomas Becke</a>r<br>
  </li>
</ul>
<span style="font-weight: bold;">
</span></div>
<dl>
<dl><ul>
    </ul>
    <hr size="3" width="100%">
    <h4> <b>Pass by Value-Result</b></h4>
    <ul>
      <dl>
        <li> Also called <b>COPY-IN, COPY-OUT.</b></li>
        <li> In Ada, this is the mechanism of the IN OUT
parameter for
scalar types</li>
        <li>In Swift the keyword is <span style="font-weight: bold;">inout</span> <br>
        </li>

        <li> Aliasing distinguishes pass by value-result from
pass by
reference</li>
        <br>
      </dl>
    </ul>
  </dl>
</dl>

<div style="margin-left: 80px;"><b><tt>a : INTEGER;</tt></b><br>
<b><tt>PROCEDURE p(x,y: IN OUT INTEGER) is<br>
<br>
</tt></b>
<div style="margin-left: 40px;"><b><tt> BEGIN</tt></b>
<div style="margin-left: 40px;">
<dl>
  <b><tt>x := x + x ;</tt></b><br>
  <b><tt>y := y + y;</tt></b>
</dl>
</div>
<b><tt>END;</tt></b>
<p><b><tt>BEGIN</tt></b> </p>
<div style="margin-left: 40px;">
<dl>
  <b><tt>a := 1;</tt></b><br>
  <b><tt>p(a,a);</tt></b>
</dl>
</div>
<b><tt>END;</tt></b></div>
</div>

<dl>

  <dl>
    <ul>
      <dl>
        <br>
Assuming pass by reference what is the last value
of "a"? <br>
        <br>
Assuming pass by Copy-in Copy-out what is the last
value
of
"a"?<br>
        <br>
        <br>
        <br>
        <hr size="1" width="100%">
      </dl>
    </ul>
  </dl>
</dl>

<h4 style="margin-left: 80px;">Issues left unspecified </h4>

<dl>

  <dl>
    <ul>
      <dl>
        <li> Order the results are copied back</li>
        <li> Are the locations of arguments stored or
recalculated on
return?</li>
        <li> ADA Quirk:&nbsp; Ada's definition states that in
out
parameters may be implemented as pass by reference or pass by
value-result for non-scalar types.</li>
        <br>
        <hr size="1" width="100%">
      </dl>
    </ul>
  </dl>
</dl>

<h4 style="margin-left: 80px;">Another Swap&nbsp;: </h4>

<dl>

  <dl>
    <ul>
      <dl>
        <b><tt>ADA:<br>
        </tt></b>
      </dl>
    </ul>
  </dl>
</dl>

<div style="margin-left: 80px;"><b><tt>PROCEDURE Main IS<br>
</tt></b>
<div style="margin-left: 40px;"><b><tt>PROCEDURE
Swap(x,y: IN OUT integer) is</tt></b><b><tt><br>
&nbsp; BEGIN<br>
</tt></b>
<div style="margin-left: 40px;">
<dl>
  <b><tt>x := x + y;</tt></b><br>
  <b><tt>y := x - y;</tt></b><br>
  <b><tt>x := x - y;</tt></b><br>
</dl>
</div>
<dl>
  <b><tt>&nbsp; END;</tt></b><br>
</dl>
</div>
<b><tt>&nbsp; BEGIN</tt></b><b><tt><br>
&nbsp;&nbsp;&nbsp; a := 1;</tt></b><b><tt><br>
&nbsp;&nbsp;&nbsp; Swap(a,a);</tt></b> <b><tt>&nbsp;&nbsp;&nbsp; <br>
&nbsp; END;</tt></b>&nbsp; </div>

<dl>

  <dl>
    <ul>
      <dl>
        <p><b><tt>Pascal:</tt></b><br>
        </p>
      </dl>
    </ul>
  </dl>
</dl>

<div style="margin-left: 80px;"><b><tt>PROCEDURE MAIN<br>
</tt></b>
<div style="margin-left: 40px;"><b><tt>PROCEDURE Swap(VAR x,y:
integer);<br>
&nbsp; BEGIN<br>
</tt></b>
<div style="margin-left: 40px;">
<dl>
  <b><tt>x := x + y ;</tt></b><br>
  <b><tt>y := x - y ;</tt></b><br>
  <b><tt>x := x - y ;<br>
  </tt></b>
</dl>
</div>
<dl>
  <b><tt>&nbsp; END; <br>
  </tt></b>
</dl>
</div>
<dl>
  <b><tt>&nbsp;BEGIN <br>
&nbsp;&nbsp; a:= 1;<br>
&nbsp;&nbsp; Swap(a,a)<br>
&nbsp;END<br>
  <br>
  </tt></b>
</dl>
</div>

<dl>

  <dl>
    <ul>
      <dl>
        <li>What is the last value of
a after each is executed?</li>
      </dl>
    </ul>
  </dl>
</dl>

<br>

<br>

<dl>

  <dl>
    <ul>
      <dl>
        <dl>
          <hr size="1" width="100%">
        </dl>
        <li> What is the value of "a" after p is called? (Ada 1,
Pascal
0)</li>
        <li> Another difference:</li>
        <dl>
          <li> If the subprogram terminates abnormally (i.e.. via
an
exception handler) the actual parameter</li>
          <dl>
            <li> might have changed value using the call by
reference.</li>
            <li> but actual parameter will not change using call
by
value-result</li>
          </dl>
        </dl>
      </dl>
    </ul>
  </dl>
</dl>

<dl>

  <dl>
    <ul>
      <dl>
        <li> <a name="AdaMatrix"></a><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/4rAFall00.html">Swap
Problem 4 using Matrices in ADA</a></li>
      </dl>
    </ul>
    <hr size="3" width="100%">
    <h4> Pass by Name&nbsp;</h4>
    <ul>
      <dl>
        <li> Used in Algol 60&nbsp;</li>
        <li>Haskell implements a variation -- &nbsp;Lazy
evaluation</li>
        <li> Arguments are not evaluated until their actual use
in the
called program.</li>
        <li> Example:</li>
      </dl>
    </ul>
  </dl>
</dl>

<div style="margin-left: 80px;">
<dl>
  <b><tt>int i;</tt></b><br>
  <b><tt>int a[ ] = new int[2];</tt></b><br>
  <b><tt>void p(x) {&nbsp; //pass by name<br>
  </tt></b>
</dl>
<div style="margin-left: 40px;"><b><tt>i = i + 1;</tt></b><br>
<b><tt>x = x + 1;</tt></b><b><tt>&nbsp; </tt></b><br>
</div>
<dl>
  <b><tt>}</tt></b><br>
  <b><tt>void main() {<br>
  </tt></b>
</dl>
<div style="margin-left: 40px;">
<dl>
  <b><tt>i = 0;</tt></b><br>
  <b><tt>a[0] = 0;</tt></b><br>
  <b><tt>a[1] = 1;</tt></b><br>
  <b><tt>p( </tt></b><tt style="font-weight: bold;">a[i]</tt><b><tt>
);</tt></b>
</dl>
</div>
<dl>
  <b><tt>}</tt></b>
</dl>
</div>

<ul style="font-weight: bold;">

  <ul>
    <li>To &#8220;hand execute&#8221; pass by name,</li>
  </ul>
</ul>

<div style="margin-left: 80px;">
<dl>
  <li> just substitute the actual parameters textually in
place
of the formal parameters.</li>
  <li>In fact, each reference to a call by name reference
is
implemented
by</li>
</dl>
<div style="margin-left: 40px;"><b><i>jump out</i></b>
to the argument (called a <i>"thunk"</i>
)<br>
execute the argument expression <br>
<b><i>jump back</i> </b>into the
routine</div>
<dl>
  <li>Thus the above would be </li>
</dl>
</div>

<div style="margin-left: 160px;"><b><tt>in main: i = 0;</tt></b><br>
<span style="font-family: monospace;">&nbsp;<span style="font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;
a[0] = 0;</span><br style="font-weight: bold;">
<span style="font-weight: bold;">&nbsp; &nbsp;&nbsp;&nbsp; a[1] = 1;</span></span><br style="font-weight: bold;">
<b style="font-weight: bold;"><tt>in
p(x):</tt></b><span style="font-weight: bold;"><big> </big></span><small style="font-family: monospace; font-weight: bold;"><br>
&nbsp; &nbsp;&nbsp; i = i + 1; <br>
&nbsp;&nbsp;&nbsp;&nbsp; a[i] = a[i] +1;</small><br>
</div>

<dl>

  <dl>
    <ul>
      <dl>
        <br>
        <li> Unlike other languages, this code modifies a[1], not
a[0]!</li>
        <li> <a name="Jensen"></a><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/4rBFall00.html">Jensen's
Device</a> is an example showing the power of pass by name.</li>
      </dl>
    </ul>
  </dl>
</dl>

<hr noshade="noshade" size="2" width="50%">
<dl>

  <dl>
    <ul>
    </ul>
  </dl>
</dl>

<dl>

</dl>

<h4 style="margin-left: 40px;">
Functional Languages and Pass by Name </h4>

<dl>

  <dl>
  </dl>
</dl>

<ul>

  <li>Since functional languages do not have state changes a
variation
of
Pass by Name, Lazy evaluation, is an excellent mechanism for passing
variables.</li>
  <ul>
    <li>Lazy evaluation evaluates each argument at most once.</li>
  </ul>
  <li>This the main mechanism in Haskell.
    <dl>
      <li>This mechanism enables new and interesting programming
abstraction.</li>
    </dl>
  </li>
</ul>

<ul>

  <li>In non pure functional languages call by name is hard to
implement.</li>
  <li> If in evaluating&nbsp; the parameter, the parameter is
a
functions with side effects, you may effect in unexpected ways the
value of a variable in later use.</li>
  <li> The semantics of call by name is very difficult to very
messy to
implement.</li>
</ul>

<hr noshade="noshade" size="2" width="90%">
<h4 style="margin-left: 40px;">Macro expansion vs.
procedure "pass by name"</h4>

<ul>

  <li>Similarity: both "employ" textural substitution</li>
  <li>For procedural calls substitution is theoretical model how
the
parameter
bind.</li>
  <li>For macro expansion the textural substitution is the <b>actual
implementation</b></li>
  <li>The<b> #define</b>&nbsp; preprocessor
command (in <b>C</b> )
causes
an <i>identifier name</i> to become defined as macro to
preprocessor.</li>
  <li><i>function-like</i> macro definition:</li>
</ul>

<blockquote style="margin-left: 80px;"><b>#define <i>name</i>
( <i>name</i>1, <i>name</i>2<i>,
...)
body</i><i>&nbsp;</i></b></blockquote>

<ul>

  <li>invocation:</li>
</ul>

<blockquote style="margin-left: 80px;"><b><i>name</i>
( <i>arg</i>1, <i>arg</i>2 ...)</b><br>
</blockquote>

<ul>

  <li>example: If a macro sum with two arguments is defined by<br>
  </li>
</ul>

<blockquote style="margin-left: 80px;"><b><tt>#define
sum(x,y) &nbsp; x+y</tt></b><br>
</blockquote>

<ul>

  <li>then the preprocessor replaces the source line (before
compiling)</li>
</ul>

<blockquote>
  <div style="margin-left: 80px;"><b><tt>result
= sum (</tt><tt> a, 3*a +b )</tt></b>;<br>
  </div>
&nbsp; &nbsp; &nbsp; &nbsp;with<br>
  <div style="margin-left: 80px;"><b><tt>result
= a &nbsp;+ 3*a +b; </tt></b><br>
  </div>
</blockquote>

<ul>

  <li>The expansion steps:</li>
</ul>

<blockquote>
  <ol>
    <li>substitute text of macro call's argument for each
occurrence of <i>nameX</i>
in body</li>
    <li>substitute resulting body for the macro call</li>
  </ol>
</blockquote>

<ul>

  <li>Swap Problem 5 : macro / call by name</li>
</ul>

<blockquote><b><tt>&nbsp; &nbsp; #define</tt></b>
swap(a,b) { int t;
t=a;
a=b; b=t; }<br>
then<br>
&nbsp; &nbsp; &nbsp;<b><tt> swap( i, A[i] )</tt></b>
;<br>
becomes<br>
&nbsp; &nbsp; <b><tt>&nbsp;{ int t; t=i;
i=A[i]; A[i]=t; };</tt></b><br>
Both call by name and macro have a "side effect" problem -- changing <i>i</i>'s
r-value changes <i>A</i>[<i>i</i>] l-value.<br>
</blockquote>

<ul>

  <li>Difference between call by name and macros:</li>
</ul>

<blockquote><b><tt>float e =2.71828;<br>
#define p(x) (x/e)<br>
...<br>
int f (int e ) {<br>
&nbsp; &nbsp;...<br>
&nbsp; &nbsp;p(z);<br>
&nbsp; &nbsp;...</tt></b><br>
}<br>
</blockquote>

<ul>

  <li>This example creates a name conflict -- &nbsp;the
compiler sees:<br>
  </li>
</ul>

<blockquote><b><tt>float e =2.71828;<br>
  <br>
...<br>
int f (int e ) {<br>
&nbsp; &nbsp;...<br>
&nbsp; &nbsp;p(z/e); &nbsp;/* DIVIDES the WRONG "e" */<br>
&nbsp; &nbsp;...</tt></b><br>
}<br>
</blockquote>

<ul>

</ul>

<blockquote>
  <ul>
  </ul>
</blockquote>

<ul>

  <li>Macro expansion imports <i>e</i> into the
scope of a different
binding
of <i>e -- </i>a case of <i><b>dynamic
scoping</b></i>.</li>
  <li>Naming problems can be avoided by true call by name
parameter
binding.</li>
</ul>

<dl>

  <hr size="1" width="100%">
  <h4> Some additional variations : Default Parameter Values</h4>
</dl>

<dl>

  <li> Conformant Arrays</li>
  <li> Variable number of arguments </li>
  <li>C++</li>
  <dl>
    <b><tt>int get_word(char*, int &amp;, int start =
0);</tt></b>
    <dl>
      <li> <i>C: Parameter names are not needed in
function prototype</i></li>
    </dl>
    <li> Ada</li>
  </dl>
</dl>

<div style="margin-left: 40px;"><span style="font-family: monospace; font-weight: bold;">
TYPE intptr is ACCESS integer;
</span><p style="font-family: monospace; font-weight: bold;">FUNCTION Get_word(C : String; X : intptr; Start : integer
:= 0 ) </p>
<dl>
&nbsp;&nbsp;
RETURN Integer;
</dl>
</div>

<dl>

  <dl>
  </dl>
  <li> Both languages parameters with default values can be
omitted</li>
  <li> C++ needs the default parameters places at the end of the
list
of
parameters</li>
</dl>

<div style="margin-left: 40px;">
<dl>
  <li> Otherwise, function calls would be ambiguous</li>
</dl>
</div>

<dl>

  <dl>
  </dl>
  <li> Ada the order is normal.</li>
  <li> Ada allows <i>named</i> parameter passing</li>
</dl>

<dl style="margin-left: 80px;">

  <b><tt>V := Get_word( Start =&gt; 1,</tt></b><b><tt>C
=&gt; &#8220;abc&#8221;,</tt></b><b><tt><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp;X =&gt; new integer&#8217;(1)</tt></b><b><tt><br>
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; );</tt></b><br>
</dl>

<dl>

  <ul>
    <dl>
      <dl>
      </dl>
    </dl>
  </ul>
</dl>

<ul>

  <ul>
    <li>The existence of named parameter passing forces Ada to
require
that parameter names be provided in the subprogram declaration.<br>
    </li>
  </ul>
  <li>Python also allows default parameters and named parameters</li>
</ul>

<div style="margin-left: 80px;"><span style="font-family: monospace;">def
func(spam, eggs,
toast=0, ham=0):<br>
&nbsp; &nbsp; &nbsp;print (spam,eggs,toast,ham)<br>
</span></div>

<div style="margin-left: 40px;">
<ul>
  <li>can be invoked by</li>
</ul>
<div style="margin-left: 40px;"><span style="font-family: monospace;"><span style="font-weight: bold;">func(1,2)</span><br>
<br>
OR<br>
<br>
<span style="font-weight: bold;">func(1,ham=1,eggs=0)</span><br>
<br>
Or<br>
<br>
</span><span style="font-family: monospace;"><br>
</span>


<span style="font-family: monospace; font-weight: bold;">func(</span><span style="font-family: monospace;"><span style="font-weight: bold;">spam=1,
eggs=0)</span><br>
<br>
Or<br>
<br>
<span style="font-weight: bold;">func(1,2,3,4)</span></span><br>
</div></div><ul>

</ul>

<dl>

</dl>

<hr width="100%"><br>

<br>

</body></html>