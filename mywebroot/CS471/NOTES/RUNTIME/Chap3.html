<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html><head>


  
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">

  
  <meta name="Author" content="Eileen Head">

  
  <meta name="GENERATOR" content="Mozilla/4.77 [en] (Windows NT 5.0; U) [Netscape]"><title>Names, Scopes, Binding and Routines</title></head><body>
<br>

<center>
<h2 style="text-align: center;"> Chapter 3 <br>
Names, Scopes and Bindings -- Fall 10<br>
</h2>
</center>

<ul>

  <ul>
  </ul>
</ul>

<a href="CODE/scopefig35.py" target="_blank">Simple
Python code example</a><br>

<a href="CODE/scott13P3.py">More complex Python code example</a>
<dl>

  <dl>
    <dl>
      <dl>
        <a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/SimpleSem.gif">
        </a>
      </dl>
    </dl>
  </dl>
  <hr width="100%">
</dl>

<h4>Binding Time:</h4>

<span style="font-style: italic;"></span>
<ul>

  <li><span style="font-style: italic;">binding</span>:
association between two things</li>
  <ul>
    <li>name and object</li>
    <li>object and attributes</li>
  </ul>
  <li><span style="font-style: italic;"><span style="font-style: italic;">binding time</span></span></li>
  <ul>
    <li>Most important concept.</li>
    <li>What are the different times?</li>
    <ul>
      <li>coarse</li>
      <li>fine<span style="font-weight: bold;"></span></li>
    </ul>
    <span style="font-style: italic;"></span>
  </ul>
</ul>

<b>
Object Lifetime and Storage Management</b>
<ul>

  <li> <span style="font-style: italic;">storage
allocation</span> corresponds to&nbsp; the object's lifetime</li>
</ul>

<ul>

  <li>Possible categories</li>
  <ul>
    <li> static objects</li>
    <ul>
      <li>memory created by load time&nbsp;</li>
      <li>lifetime throughout the program's execution</li>
    </ul>
    <li> stack-dynamic objects</li>
    <ul>
      <li>memory allocated at runtime</li>
      <li>lifetime - fifo</li>
    </ul>
    <li> heap-dynamic objects</li>
    <ul>
      <li>memory allocated at runtime</li>
      <li>lifetime - arbitrary </li>
    </ul>
    <li> explicit -- user must create storage</li>
    <li> implicit -- declaring the variable creates storage</li>
  </ul>
</ul>

<div style="margin-left: 80px;"><a href="IMAGES/Runtime.gif"><img src="IMAGES/Runtime.gif" alt="Runtime memory model" style="border: 0px solid ; width: 100px; height: 154px;" border="0" height="304" width="200"></a></div>

<ul>

  <li> Static allocation</li>

<dl style="margin-left: 40px;">
  <li> l-values statically determined (i.e. by load time)</li>
  <li> languages with only static allocation have no recursion</li>
  <li> Fortran</li>
</dl>
</ul>

<ul>

  <dl>
  </dl>
</ul>

<ul>

  <table style="width: 85%; text-align: left; margin-left: auto; margin-right: auto;" border="1" cellpadding="2" cellspacing="2">
    <tbody>
      <tr>
        <td style="vertical-align: top;"><b><tt>int
i = 1, j =
2, k = 3;</tt></b><br>
        <b><tt>void alpha() {</tt></b>
        <dl>
          <b><tt>&nbsp; &nbsp;int i = 4, x = 5;</tt></b><b><tt><br>
&nbsp; &nbsp; &nbsp;...</tt></b><br>
          <b><tt>&nbsp; &nbsp;i += k + x;</tt></b><br>
          <b><tt>&nbsp;&nbsp; &nbsp; ...</tt></b><br>
          <b>};</b>
        </dl>
        <b><tt>void beta() {</tt></b>
        <dl>
          <b><tt>&nbsp; &nbsp;int k = 6;</tt></b><br>
          <b><tt>&nbsp;&nbsp;
&nbsp;&nbsp;
...</tt></b><br>
          <b><tt>&nbsp; &nbsp;i = j + k;</tt></b><br>
          <b><tt>&nbsp; &nbsp;alpha();</tt></b><br>
          <b><tt>&nbsp;&nbsp;&nbsp;
&nbsp;
...</tt></b><br>
          <b>};</b>
        </dl>
        <b><tt>void main() {<br>
        </tt></b><b><tt>&nbsp; &nbsp;
...</tt></b><br>
        <b><tt>&nbsp; beta();</tt></b><br>
        <b><tt>&nbsp; &nbsp; ...</tt></b> <b><tt><br>
}</tt></b><br>
        </td>
        <td align="center" valign="middle"> <a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/2c2.gif"><img style="border: 0px solid ; width: 220px; height: 265px;" src="IMAGES/2c2.gif" alt="Snapshot of Simplesim executing C2 program">
        </a><br>
        </td>
      </tr>
    </tbody>
  </table>
</ul>

<dl>

  <dl>
    <li> <span style="font-weight: bold;">Stack
allocation</span></li>
    <br>
  </dl>
</dl>

<dl style="margin-left: 80px;">

  <a href="IMAGES/SimpleStack.gif"><img style="border: 0px solid ; width: 290px; height: 273px;" src="IMAGES/SimpleStack.gif" alt="Snapshot of Simplesim executing C2 program"></a><br>
</dl>

<dl>

  <br>
  <dl>
    <li> <b><i>Automatic variable</i></b></li>
    <dl>
      <li> Deallocation memory when the variable exits the scope</li>
    </dl>
    <li> Memory usage is predictable</li>
    <li> LIFO stack</li>
    <li>Allows recursion</li>
  </dl>
</dl>

<dl>

</dl>

<dl>

</dl>

<div style="margin-left: 40px;">
<ul>
  <li>Activation records (AR), also called frames</li>
</ul>
<dl style="margin-left: 40px;">
  <a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/IMAGES/2ar2.gif"><img style="border: 0px solid ; width: 150px; height: 146px;" src="IMAGES/2ar2.gif" alt="Addition field in AR allow each call to a routine to have it's own local data" align="middle"></a>
</dl>
</div>

<div style="margin-left: 40px;">
<dl>
  <li> In order to support mutual recursion the definition and
declaration must be able to be separated</li>
</dl>
</div>

<dl>

</dl>

<blockquote><b><tt>int n;</tt></b><br>
</blockquote>

<ul>

  <dl>
    <b><tt>int fact(void) {</tt></b>
    <dl>
      <b><tt>int loc;</tt></b><br>
      <b><tt>if (n&gt;1) {</tt></b>
      <dl>
        <b><tt>loc = n--;</tt></b><br>
        <b><tt>return loc * <font color="#cc33cc">fact()</font>;&nbsp;</tt></b>
      </dl>
      <b><tt>}&nbsp; else&nbsp; {</tt></b>
      <dl>
        <b><tt>return 1; &nbsp;</tt></b>
      </dl>
      <b><tt>}</tt></b>
    </dl>
    <b><tt>}</tt></b><br>
    <b><tt>int main(void) {</tt></b>
    <dl>
      <b><tt>read(n);</tt></b><br>
      <b><tt>if (n&gt;0)</tt></b><br>
      <b><tt>&nbsp;&nbsp;&nbsp; <font color="#3333ff">fact()</font>;&nbsp;</tt></b><br>
      <b><tt>else</tt></b><br>
      <b><tt>&nbsp;&nbsp;&nbsp; print("input
error");</tt></b><br>
      <b><tt>return 0;&nbsp;</tt></b>
    </dl>
    <b><tt>}</tt></b>
  </dl>
</ul>

<ul>

  <dl>
    <p>A&nbsp; <b>dynamic link (control link)&nbsp;</b>
is a
reference (points) to the activation record of the calling
routine.&nbsp;<span style="font-weight: bold;"><span style="font-weight: bold;"><span style="font-style: italic;"></span></span></span></p>
    <p><span style="font-weight: bold;"><span style="font-weight: bold;"><span style="font-style: italic;">Environment&nbsp; pointer</span>
(<span style="font-style: italic;">ep</span>) (also
called the frame
pointer)&nbsp; </span></span>is the register
which points to the current environment (i.e activation record (local
data)) &nbsp;Implementation dependent where in the AR the current
the <span style="font-style: italic; font-weight: bold;">ep</span>
points to.<i><b>,</b></i> we will point to the
first field.<br>
    </p>
  </dl>
</ul>

<blockquote><i><b>Stack ptr</b></i><b> </b>is the register which
points to the next free space on the stack (data memory).<br>
</blockquote>

<blockquote> <b><i>Instruction ptr</i>
&nbsp;</b>is the register which
the address of the instruction currently be executed (in this snapshot)
The instruction address is in code memory and not shown. &nbsp;</blockquote>

<ul>

  <dl>
    <li>In reality there is more information in the AR.
&nbsp;i.e. temp
variables&nbsp;</li>
    <li><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/CODE/fact.c">fact.c</a>
real c code</li>
    <li> <a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/CODE/fact.s">fact.s</a>
assembly code for Intel machines produces using</li>
    <ul>
      <tt><br>
      <big>gcc -S -ansi fact.c</big></tt><big> </big><br>
      <br>
Note that the file assembly file produced by gcc is in ATT syntax.<tt><br>
      </tt>
      <ul style="list-style-type: disc;">
        <li><a href="http://personales.mundivia.es/jap/djasm.htm">DJGPP
QuickAsm Programming Guide</a> is an excellent reference.</li>
        <li><a href="http://www.gnu.org/software/binutils/manual/gas-2.9.1/html_chapter/as_16.html">80386
Dependent Features</a></li>
        <li><a href="http://developer.intel.com/design/pentium/manuals/24319101.pdf">Intel
Architecture Software Developer&#8217;s Manual</a></li>
        <li><a href="http://www.gnu.org/software/ddd/manual/">DDD
-
Data Display Debugger - Table of Contents</a></li>
      </ul>
    </ul>
  </dl>
  <br>
</ul>

<ul>

  <li><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/CODE/factsun.s">factsun.s</a>
assembly code for bingsuns</li>
</ul>

<h4>Constants</h4>

<ul>

  <li>A <span style="font-weight: bold;">constant </span>is
a
language entity that has a fixed value for the duration of it existence.</li>
  <ul>
    <li>literals -- representation of values</li>
    <li>compile time constant &nbsp;(translation time
constants)</li>
    <li>static constant &nbsp;(load time constant)</li>
    <li>manifest constant &nbsp;(a name for a literal)</li>
    <li><span style="font-style: italic;">elaboration
time&nbsp;</span>constants&nbsp;</li>
    
  </ul>
</ul>

<ul>

  <li> Ada allows constants to be evaluated during <span style="font-style: italic;">elaboration</span>.</li>
  <br>
  <tt>procedure Swap ( x,y: in out INTEGER) is</tt>
  <ul>
    <tt>temp: constant INTEGER := x;</tt>
  </ul>
  <tt>begin</tt>
  <ul>
    <tt>x := y;</tt><br>
    <tt>y := temp;</tt>
  </ul>
  <tt>end Swap;<br>
  </tt>
  <li> Java Constants</li>
  <br>
  <tt>class ConstantEx {</tt>
  <ul>
    <tt>void myMethod( int n ) {</tt>
    <ul>
      <tt>final int j = n;</tt><br>
      <tt>System.out.println(j);</tt><br>
      <tt>// j =15;&nbsp; is not legal</tt>
    </ul>
    <tt>}</tt><br>
    <tt>static public void main(String [] a) {</tt>
    <ul>
      <tt>ConstantEx ex = new ConstantEx ();</tt><br>
      <tt>ex.myMethod( 5 );</tt>
    </ul>
    <tt>}</tt>
  </ul>
  <tt>}<br>
  </tt>
  <li>C#</li>
  <ul>
    <li>readonly - runtime</li>
    <li>const - compile time</li>
  </ul>
</ul>

<ul>

  <hr width="100%">
</ul>

<h4>HEAP Storage</h4>

<dl>

  <li> <b><i>Heap </i></b>(not the
data structure <i>heap</i>)&nbsp;</li>
  <li> Memory management hard</li>
</dl>

<ul>

  <li>tradeoff speed vs space</li>
  <ul>
    <li>space -- internal vs external fragmentation</li>
  </ul>
  <li>allocation algorithm (memory management)</li>
  <ul>
    <li>describe</li>
  </ul>
</ul>

Dangling Reference Problem -- object deallocated too soon
<li style="margin-left: 40px;"> Remember dangling (pointer)
reference points to deallocated storage.</li>

<li style="margin-left: 40px;"><a href="IMAGES/4danglingPt.gif">references</a></li>

<div style="margin-left: 40px;">
Creations of two Dangling Pointers ----old C </div>

<dl style="margin-left: 40px;">

/* ppp is the address of a pointer */ <br>
  <b><tt>int * dangle ( int ** ppp) {</tt></b>
  <dl>
    <b><tt>int p = 5; int m = 21;</tt></b><br>
    <b><tt>*ppp = &amp;p&nbsp;&nbsp;</tt></b>/*<font size="-1">
dereference ppp to get the pointer whose address was passed. </font>*/
    <br>
    <b><tt>return &amp;m;</tt></b>
  </dl>
&nbsp;} <br>
main () {
  <dl>
    <b><tt>int k = 17;</tt></b><br>
    <b><tt>int *pm,&nbsp; *pk = &amp;k;</tt></b><br>
    <b><tt>pm = dangle(&amp;pk);</tt></b>&nbsp;<font size="-1">//both
pm and pk point to deallocated memory</font>.
  </dl>
}
  <h6> Fischer&amp;Grodzinsky, The Anatomy of Programming
Languages,
page 237</h6>
</dl>

<ul>

  <li>Garbage collection algorithms&nbsp;</li>
  <ul>
    <li>Reference counting [Collins 1960]</li>
    <ul>
      <li>cycles not reclaimed [Harold-McBeth 1963]</li>
    </ul>
    <li><span style="font-weight: bold;">Tracing
Algorithms</span></li>
    <ul>
      <li>Mark and Sweep [McCarthy 1960]</li>
      <li>Stop and Copy</li>
    </ul>
  </ul>
</ul>

<hr style="width: 100%; height: 2px;">
<h3>Scope</h3>

<ul>

  <li> <b><i>Scope</i></b> is the region
of the program which the
variable can be referred to by using its simple name (identifier).<br>
    <br>
</li>
  <li>What is the difference between <span style="font-style: italic;">lifetime
of a binding </span>and<span style="font-style: italic;"> scope of a
binding?<br>
    <br>
</span></li>
  <li><span style="font-weight: bold;"> Static
scoping </span>(lexical
scoping)<br>
    <br>
</li>
  <ul>
    <li> Visibility of variable follows the structure of the
blocks
they
are written in<br>
      <br>
</li>
    <li> Does not depend on function calls<br>
      <br>
</li>
    <li><span style="font-style: italic;">free</span>
variables (not declared locally)&nbsp; are bound statically<br>
      <br>
 </li>
    <li><b><i>scope hole:</i> </b>when
the name bound to an object
is
hidden by a nested declaration of the same name</li>
    <ul>
      <span style="font-family: monospace; font-weight: bold;">{
int
hide = 1; </span><br style="font-family: monospace; font-weight: bold;">
      <span style="font-family: monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;
{ float hide = 1.0 </span><br style="font-family: monospace; font-weight: bold;">
      <span style="font-family: monospace; font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;
} </span><br style="font-family: monospace; font-weight: bold;">
}
      <br>
      <br>
<li> Ada allows a <i>qualifier</i> to access the
outer declared
variable.</li>
      <ul>
        <li> Ada calls this <b>visibility by selections.</b></li>
      </ul>
      <li> Java allows a qualifier to access a hidden
instance/class
variable<br>
        <br>
</li>
    </ul>
    <li>(pre-99) C only allows declarations at the beginning
blocks<br>
      <br>
</li>
    <li> Algol 68, C++, Java, C-99 allow declarations anywhere<br>
      <br>
    </li>
    <li>When does a declaration come in scope?<br>
      <br>
</li>
    <ul>
      <li>Java, C and C++ vs C# and Pascal</li>
      <li>Java example <a href="../../../../%7Ehead/CS471/NOTES/RUNTIME/CODE/Scope.java">Scope.java</a></li>
      <li>C example <a href="../../../../%7Ehead/CS471/NOTES/RUNTIME/CODE/scope.c">scope.c</a><br>
&nbsp;</li>

    </ul>
    <li>What is the difference between declaration and definition
?</li>
    <dl>
      <dd> <code></code><br>
      </dd>
    </dl>
    <li>Python: scope rules in nested functions:<br>
    </li>
  </ul>
  <dl>
  </dl>
</ul>

<div style="margin-left: 80px;"><a href="CODE/scopefig35.py" target="_blank">Simple
Nested Functions example</a><br>
<a href="CODE/scott13P3.py">Another Nested Function Example</a>
<br>
</div>

<ul>

  <dl>
    <dl>
      <dt>What is the output ?<span style="font-family: monospace;"><br>
        </span></dt>
    </dl>
  </dl>
</ul>

<div style="margin-left: 80px;"><span style="font-family: monospace;">print
outer()<br>
</span><span style="font-family: monospace;">print
i, j</span><br>
</div>

<ul><dl><dl>
      <dl>

  
      </dl>

    </dl>
  </dl>
  <ul>
  </ul>
</ul>

<ul>

  
  <li style="font-weight: bold;"> Dynamic scoping<br>
    <br>
</li>
  <ul>
    <li><span style="font-style: italic;">free </span>variables
are bound dynamically</li>
    <li> visibility of variable depends on sequence of function
calls</li>
    <li> can not determine from written code</li>
    <li> APL, Snobol, early versions of LISP, Perl</li>
  </ul>
</ul>

<dl>

  <dd><span style="font-weight: bold;">Perl</span>
: local variables in
a functions </dd>
</dl>

<ul>

  <ul>
    <dl>
      <li> There are two different ways to create non global
variables.</li>
      <li> <b>STATIC Scoping</b></li>
      <dl>
        <li> <tt>my </tt>function creates a variable<br>
          <br>
</li>
        <dl style="font-weight: bold;">
          <tt>sub sub1 {</tt>
        </dl>
        <tt style="font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
my $sum = 0;</tt><br style="font-weight: bold;">
        <tt style="font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
...</tt><br style="font-weight: bold;">
        <tt style="font-weight: bold;">&nbsp;&nbsp; &nbsp; &nbsp;
}<br>
</tt><br>
whose
        <dl>
          <li> scope is the block</li>
          <li> lifetime is from the execution of the <tt>my </tt>function
to the end of the execution of the block.<br>
            <br>
</li>
        </dl>
      </dl>
      <li> <b>Dynamic Scoping<br>
        <br>
</b></li>
      <dl>
        <li> <tt>local </tt>creates a non-global
variable<br>
          <br>
</li>
&nbsp; <tt style="font-weight: bold;">sub sub1 {</tt><span style="font-weight: bold;"> </span><br style="font-weight: bold;">
        <tt style="font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
local $dyn = 0;</tt><br style="font-weight: bold;">
        <tt style="font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
...</tt>
        <dl style="font-weight: bold;">
&nbsp;<tt>sub2</tt><br>
&nbsp; <tt># after the call to sub2 the value of
$dyn = "wow"</tt>
        </dl>
        <span style="font-weight: bold;">&nbsp; </span><tt style="font-weight: bold;">}</tt><br style="font-weight: bold;">
        <span style="font-weight: bold;">&nbsp; </span><tt style="font-weight: bold;">sub sub2 {</tt><br style="font-weight: bold;">
        <tt style="font-weight: bold;">&nbsp;&nbsp;&nbsp;
# locations
of $dyn is dynamic</tt><span style="font-weight: bold;">
&nbsp; </span><br style="font-weight: bold;">
        <tt style="font-weight: bold;">&nbsp;&nbsp;&nbsp;
$dyn = "wow"</tt><span style="font-weight: bold;">
&nbsp; </span><tt style="font-weight: bold;"><br>
&nbsp;}<br>
        <br>
</tt>
        <li> lifetime is the same as a "<i>my</i>"
variable</li>
        <li> scope is the block in which it is defined as well as
any
function directly or indirectly from that block.</li>
        <li> <i>local</i> is an unfortunate legacy
from earlier
versions of Perl and should be avoided.</li>
      </dl>
    </dl>
  </ul>
</ul>

<center>
<h6> Perl examples taken from "<i>A Little Book on Perl"</i>,
by Robert
Sebesta</h6>
<hr style="width: 100%; height: 2px;"><tt><span style="font-weight: bold;"></span></tt>
<div style="text-align: left;">
<h4>Concepts related to Scope</h4>
<ul>
  <li>Aliases</li>
  <ul>
    <li>What is it?</li>
  </ul>
  <li>Overloading vs Coercion vs Polymorphism</li>
</ul>
<dl>
  <dd><a href="3hJF03.html">Example</a></dd>
</dl>
</div>
</center>

<hr style="width: 100%; height: 2px;">
<h4>Runtime Support of Nested Blocks and
Nested Routines</h4>

<ul>

  <li> C, C++ support nested blocks but not nested
routines</li>
  <br>
  <div style="margin-left: 40px;"><b><tt>int
f(void) {</tt></b></div>
  <dl style="margin-left: 40px;">
    <b><tt>&nbsp; int x,y,w;</tt></b><br>
    <b><tt>&nbsp; while( ...) {</tt></b>
    <dl>
      <b><tt>&nbsp; int x,z;</tt></b><br>
      <b><tt>&nbsp; ...</tt></b><br>
      <b><tt>&nbsp; while (...) {</tt></b>
      <dl>
        <b><tt>int y;</tt></b><br>
        <b><tt>...</tt></b>
      </dl>
      <b><tt>&nbsp; }</tt></b><br>
      <b><tt>&nbsp; if (...) {</tt></b><br>
      <b><tt>&nbsp;&nbsp;&nbsp; int x, w;</tt></b><br>
      <b><tt>&nbsp;&nbsp;&nbsp; ...</tt></b><br>
      <b><tt>&nbsp; }</tt></b>
    </dl>
    <b><tt>&nbsp; }</tt></b><br>
    <b><tt>&nbsp; if (...) {</tt></b><br>
    <b><tt>&nbsp;&nbsp;&nbsp; int a,b,c,d;</tt></b><br>
    <b><tt>&nbsp;&nbsp;&nbsp; ...</tt></b><br>
    <b><tt>&nbsp; }</tt></b>
  </dl>
  <div style="margin-left: 40px;"><b><tt>}</tt></b></div>
  <dl>
    <dl>
&nbsp;
    </dl>
  </dl>
</ul>

<dl style="margin-left: 40px;">

  <li> Pascal, Modula 2, Haskell have nested routines
but not
nested blocks</li>
  <li> Ada and Python have both</li>
  <dd><a href="CODE/scopefig35.py" target="_blank">Simple
Nested Functions example<br>
    </a><a href="nestedPython.pdf">Figures from Text</a></dd>
</dl>

<li style="margin-left: 40px;"> Nested routines need to be
able to find
variable
declared
in the outer routine.</li>

<li style="margin-left: 40px;">Referencing environment</li>

<dl>

</dl>

<h3 style="margin-left: 40px;">Classes of values:<br>
</h3>

<ul>

  <ul>
    <li>"third class" values can only be only be assigned into a
variable.</li>
    <ul>
      <li>subroutines in Ada 83<br>
      </li>
    </ul>
    <li>"second class" values can be&nbsp; passed as a parameter or
assigned into a variable.</li>
    <ul>
      <li>most imperative --Pascal</li>
      <li><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/CODE/nestAv3.py">Nested
function passed as arguments</a><br>
      </li>
    </ul>
    <li>"first class" values:&nbsp; can be returned from a routine,
passed as a parameter or assigned into a variable.</li>
    <ul>
      <li>C#, most scripting languages and ALL functional languages</li>
      <li>closure<br>
      </li>
      <li><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/CODE/firstClassV3.py">Functions
are first class in Python</a></li>
      <li><a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/CODE/nestBv3.py">Nested
functions as returned values</a><br>
      </li>
    </ul>
  </ul>
  <h3>Other issues with passing functions<br>
  </h3>
  <ul>
    <li>Issues - What is the referencing environment of the
function passed?&nbsp;</li>
    <li>Shallow binding&nbsp; vs&nbsp; Deep binding.</li>
    <li>Static scoping is combined with deep binding. &nbsp;</li>
    <ul>
      <li>Shallow binding does not make sense with static scoping.</li>
    </ul>
  </ul>
  <blockquote>
    <table style="width: 700px; height: 377px;" border="0" cellpadding="3" cellspacing="2">
      <tbody>
        <tr>
          <td height="65%" valign="top"><span style="font-family: monospace;">program
binding_example (input,
output);</span><br style="font-family: monospace;">
          <br style="font-family: monospace;">
          <span style="font-family: monospace;">procedure
A (I: integer; procedure P); </span><br style="font-family: monospace;">
          <blockquote style="font-family: monospace;">procedure
B;<br>
begin<br>
&nbsp; &nbsp; writeln (I);<br>
end; &nbsp;(* end of B *)<br>
          </blockquote>
          <span style="font-family: monospace;">begin
&nbsp;(*A*)</span><br style="font-family: monospace;">
          <blockquote style="font-family: monospace;">if <b>&nbsp;I
&gt; 1</b>
then<br>
&nbsp; &nbsp;P<br>
else<br>
&nbsp; &nbsp;A(2,B);<br>
          </blockquote>
          <span style="font-family: monospace;">end;
&nbsp;(* end of A*)</span><br style="font-family: monospace;">
          <br style="font-family: monospace;">
          <span style="font-family: monospace;">procedure
C; begin&nbsp; end;</span><br style="font-family: monospace;">
          <br style="font-family: monospace;">
          <span style="font-family: monospace;">begin
(*main*)</span><br style="font-family: monospace;">
          <span style="font-family: monospace;">&nbsp;
&nbsp; &nbsp; &nbsp;A ( 1, C );</span><br>
          <span style="font-family: monospace;">end</span><br>
          </td>
          <td valign="middle"><i><b>I</b><small> </small></i><small>is
NOT local to "<i><b>B</b></i>".<br>
When<b><i> P</i></b> is called it is "<b><i>B</i></b>" <br>
The question is -- <br>
&nbsp; &nbsp;Where is "<b><i>B</i></b>"
bound to <br>
&nbsp; &nbsp; the &nbsp;"<b><i>A</i></b>"
where "<b><i>B</i></b>" is
declared<br>
&nbsp; or &nbsp; &nbsp;<br>
&nbsp; &nbsp;the "<b><i>A</i></b>"&nbsp;
where "<b><i>B</i></b>" is
passed to?<br>
          <br>
Deep binding :<br>
&nbsp; &nbsp;output 1<br>
          <br>
Shallow binding:<br>
&nbsp; &nbsp;output 2<br>
          <br>
Example Scott 139</small> <br>
          </td>
        </tr>
      </tbody>
    </table>
  </blockquote>
  <ul>
    <li>How could this be implemented at run time?</li>
    <li>Why isn't this an issue in C?</li>
  </ul>
  <br>
  <hr width="100%"><b>Activation
Records
Whose Size Becomes Known at Unit Activation: C5</b>
</ul>

<div style="margin-left: 80px;">
<ul>
  <li> Ada allows the size of local arrays to be decided
during execution.</li>
</ul>
</div>

<ul>

  <ul>
    <dl>
      <dl>
        <li> <i><a name="elaboration">Elaboration</a></i>
is the process by which declarations become active
when&nbsp;encountered in the flow of control. This entails the
creation
of a binding. It may also entails the allocation of stack space for
local objects, and possibly the assignment of initial values.</li>
        <li> The activation record is allocated in several steps</li>
        <dl>
          <li> storage for statically know data and descriptors
of the
dynamic arrays is allocated</li>
          <li> when the declaration of the array is encounted,
dimensions are entered in the descriptor and the size of the array
is evaluated</li>
          <li> AR is extended in Free space to include space
for
the
array</li>
          <li> the pointer in the descriptor is set to this area</li>
        </dl>
      </dl>
    </dl>
    <br>
  </ul>
</ul>

Implementing Dynamic Scoping see&nbsp;<a href="http://bingweb.binghamton.edu/%7Ehead/CS471/NOTES/RUNTIME/4rF05A.html">here</a><br>

<hr style="width: 100%; height: 2px;">
<hr style="width: 100%; height: 2px;">
</body></html>